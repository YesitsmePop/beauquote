"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/PointMaterial.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/PointMaterial.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PointMaterial: () => (/* binding */ PointMaterial),\n/* harmony export */   PointMaterialImpl: () => (/* binding */ PointMaterialImpl)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _helpers_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/constants.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/constants.js\");\n\n\n\n\nconst opaque_fragment = _helpers_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 154 ? 'opaque_fragment' : 'output_fragment';\nclass PointMaterialImpl extends three__WEBPACK_IMPORTED_MODULE_3__.PointsMaterial {\n    constructor(props){\n        super(props);\n        this.onBeforeCompile = (shader, renderer)=>{\n            const { isWebGL2 } = renderer.capabilities;\n            shader.fragmentShader = shader.fragmentShader.replace(`#include <${opaque_fragment}>`, `\n        ${!isWebGL2 ? `#extension GL_OES_standard_derivatives : enable\\n#include <${opaque_fragment}>` : `#include <${opaque_fragment}>`}\n      vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n      float r = dot(cxy, cxy);\n      float delta = fwidth(r);     \n      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\n      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );\n      #include <tonemapping_fragment>\n      #include <${_helpers_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n      `);\n        };\n    }\n}\nconst PointMaterial = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, ref)=>{\n    const [material] = react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        \"PointMaterial.useState\": ()=>new PointMaterialImpl(null)\n    }[\"PointMaterial.useState\"]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n        object: material,\n        ref: ref,\n        attach: \"material\"\n    }));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Qb2ludE1hdGVyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDQTtBQUNtQjtBQUVsRCxNQUFNSSxrQkFBa0JELDBEQUFPQSxJQUFJLE1BQU0sb0JBQW9CO0FBQzdELE1BQU1FLDBCQUEwQkosaURBQW9CO0lBQ2xETSxZQUFZQyxLQUFLLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsZUFBZSxHQUFHLENBQUNDLFFBQVFDO1lBQzlCLE1BQU0sRUFDSkMsUUFBUSxFQUNULEdBQUdELFNBQVNFLFlBQVk7WUFDekJILE9BQU9JLGNBQWMsR0FBR0osT0FBT0ksY0FBYyxDQUFDQyxPQUFPLENBQUMsQ0FBQyxVQUFVLEVBQUVYLGdCQUFnQixDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3RGLEVBQUUsQ0FBQ1EsV0FBVyxDQUFDLDJEQUEyRCxFQUFFUixnQkFBZ0IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUVBLGdCQUFnQixDQUFDLENBQUMsQ0FBQzs7Ozs7OztnQkFPekgsRUFBRUQsMERBQU9BLElBQUksTUFBTSx3QkFBd0IscUJBQXFCO01BQzFFLENBQUM7UUFDSDtJQUNGO0FBQ0Y7QUFDQSxNQUFNYSxnQkFBZ0IsYUFBYSxpQkFBRWQsNkNBQWdCLENBQUMsQ0FBQ00sT0FBT1U7SUFDNUQsTUFBTSxDQUFDQyxTQUFTLEdBQUdqQiwyQ0FBYztrQ0FBQyxJQUFNLElBQUlHLGtCQUFrQjs7SUFDOUQsT0FBTyxXQUFXLEdBQUVILGdEQUFtQixDQUFDLGFBQWFGLDhFQUFRQSxDQUFDLENBQUMsR0FBR1EsT0FBTztRQUN2RWMsUUFBUUg7UUFDUkQsS0FBS0E7UUFDTEssUUFBUTtJQUNWO0FBQ0Y7QUFFNEMiLCJzb3VyY2VzIjpbIkQ6XFxXZWJfQXBwc1xcUmVhY3QtUHJvamVjdHNcXHF1b3RlLWRlY29kZXJcXG5vZGVfbW9kdWxlc1xcQHJlYWN0LXRocmVlXFxkcmVpXFxjb3JlXFxQb2ludE1hdGVyaWFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi9oZWxwZXJzL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IG9wYXF1ZV9mcmFnbWVudCA9IHZlcnNpb24gPj0gMTU0ID8gJ29wYXF1ZV9mcmFnbWVudCcgOiAnb3V0cHV0X2ZyYWdtZW50JztcbmNsYXNzIFBvaW50TWF0ZXJpYWxJbXBsIGV4dGVuZHMgVEhSRUUuUG9pbnRzTWF0ZXJpYWwge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLm9uQmVmb3JlQ29tcGlsZSA9IChzaGFkZXIsIHJlbmRlcmVyKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzV2ViR0wyXG4gICAgICB9ID0gcmVuZGVyZXIuY2FwYWJpbGl0aWVzO1xuICAgICAgc2hhZGVyLmZyYWdtZW50U2hhZGVyID0gc2hhZGVyLmZyYWdtZW50U2hhZGVyLnJlcGxhY2UoYCNpbmNsdWRlIDwke29wYXF1ZV9mcmFnbWVudH0+YCwgYFxuICAgICAgICAkeyFpc1dlYkdMMiA/IGAjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcbiNpbmNsdWRlIDwke29wYXF1ZV9mcmFnbWVudH0+YCA6IGAjaW5jbHVkZSA8JHtvcGFxdWVfZnJhZ21lbnR9PmB9XG4gICAgICB2ZWMyIGN4eSA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XG4gICAgICBmbG9hdCByID0gZG90KGN4eSwgY3h5KTtcbiAgICAgIGZsb2F0IGRlbHRhID0gZndpZHRoKHIpOyAgICAgXG4gICAgICBmbG9hdCBtYXNrID0gMS4wIC0gc21vb3Roc3RlcCgxLjAgLSBkZWx0YSwgMS4wICsgZGVsdGEsIHIpO1xuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChnbF9GcmFnQ29sb3IucmdiLCBtYXNrICogZ2xfRnJhZ0NvbG9yLmEgKTtcbiAgICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cbiAgICAgICNpbmNsdWRlIDwke3ZlcnNpb24gPj0gMTU0ID8gJ2NvbG9yc3BhY2VfZnJhZ21lbnQnIDogJ2VuY29kaW5nc19mcmFnbWVudCd9PlxuICAgICAgYCk7XG4gICAgfTtcbiAgfVxufVxuY29uc3QgUG9pbnRNYXRlcmlhbCA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgW21hdGVyaWFsXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBQb2ludE1hdGVyaWFsSW1wbChudWxsKSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBvYmplY3Q6IG1hdGVyaWFsLFxuICAgIHJlZjogcmVmLFxuICAgIGF0dGFjaDogXCJtYXRlcmlhbFwiXG4gIH0pKTtcbn0pO1xuXG5leHBvcnQgeyBQb2ludE1hdGVyaWFsLCBQb2ludE1hdGVyaWFsSW1wbCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiVEhSRUUiLCJSZWFjdCIsInZlcnNpb24iLCJvcGFxdWVfZnJhZ21lbnQiLCJQb2ludE1hdGVyaWFsSW1wbCIsIlBvaW50c01hdGVyaWFsIiwiY29uc3RydWN0b3IiLCJwcm9wcyIsIm9uQmVmb3JlQ29tcGlsZSIsInNoYWRlciIsInJlbmRlcmVyIiwiaXNXZWJHTDIiLCJjYXBhYmlsaXRpZXMiLCJmcmFnbWVudFNoYWRlciIsInJlcGxhY2UiLCJQb2ludE1hdGVyaWFsIiwiZm9yd2FyZFJlZiIsInJlZiIsIm1hdGVyaWFsIiwidXNlU3RhdGUiLCJjcmVhdGVFbGVtZW50Iiwib2JqZWN0IiwiYXR0YWNoIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/PointMaterial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Points.js":
/*!*******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Points.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Points: () => (/* binding */ Points),\n/* harmony export */   PointsBuffer: () => (/* binding */ PointsBuffer),\n/* harmony export */   PositionPoint: () => (/* binding */ PositionPoint)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_extend_useFrame_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=extend,useFrame!=!@react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js\");\n\n\n\n\nconst _inverseMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\nconst _ray = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_2__.Ray();\nconst _sphere = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_2__.Sphere();\nconst _position = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nclass PositionPoint extends three__WEBPACK_IMPORTED_MODULE_2__.Group {\n    constructor(){\n        super();\n        this.size = 0;\n        this.color = new three__WEBPACK_IMPORTED_MODULE_2__.Color('white');\n        this.instance = {\n            current: undefined\n        };\n        this.instanceKey = {\n            current: undefined\n        };\n    }\n    // This will allow the virtual instance have bounds\n    get geometry() {\n        var _this$instance$curren;\n        return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;\n    }\n    raycast(raycaster, intersects) {\n        var _raycaster$params$Poi, _raycaster$params$Poi2;\n        const parent = this.instance.current;\n        if (!parent || !parent.geometry) return;\n        const instanceId = parent.userData.instances.indexOf(this.instanceKey);\n        // If the instance wasn't found or exceeds the parents draw range, bail out\n        if (instanceId === -1 || instanceId > parent.geometry.drawRange.count) return;\n        const threshold = (_raycaster$params$Poi = (_raycaster$params$Poi2 = raycaster.params.Points) == null ? void 0 : _raycaster$params$Poi2.threshold) !== null && _raycaster$params$Poi !== void 0 ? _raycaster$params$Poi : 1;\n        _sphere.set(this.getWorldPosition(_position), threshold);\n        if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n        _inverseMatrix.copy(parent.matrixWorld).invert();\n        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n        const localThresholdSq = localThreshold * localThreshold;\n        const rayPointDistanceSq = _ray.distanceSqToPoint(this.position);\n        if (rayPointDistanceSq < localThresholdSq) {\n            const intersectPoint = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n            _ray.closestPointToPoint(this.position, intersectPoint);\n            intersectPoint.applyMatrix4(this.matrixWorld);\n            const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n            if (distance < raycaster.near || distance > raycaster.far) return;\n            intersects.push({\n                distance: distance,\n                distanceToRay: Math.sqrt(rayPointDistanceSq),\n                point: intersectPoint,\n                index: instanceId,\n                face: null,\n                object: this\n            });\n        }\n    }\n}\nlet i, positionRef;\nconst context = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nconst parentMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\nconst position = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n/**\n * Instance implementation, relies on react + context to update the attributes based on the children of this component\n */ const PointsInstances = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ children, range, limit = 1000, ...props }, ref)=>{\n    const parentRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, {\n        \"PointsInstances.useImperativeHandle\": ()=>parentRef.current\n    }[\"PointsInstances.useImperativeHandle\"], []);\n    const [refs, setRefs] = react__WEBPACK_IMPORTED_MODULE_1__.useState([]);\n    const [[positions, colors, sizes]] = react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        \"PointsInstances.useState\": ()=>[\n                new Float32Array(limit * 3),\n                Float32Array.from({\n                    length: limit * 3\n                }, {\n                    \"PointsInstances.useState\": ()=>1\n                }[\"PointsInstances.useState\"]),\n                Float32Array.from({\n                    length: limit\n                }, {\n                    \"PointsInstances.useState\": ()=>1\n                }[\"PointsInstances.useState\"])\n            ]\n    }[\"PointsInstances.useState\"]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"PointsInstances.useEffect\": ()=>{\n            // We might be a frame too late? 🤷‍♂️\n            parentRef.current.geometry.attributes.position.needsUpdate = true;\n        }\n    }[\"PointsInstances.useEffect\"]);\n    (0,_barrel_optimize_names_extend_useFrame_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.D)({\n        \"PointsInstances.useFrame\": ()=>{\n            parentRef.current.updateMatrix();\n            parentRef.current.updateMatrixWorld();\n            parentMatrix.copy(parentRef.current.matrixWorld).invert();\n            parentRef.current.geometry.drawRange.count = Math.min(limit, range !== undefined ? range : limit, refs.length);\n            for(i = 0; i < refs.length; i++){\n                positionRef = refs[i].current;\n                positionRef.getWorldPosition(position).applyMatrix4(parentMatrix);\n                position.toArray(positions, i * 3);\n                parentRef.current.geometry.attributes.position.needsUpdate = true;\n                positionRef.matrixWorldNeedsUpdate = true;\n                positionRef.color.toArray(colors, i * 3);\n                parentRef.current.geometry.attributes.color.needsUpdate = true;\n                sizes.set([\n                    positionRef.size\n                ], i);\n                parentRef.current.geometry.attributes.size.needsUpdate = true;\n            }\n        }\n    }[\"PointsInstances.useFrame\"]);\n    const api = react__WEBPACK_IMPORTED_MODULE_1__.useMemo({\n        \"PointsInstances.useMemo[api]\": ()=>({\n                getParent: ({\n                    \"PointsInstances.useMemo[api]\": ()=>parentRef\n                })[\"PointsInstances.useMemo[api]\"],\n                subscribe: ({\n                    \"PointsInstances.useMemo[api]\": (ref)=>{\n                        setRefs({\n                            \"PointsInstances.useMemo[api]\": (refs)=>[\n                                    ...refs,\n                                    ref\n                                ]\n                        }[\"PointsInstances.useMemo[api]\"]);\n                        return ({\n                            \"PointsInstances.useMemo[api]\": ()=>setRefs({\n                                    \"PointsInstances.useMemo[api]\": (refs)=>refs.filter({\n                                            \"PointsInstances.useMemo[api]\": (item)=>item.current !== ref.current\n                                        }[\"PointsInstances.useMemo[api]\"])\n                                }[\"PointsInstances.useMemo[api]\"])\n                        })[\"PointsInstances.useMemo[api]\"];\n                    }\n                })[\"PointsInstances.useMemo[api]\"]\n            })\n    }[\"PointsInstances.useMemo[api]\"], []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"points\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        userData: {\n            instances: refs\n        },\n        matrixAutoUpdate: false,\n        ref: parentRef,\n        raycast: ()=>null\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferGeometry\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-position\",\n        args: [\n            positions,\n            3\n        ],\n        usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-color\",\n        args: [\n            colors,\n            3\n        ],\n        usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-size\",\n        args: [\n            sizes,\n            1\n        ],\n        usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(context.Provider, {\n        value: api\n    }, children));\n});\nconst Point = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ children, ...props }, ref)=>{\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo({\n        \"Point.useMemo\": ()=>(0,_barrel_optimize_names_extend_useFrame_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.e)({\n                PositionPoint\n            })\n    }[\"Point.useMemo\"], []);\n    const group = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, {\n        \"Point.useImperativeHandle\": ()=>group.current\n    }[\"Point.useImperativeHandle\"], []);\n    const { subscribe, getParent } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(context);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect({\n        \"Point.useLayoutEffect\": ()=>subscribe(group)\n    }[\"Point.useLayoutEffect\"], []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"positionPoint\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        instance: getParent(),\n        instanceKey: group,\n        ref: group\n    }, props), children);\n});\n/**\n * Buffer implementation, relies on complete buffers of the correct number, leaves it to the user to update them\n */ const PointsBuffer = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ children, positions, colors, sizes, stride = 3, ...props }, forwardedRef)=>{\n    const pointsRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(forwardedRef, {\n        \"PointsBuffer.useImperativeHandle\": ()=>pointsRef.current\n    }[\"PointsBuffer.useImperativeHandle\"], []);\n    (0,_barrel_optimize_names_extend_useFrame_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.D)({\n        \"PointsBuffer.useFrame\": ()=>{\n            const attr = pointsRef.current.geometry.attributes;\n            attr.position.needsUpdate = true;\n            if (colors) attr.color.needsUpdate = true;\n            if (sizes) attr.size.needsUpdate = true;\n        }\n    }[\"PointsBuffer.useFrame\"]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"points\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: pointsRef\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferGeometry\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-position\",\n        args: [\n            positions,\n            stride\n        ],\n        usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n    }), colors && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-color\",\n        args: [\n            colors,\n            stride\n        ],\n        count: colors.length / stride,\n        usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n    }), sizes && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-size\",\n        args: [\n            sizes,\n            1\n        ],\n        count: sizes.length / stride,\n        usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n    })), children);\n});\nconst Points = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, forwardedRef)=>{\n    if (props.positions instanceof Float32Array) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(PointsBuffer, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n            ref: forwardedRef\n        }));\n    } else return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(PointsInstances, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n        ref: forwardedRef\n    }));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Qb2ludHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzNCO0FBQ0E7QUFDdUI7QUFFdEQsTUFBTUssaUJBQWlCLGFBQWEsR0FBRSxJQUFJSiwwQ0FBYTtBQUN2RCxNQUFNTSxPQUFPLGFBQWEsR0FBRSxJQUFJTixzQ0FBUztBQUN6QyxNQUFNUSxVQUFVLGFBQWEsR0FBRSxJQUFJUix5Q0FBWTtBQUMvQyxNQUFNVSxZQUFZLGFBQWEsR0FBRSxJQUFJViwwQ0FBYTtBQUNsRCxNQUFNWSxzQkFBc0JaLHdDQUFXO0lBQ3JDYyxhQUFjO1FBQ1osS0FBSztRQUNMLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxLQUFLLEdBQUcsSUFBSWhCLHdDQUFXLENBQUM7UUFDN0IsSUFBSSxDQUFDa0IsUUFBUSxHQUFHO1lBQ2RDLFNBQVNDO1FBQ1g7UUFDQSxJQUFJLENBQUNDLFdBQVcsR0FBRztZQUNqQkYsU0FBU0M7UUFDWDtJQUNGO0lBRUEsbURBQW1EO0lBQ25ELElBQUlFLFdBQVc7UUFDYixJQUFJQztRQUNKLE9BQU8sQ0FBQ0Esd0JBQXdCLElBQUksQ0FBQ0wsUUFBUSxDQUFDQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlJLHNCQUFzQkQsUUFBUTtJQUMxRztJQUNBRSxRQUFRQyxTQUFTLEVBQUVDLFVBQVUsRUFBRTtRQUM3QixJQUFJQyx1QkFBdUJDO1FBQzNCLE1BQU1DLFNBQVMsSUFBSSxDQUFDWCxRQUFRLENBQUNDLE9BQU87UUFDcEMsSUFBSSxDQUFDVSxVQUFVLENBQUNBLE9BQU9QLFFBQVEsRUFBRTtRQUNqQyxNQUFNUSxhQUFhRCxPQUFPRSxRQUFRLENBQUNDLFNBQVMsQ0FBQ0MsT0FBTyxDQUFDLElBQUksQ0FBQ1osV0FBVztRQUNyRSwyRUFBMkU7UUFDM0UsSUFBSVMsZUFBZSxDQUFDLEtBQUtBLGFBQWFELE9BQU9QLFFBQVEsQ0FBQ1ks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VyxHQUFFekYsZ0RBQW1CLENBQUMsbUJBQW1CO1FBQ2hFOEcsUUFBUTtRQUNSQyxNQUFNO1lBQUN0QjtZQUFRZ0M7U0FBTztRQUN0QnZGLE9BQU91RCxPQUFPSSxNQUFNLEdBQUc0QjtRQUN2QlQsT0FBT2pILG1EQUFzQjtJQUMvQixJQUFJMkYsU0FBUyxXQUFXLEdBQUUxRixnREFBbUIsQ0FBQyxtQkFBbUI7UUFDL0Q4RyxRQUFRO1FBQ1JDLE1BQU07WUFBQ3JCO1lBQU87U0FBRTtRQUNoQnhELE9BQU93RCxNQUFNRyxNQUFNLEdBQUc0QjtRQUN0QlQsT0FBT2pILG1EQUFzQjtJQUMvQixLQUFLOEU7QUFDUDtBQUNBLE1BQU14QyxTQUFTLGFBQWEsaUJBQUVyQyw2Q0FBZ0IsQ0FBQyxDQUFDZ0YsT0FBTzBDO0lBQ3JELElBQUkxQyxNQUFNUSxTQUFTLFlBQVlHLGNBQWM7UUFDM0MsT0FBTyxXQUFXLEdBQUUzRixnREFBbUIsQ0FBQ3dILGNBQWMxSCw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdrRixPQUFPO1lBQ3hFQyxLQUFLeUM7UUFDUDtJQUNGLE9BQU8sT0FBTyxXQUFXLEdBQUUxSCxnREFBbUIsQ0FBQzJFLGlCQUFpQjdFLDhFQUFRQSxDQUFDLENBQUMsR0FBR2tGLE9BQU87UUFDbEZDLEtBQUt5QztJQUNQO0FBQ0Y7QUFFc0QiLCJzb3VyY2VzIjpbIkQ6XFxXZWJfQXBwc1xcUmVhY3QtUHJvamVjdHNcXHF1b3RlLWRlY29kZXJcXG5vZGVfbW9kdWxlc1xcQHJlYWN0LXRocmVlXFxkcmVpXFxjb3JlXFxQb2ludHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZXh0ZW5kLCB1c2VGcmFtZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5cbmNvbnN0IF9pbnZlcnNlTWF0cml4ID0gLyogQF9fUFVSRV9fICovbmV3IFRIUkVFLk1hdHJpeDQoKTtcbmNvbnN0IF9yYXkgPSAvKiBAX19QVVJFX18gKi9uZXcgVEhSRUUuUmF5KCk7XG5jb25zdCBfc3BoZXJlID0gLyogQF9fUFVSRV9fICovbmV3IFRIUkVFLlNwaGVyZSgpO1xuY29uc3QgX3Bvc2l0aW9uID0gLyogQF9fUFVSRV9fICovbmV3IFRIUkVFLlZlY3RvcjMoKTtcbmNsYXNzIFBvc2l0aW9uUG9pbnQgZXh0ZW5kcyBUSFJFRS5Hcm91cCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCd3aGl0ZScpO1xuICAgIHRoaXMuaW5zdGFuY2UgPSB7XG4gICAgICBjdXJyZW50OiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHRoaXMuaW5zdGFuY2VLZXkgPSB7XG4gICAgICBjdXJyZW50OiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgLy8gVGhpcyB3aWxsIGFsbG93IHRoZSB2aXJ0dWFsIGluc3RhbmNlIGhhdmUgYm91bmRzXG4gIGdldCBnZW9tZXRyeSgpIHtcbiAgICB2YXIgX3RoaXMkaW5zdGFuY2UkY3VycmVuO1xuICAgIHJldHVybiAoX3RoaXMkaW5zdGFuY2UkY3VycmVuID0gdGhpcy5pbnN0YW5jZS5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaW5zdGFuY2UkY3VycmVuLmdlb21ldHJ5O1xuICB9XG4gIHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG4gICAgdmFyIF9yYXljYXN0ZXIkcGFyYW1zJFBvaSwgX3JheWNhc3RlciRwYXJhbXMkUG9pMjtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmluc3RhbmNlLmN1cnJlbnQ7XG4gICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC5nZW9tZXRyeSkgcmV0dXJuO1xuICAgIGNvbnN0IGluc3RhbmNlSWQgPSBwYXJlbnQudXNlckRhdGEuaW5zdGFuY2VzLmluZGV4T2YodGhpcy5pbnN0YW5jZUtleSk7XG4gICAgLy8gSWYgdGhlIGluc3RhbmNlIHdhc24ndCBmb3VuZCBvciBleGNlZWRzIHRoZSBwYXJlbnRzIGRyYXcgcmFuZ2UsIGJhaWwgb3V0XG4gICAgaWYgKGluc3RhbmNlSWQgPT09IC0xIHx8IGluc3RhbmNlSWQgPiBwYXJlbnQuZ2VvbWV0cnkuZHJhd1JhbmdlLmNvdW50KSByZXR1cm47XG4gICAgY29uc3QgdGhyZXNob2xkID0gKF9yYXljYXN0ZXIkcGFyYW1zJFBvaSA9IChfcmF5Y2FzdGVyJHBhcmFtcyRQb2kyID0gcmF5Y2FzdGVyLnBhcmFtcy5Qb2ludHMpID09IG51bGwgPyB2b2lkIDAgOiBfcmF5Y2FzdGVyJHBhcmFtcyRQb2kyLnRocmVzaG9sZCkgIT09IG51bGwgJiYgX3JheWNhc3RlciRwYXJhbXMkUG9pICE9PSB2b2lkIDAgPyBfcmF5Y2FzdGVyJHBhcmFtcyRQb2kgOiAxO1xuICAgIF9zcGhlcmUuc2V0KHRoaXMuZ2V0V29ybGRQb3NpdGlvbihfcG9zaXRpb24pLCB0aHJlc2hvbGQpO1xuICAgIGlmIChyYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoX3NwaGVyZSkgPT09IGZhbHNlKSByZXR1cm47XG4gICAgX2ludmVyc2VNYXRyaXguY29weShwYXJlbnQubWF0cml4V29ybGQpLmludmVydCgpO1xuICAgIF9yYXkuY29weShyYXljYXN0ZXIucmF5KS5hcHBseU1hdHJpeDQoX2ludmVyc2VNYXRyaXgpO1xuICAgIGNvbnN0IGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCh0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnopIC8gMyk7XG4gICAgY29uc3QgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG4gICAgY29uc3QgcmF5UG9pbnREaXN0YW5jZVNxID0gX3JheS5kaXN0YW5jZVNxVG9Qb2ludCh0aGlzLnBvc2l0aW9uKTtcbiAgICBpZiAocmF5UG9pbnREaXN0YW5jZVNxIDwgbG9jYWxUaHJlc2hvbGRTcSkge1xuICAgICAgY29uc3QgaW50ZXJzZWN0UG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgX3JheS5jbG9zZXN0UG9pbnRUb1BvaW50KHRoaXMucG9zaXRpb24sIGludGVyc2VjdFBvaW50KTtcbiAgICAgIGludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhpbnRlcnNlY3RQb2ludCk7XG4gICAgICBpZiAoZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIpIHJldHVybjtcbiAgICAgIGludGVyc2VjdHMucHVzaCh7XG4gICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgZGlzdGFuY2VUb1JheTogTWF0aC5zcXJ0KHJheVBvaW50RGlzdGFuY2VTcSksXG4gICAgICAgIHBvaW50OiBpbnRlcnNlY3RQb2ludCxcbiAgICAgICAgaW5kZXg6IGluc3RhbmNlSWQsXG4gICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgIG9iamVjdDogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5sZXQgaSwgcG9zaXRpb25SZWY7XG5jb25zdCBjb250ZXh0ID0gLyogQF9fUFVSRV9fICovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IHBhcmVudE1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqL25ldyBUSFJFRS5NYXRyaXg0KCk7XG5jb25zdCBwb3NpdGlvbiA9IC8qIEBfX1BVUkVfXyAqL25ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbi8qKlxuICogSW5zdGFuY2UgaW1wbGVtZW50YXRpb24sIHJlbGllcyBvbiByZWFjdCArIGNvbnRleHQgdG8gdXBkYXRlIHRoZSBhdHRyaWJ1dGVzIGJhc2VkIG9uIHRoZSBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudFxuICovXG5jb25zdCBQb2ludHNJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIGNoaWxkcmVuLFxuICByYW5nZSxcbiAgbGltaXQgPSAxMDAwLFxuICAuLi5wcm9wc1xufSwgcmVmKSA9PiB7XG4gIGNvbnN0IHBhcmVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHBhcmVudFJlZi5jdXJyZW50LCBbXSk7XG4gIGNvbnN0IFtyZWZzLCBzZXRSZWZzXSA9IFJlYWN0LnVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW1twb3NpdGlvbnMsIGNvbG9ycywgc2l6ZXNdXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IFtuZXcgRmxvYXQzMkFycmF5KGxpbWl0ICogMyksIEZsb2F0MzJBcnJheS5mcm9tKHtcbiAgICBsZW5ndGg6IGxpbWl0ICogM1xuICB9LCAoKSA9PiAxKSwgRmxvYXQzMkFycmF5LmZyb20oe1xuICAgIGxlbmd0aDogbGltaXRcbiAgfSwgKCkgPT4gMSldKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBXZSBtaWdodCBiZSBhIGZyYW1lIHRvbyBsYXRlPyDwn6S34oCN4pmC77iPXG4gICAgcGFyZW50UmVmLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH0pO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgcGFyZW50UmVmLmN1cnJlbnQudXBkYXRlTWF0cml4KCk7XG4gICAgcGFyZW50UmVmLmN1cnJlbnQudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICBwYXJlbnRNYXRyaXguY29weShwYXJlbnRSZWYuY3VycmVudC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG4gICAgcGFyZW50UmVmLmN1cnJlbnQuZ2VvbWV0cnkuZHJhd1JhbmdlLmNvdW50ID0gTWF0aC5taW4obGltaXQsIHJhbmdlICE9PSB1bmRlZmluZWQgPyByYW5nZSA6IGxpbWl0LCByZWZzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHJlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvc2l0aW9uUmVmID0gcmVmc1tpXS5jdXJyZW50O1xuICAgICAgcG9zaXRpb25SZWYuZ2V0V29ybGRQb3NpdGlvbihwb3NpdGlvbikuYXBwbHlNYXRyaXg0KHBhcmVudE1hdHJpeCk7XG4gICAgICBwb3NpdGlvbi50b0FycmF5KHBvc2l0aW9ucywgaSAqIDMpO1xuICAgICAgcGFyZW50UmVmLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICBwb3NpdGlvblJlZi5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHBvc2l0aW9uUmVmLmNvbG9yLnRvQXJyYXkoY29sb3JzLCBpICogMyk7XG4gICAgICBwYXJlbnRSZWYuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHNpemVzLnNldChbcG9zaXRpb25SZWYuc2l6ZV0sIGkpO1xuICAgICAgcGFyZW50UmVmLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcy5zaXplLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBhcGkgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZ2V0UGFyZW50OiAoKSA9PiBwYXJlbnRSZWYsXG4gICAgc3Vic2NyaWJlOiByZWYgPT4ge1xuICAgICAgc2V0UmVmcyhyZWZzID0+IFsuLi5yZWZzLCByZWZdKTtcbiAgICAgIHJldHVybiAoKSA9PiBzZXRSZWZzKHJlZnMgPT4gcmVmcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmN1cnJlbnQgIT09IHJlZi5jdXJyZW50KSk7XG4gICAgfVxuICB9KSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2ludHNcIiwgX2V4dGVuZHMoe1xuICAgIHVzZXJEYXRhOiB7XG4gICAgICBpbnN0YW5jZXM6IHJlZnNcbiAgICB9LFxuICAgIG1hdHJpeEF1dG9VcGRhdGU6IGZhbHNlLFxuICAgIHJlZjogcGFyZW50UmVmLFxuICAgIHJheWNhc3Q6ICgpID0+IG51bGxcbiAgfSwgcHJvcHMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckdlb21ldHJ5XCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIsIHtcbiAgICBhdHRhY2g6IFwiYXR0cmlidXRlcy1wb3NpdGlvblwiLFxuICAgIGFyZ3M6IFtwb3NpdGlvbnMsIDNdLFxuICAgIHVzYWdlOiBUSFJFRS5EeW5hbWljRHJhd1VzYWdlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLCB7XG4gICAgYXR0YWNoOiBcImF0dHJpYnV0ZXMtY29sb3JcIixcbiAgICBhcmdzOiBbY29sb3JzLCAzXSxcbiAgICB1c2FnZTogVEhSRUUuRHluYW1pY0RyYXdVc2FnZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIiwge1xuICAgIGF0dGFjaDogXCJhdHRyaWJ1dGVzLXNpemVcIixcbiAgICBhcmdzOiBbc2l6ZXMsIDFdLFxuICAgIHVzYWdlOiBUSFJFRS5EeW5hbWljRHJhd1VzYWdlXG4gIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhcGlcbiAgfSwgY2hpbGRyZW4pKTtcbn0pO1xuY29uc3QgUG9pbnQgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIGNoaWxkcmVuLFxuICAuLi5wcm9wc1xufSwgcmVmKSA9PiB7XG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4gZXh0ZW5kKHtcbiAgICBQb3NpdGlvblBvaW50XG4gIH0pLCBbXSk7XG4gIGNvbnN0IGdyb3VwID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gZ3JvdXAuY3VycmVudCwgW10pO1xuICBjb25zdCB7XG4gICAgc3Vic2NyaWJlLFxuICAgIGdldFBhcmVudFxuICB9ID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHN1YnNjcmliZShncm91cCksIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicG9zaXRpb25Qb2ludFwiLCBfZXh0ZW5kcyh7XG4gICAgaW5zdGFuY2U6IGdldFBhcmVudCgpLFxuICAgIGluc3RhbmNlS2V5OiBncm91cCxcbiAgICByZWY6IGdyb3VwXG4gIH0sIHByb3BzKSwgY2hpbGRyZW4pO1xufSk7XG5cbi8qKlxuICogQnVmZmVyIGltcGxlbWVudGF0aW9uLCByZWxpZXMgb24gY29tcGxldGUgYnVmZmVycyBvZiB0aGUgY29ycmVjdCBudW1iZXIsIGxlYXZlcyBpdCB0byB0aGUgdXNlciB0byB1cGRhdGUgdGhlbVxuICovXG5cbmNvbnN0IFBvaW50c0J1ZmZlciA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgY2hpbGRyZW4sXG4gIHBvc2l0aW9ucyxcbiAgY29sb3JzLFxuICBzaXplcyxcbiAgc3RyaWRlID0gMyxcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCBwb2ludHNSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiBwb2ludHNSZWYuY3VycmVudCwgW10pO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgY29uc3QgYXR0ciA9IHBvaW50c1JlZi5jdXJyZW50Lmdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgYXR0ci5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgaWYgKGNvbG9ycykgYXR0ci5jb2xvci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgaWYgKHNpemVzKSBhdHRyLnNpemUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicG9pbnRzXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHBvaW50c1JlZlxuICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyR2VvbWV0cnlcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIiwge1xuICAgIGF0dGFjaDogXCJhdHRyaWJ1dGVzLXBvc2l0aW9uXCIsXG4gICAgYXJnczogW3Bvc2l0aW9ucywgc3RyaWRlXSxcbiAgICB1c2FnZTogVEhSRUUuRHluYW1pY0RyYXdVc2FnZVxuICB9KSwgY29sb3JzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIsIHtcbiAgICBhdHRhY2g6IFwiYXR0cmlidXRlcy1jb2xvclwiLFxuICAgIGFyZ3M6IFtjb2xvcnMsIHN0cmlkZV0sXG4gICAgY291bnQ6IGNvbG9ycy5sZW5ndGggLyBzdHJpZGUsXG4gICAgdXNhZ2U6IFRIUkVFLkR5bmFtaWNEcmF3VXNhZ2VcbiAgfSksIHNpemVzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIsIHtcbiAgICBhdHRhY2g6IFwiYXR0cmlidXRlcy1zaXplXCIsXG4gICAgYXJnczogW3NpemVzLCAxXSxcbiAgICBjb3VudDogc2l6ZXMubGVuZ3RoIC8gc3RyaWRlLFxuICAgIHVzYWdlOiBUSFJFRS5EeW5hbWljRHJhd1VzYWdlXG4gIH0pKSwgY2hpbGRyZW4pO1xufSk7XG5jb25zdCBQb2ludHMgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGlmIChwcm9wcy5wb3NpdGlvbnMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUG9pbnRzQnVmZmVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHJlZjogZm9yd2FyZGVkUmVmXG4gICAgfSkpO1xuICB9IGVsc2UgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvaW50c0luc3RhbmNlcywgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgcmVmOiBmb3J3YXJkZWRSZWZcbiAgfSkpO1xufSk7XG5cbmV4cG9ydCB7IFBvaW50LCBQb2ludHMsIFBvaW50c0J1ZmZlciwgUG9zaXRpb25Qb2ludCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiVEhSRUUiLCJSZWFjdCIsImV4dGVuZCIsInVzZUZyYW1lIiwiX2ludmVyc2VNYXRyaXgiLCJNYXRyaXg0IiwiX3JheSIsIlJheSIsIl9zcGhlcmUiLCJTcGhlcmUiLCJfcG9zaXRpb24iLCJWZWN0b3IzIiwiUG9zaXRpb25Qb2ludCIsIkdyb3VwIiwiY29uc3RydWN0b3IiLCJzaXplIiwiY29sb3IiLCJDb2xvciIsImluc3RhbmNlIiwiY3VycmVudCIsInVuZGVmaW5lZCIsImluc3RhbmNlS2V5IiwiZ2VvbWV0cnkiLCJfdGhpcyRpbnN0YW5jZSRjdXJyZW4iLCJyYXljYXN0IiwicmF5Y2FzdGVyIiwiaW50ZXJzZWN0cyIsIl9yYXljYXN0ZXIkcGFyYW1zJFBvaSIsIl9yYXljYXN0ZXIkcGFyYW1zJFBvaTIiLCJwYXJlbnQiLCJpbnN0YW5jZUlkIiwidXNlckRhdGEiLCJpbnN0YW5jZXMiLCJpbmRleE9mIiwiZHJhd1JhbmdlIiwiY291bnQiLCJ0aHJlc2hvbGQiLCJwYXJhbXMiLCJQb2ludHMiLCJzZXQiLCJnZXRXb3JsZFBvc2l0aW9uIiwicmF5IiwiaW50ZXJzZWN0c1NwaGVyZSIsImNvcHkiLCJtYXRyaXhXb3JsZCIsImludmVydCIsImFwcGx5TWF0cml4NCIsImxvY2FsVGhyZXNob2xkIiwic2NhbGUiLCJ4IiwieSIsInoiLCJsb2NhbFRocmVzaG9sZFNxIiwicmF5UG9pbnREaXN0YW5jZVNxIiwiZGlzdGFuY2VTcVRvUG9pbnQiLCJwb3NpdGlvbiIsImludGVyc2VjdFBvaW50IiwiY2xvc2VzdFBvaW50VG9Qb2ludCIsImRpc3RhbmNlIiwib3JpZ2luIiwiZGlzdGFuY2VUbyIsIm5lYXIiLCJmYXIiLCJwdXNoIiwiZGlzdGFuY2VUb1JheSIsIk1hdGgiLCJzcXJ0IiwicG9pbnQiLCJpbmRleCIsImZhY2UiLCJvYmplY3QiLCJpIiwicG9zaXRpb25SZWYiLCJjb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInBhcmVudE1hdHJpeCIsIlBvaW50c0luc3RhbmNlcyIsImZvcndhcmRSZWYiLCJjaGlsZHJlbiIsInJhbmdlIiwibGltaXQiLCJwcm9wcyIsInJlZiIsInBhcmVudFJlZiIsInVzZVJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJyZWZzIiwic2V0UmVmcyIsInVzZVN0YXRlIiwicG9zaXRpb25zIiwiY29sb3JzIiwic2l6ZXMiLCJGbG9hdDMyQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwidXNlRWZmZWN0IiwiYXR0cmlidXRlcyIsIm5lZWRzVXBkYXRlIiwidXBkYXRlTWF0cml4IiwidXBkYXRlTWF0cml4V29ybGQiLCJtaW4iLCJ0b0FycmF5IiwibWF0cml4V29ybGROZWVkc1VwZGF0ZSIsImFwaSIsInVzZU1lbW8iLCJnZXRQYXJlbnQiLCJzdWJzY3JpYmUiLCJmaWx0ZXIiLCJpdGVtIiwiY3JlYXRlRWxlbWVudCIsIm1hdHJpeEF1dG9VcGRhdGUiLCJhdHRhY2giLCJhcmdzIiwidXNhZ2UiLCJEeW5hbWljRHJhd1VzYWdlIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIlBvaW50IiwiZ3JvdXAiLCJ1c2VDb250ZXh0IiwidXNlTGF5b3V0RWZmZWN0IiwiUG9pbnRzQnVmZmVyIiwic3RyaWRlIiwiZm9yd2FyZGVkUmVmIiwicG9pbnRzUmVmIiwiYXR0ciJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Points.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_REVISION_three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=REVISION!=!three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst getVersion = ()=>parseInt(_barrel_optimize_names_REVISION_three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, ''));\nconst version = /* @__PURE__ */ getVersion();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFFakMsTUFBTUMsYUFBYSxJQUFNQyxTQUFTRiwyRUFBUUEsQ0FBQ0csT0FBTyxDQUFDLFFBQVE7QUFDM0QsTUFBTUMsVUFBVSxhQUFhLEdBQUVIO0FBRVoiLCJzb3VyY2VzIjpbIkQ6XFxXZWJfQXBwc1xcUmVhY3QtUHJvamVjdHNcXHF1b3RlLWRlY29kZXJcXG5vZGVfbW9kdWxlc1xcQHJlYWN0LXRocmVlXFxkcmVpXFxoZWxwZXJzXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUkVWSVNJT04gfSBmcm9tICd0aHJlZSc7XG5cbmNvbnN0IGdldFZlcnNpb24gPSAoKSA9PiBwYXJzZUludChSRVZJU0lPTi5yZXBsYWNlKC9cXEQrL2csICcnKSk7XG5jb25zdCB2ZXJzaW9uID0gLyogQF9fUFVSRV9fICovZ2V0VmVyc2lvbigpO1xuXG5leHBvcnQgeyB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOlsiUkVWSVNJT04iLCJnZXRWZXJzaW9uIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwidmVyc2lvbiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useStore),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useThree),\n/* harmony export */   D: () => (/* binding */ useFrame),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useGraph),\n/* harmony export */   G: () => (/* binding */ useLoader),\n/* harmony export */   _: () => (/* binding */ _roots),\n/* harmony export */   a: () => (/* binding */ useMutableCallback),\n/* harmony export */   b: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   c: () => (/* binding */ createRoot),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ createPointerEvents),\n/* harmony export */   g: () => (/* binding */ createEvents),\n/* harmony export */   h: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ addEffect),\n/* harmony export */   k: () => (/* binding */ addAfterEffect),\n/* harmony export */   l: () => (/* binding */ addTail),\n/* harmony export */   m: () => (/* binding */ invalidate),\n/* harmony export */   n: () => (/* binding */ advance),\n/* harmony export */   o: () => (/* binding */ createPortal),\n/* harmony export */   p: () => (/* binding */ flushSync),\n/* harmony export */   q: () => (/* binding */ context),\n/* harmony export */   r: () => (/* binding */ reconciler),\n/* harmony export */   s: () => (/* binding */ applyProps),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useBridge),\n/* harmony export */   v: () => (/* binding */ getRootState),\n/* harmony export */   w: () => (/* binding */ dispose),\n/* harmony export */   x: () => (/* binding */ act),\n/* harmony export */   y: () => (/* binding */ buildGraph),\n/* harmony export */   z: () => (/* binding */ useInstanceHandle)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n\n\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\n/**\r\n * Returns the instance's initial (outmost) root.\r\n */ function findInitialRoot(instance) {\n    let root = instance.root;\n    while(root.getState().previousRoot)root = root.getState().previousRoot;\n    return root;\n}\n/**\r\n * Safely flush async effects when testing, simulating a legacy root.\r\n * @deprecated Import from React instead. import { act } from 'react'\r\n */ // Reference with computed key to break Webpack static analysis\n// https://github.com/webpack/webpack/issues/14814\nconst act = react__WEBPACK_IMPORTED_MODULE_0__['act' + ''];\nconst isOrthographicCamera = (def)=>def && def.isOrthographicCamera;\nconst isRef = (obj)=>obj && obj.hasOwnProperty('current');\nconst isColorRepresentation = (value)=>value != null && (typeof value === 'string' || typeof value === 'number' || value.isColor);\n/**\r\n * An SSR-friendly useLayoutEffect.\r\n *\r\n * React currently throws a warning when using useLayoutEffect on the server.\r\n * To get around it, we can conditionally useEffect on the server (no-op) and\r\n * useLayoutEffect elsewhere.\r\n *\r\n * @see https://github.com/facebook/react/issues/14927\r\n */ const useIsomorphicLayoutEffect = /* @__PURE__ */ ((_window$document, _window$navigator)=> false && (0))() ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n    useIsomorphicLayoutEffect({\n        \"useMutableCallback.useIsomorphicLayoutEffect\": ()=>void (ref.current = fn)\n    }[\"useMutableCallback.useIsomorphicLayoutEffect\"], [\n        fn\n    ]);\n    return ref;\n}\n/**\r\n * Bridges renderer Context and StrictMode from a primary renderer.\r\n */ function useBridge() {\n    const fiber = (0,its_fine__WEBPACK_IMPORTED_MODULE_5__.useFiber)();\n    const ContextBridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_5__.useContextBridge)();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"useBridge.useMemo\": ()=>({\n                \"useBridge.useMemo\": ({ children })=>{\n                    const strict = !!(0,its_fine__WEBPACK_IMPORTED_MODULE_5__.traverseFiber)(fiber, true, {\n                        \"useBridge.useMemo\": (node)=>node.type === react__WEBPACK_IMPORTED_MODULE_0__.StrictMode\n                    }[\"useBridge.useMemo\"]);\n                    const Root = strict ? react__WEBPACK_IMPORTED_MODULE_0__.StrictMode : react__WEBPACK_IMPORTED_MODULE_0__.Fragment;\n                    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Root, {\n                        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ContextBridge, {\n                            children: children\n                        })\n                    });\n                }\n            })[\"useBridge.useMemo\"]\n    }[\"useBridge.useMemo\"], [\n        fiber,\n        ContextBridge\n    ]);\n}\nfunction Block({ set }) {\n    useIsomorphicLayoutEffect({\n        \"Block.useIsomorphicLayoutEffect\": ()=>{\n            set(new Promise({\n                \"Block.useIsomorphicLayoutEffect\": ()=>null\n            }[\"Block.useIsomorphicLayoutEffect\"]));\n            return ({\n                \"Block.useIsomorphicLayoutEffect\": ()=>set(false)\n            })[\"Block.useIsomorphicLayoutEffect\"];\n        }\n    }[\"Block.useIsomorphicLayoutEffect\"], [\n        set\n    ]);\n    return null;\n}\n// NOTE: static members get down-level transpiled to mutations which break tree-shaking\nconst ErrorBoundary = /* @__PURE__ */ ((_ErrorBoundary)=>(_ErrorBoundary = class ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n        constructor(...args){\n            super(...args);\n            this.state = {\n                error: false\n            };\n        }\n        componentDidCatch(err) {\n            this.props.set(err);\n        }\n        render() {\n            return this.state.error ? null : this.props.children;\n        }\n    }, _ErrorBoundary.getDerivedStateFromError = ()=>({\n            error: true\n        }), _ErrorBoundary))();\nfunction calculateDpr(dpr) {\n    var _window$devicePixelRa;\n    // Err on the side of progress by assuming 2x dpr if we can't detect it\n    // This will happen in workers where window is defined but dpr isn't.\n    const target =  false ? 0 : 1;\n    return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n/**\r\n * Returns instance root state\r\n */ function getRootState(obj) {\n    var _r3f;\n    return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n}\n// A collection of compare functions\nconst is = {\n    obj: (a)=>a === Object(a) && !is.arr(a) && typeof a !== 'function',\n    fun: (a)=>typeof a === 'function',\n    str: (a)=>typeof a === 'string',\n    num: (a)=>typeof a === 'number',\n    boo: (a)=>typeof a === 'boolean',\n    und: (a)=>a === void 0,\n    nul: (a)=>a === null,\n    arr: (a)=>Array.isArray(a),\n    equ (a, b, { arrays = 'shallow', objects = 'reference', strict = true } = {}) {\n        // Wrong type or one of the two undefined, doesn't match\n        if (typeof a !== typeof b || !!a !== !!b) return false;\n        // Atomic, just compare a against b\n        if (is.str(a) || is.num(a) || is.boo(a)) return a === b;\n        const isObj = is.obj(a);\n        if (isObj && objects === 'reference') return a === b;\n        const isArr = is.arr(a);\n        if (isArr && arrays === 'reference') return a === b;\n        // Array or Object, shallow compare first to see if it's a match\n        if ((isArr || isObj) && a === b) return true;\n        // Last resort, go through keys\n        let i;\n        // Check if a has all the keys of b\n        for(i in a)if (!(i in b)) return false;\n        // Check if values between keys match\n        if (isObj && arrays === 'shallow' && objects === 'shallow') {\n            for(i in strict ? b : a)if (!is.equ(a[i], b[i], {\n                strict,\n                objects: 'reference'\n            })) return false;\n        } else {\n            for(i in strict ? b : a)if (a[i] !== b[i]) return false;\n        }\n        // If i is undefined\n        if (is.und(i)) {\n            // If both arrays are empty we consider them equal\n            if (isArr && a.length === 0 && b.length === 0) return true;\n            // If both objects are empty we consider them equal\n            if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n            // Otherwise match them by value\n            if (a !== b) return false;\n        }\n        return true;\n    }\n};\n// Collects nodes and materials from a THREE.Object3D\nfunction buildGraph(object) {\n    const data = {\n        nodes: {},\n        materials: {},\n        meshes: {}\n    };\n    if (object) {\n        object.traverse((obj)=>{\n            if (obj.name) data.nodes[obj.name] = obj;\n            if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n            if (obj.isMesh && !data.meshes[obj.name]) data.meshes[obj.name] = obj;\n        });\n    }\n    return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n    if (obj.type !== 'Scene') obj.dispose == null ? void 0 : obj.dispose();\n    for(const p in obj){\n        const prop = obj[p];\n        if ((prop == null ? void 0 : prop.type) !== 'Scene') prop == null ? void 0 : prop.dispose == null ? void 0 : prop.dispose();\n    }\n}\nconst REACT_INTERNAL_PROPS = [\n    'children',\n    'key',\n    'ref'\n];\n// Gets only instance props from reconciler fibers\nfunction getInstanceProps(queue) {\n    const props = {};\n    for(const key in queue){\n        if (!REACT_INTERNAL_PROPS.includes(key)) props[key] = queue[key];\n    }\n    return props;\n}\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(target, root, type, props) {\n    const object = target;\n    // Create instance descriptor\n    let instance = object == null ? void 0 : object.__r3f;\n    if (!instance) {\n        instance = {\n            root,\n            type,\n            parent: null,\n            children: [],\n            props: getInstanceProps(props),\n            object,\n            eventCount: 0,\n            handlers: {},\n            isHidden: false\n        };\n        if (object) object.__r3f = instance;\n    }\n    return instance;\n}\nfunction resolve(root, key) {\n    let target = root[key];\n    if (!key.includes('-')) return {\n        root,\n        key,\n        target\n    };\n    // Resolve pierced target\n    target = root;\n    for (const part of key.split('-')){\n        var _target;\n        key = part;\n        root = target;\n        target = (_target = target) == null ? void 0 : _target[key];\n    }\n    // TODO: change key to 'foo-bar' if target is undefined?\n    return {\n        root,\n        key,\n        target\n    };\n}\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child) {\n    if (is.str(child.props.attach)) {\n        // If attaching into an array (foo-0), create one\n        if (INDEX_REGEX.test(child.props.attach)) {\n            const index = child.props.attach.replace(INDEX_REGEX, '');\n            const { root, key } = resolve(parent.object, index);\n            if (!Array.isArray(root[key])) root[key] = [];\n        }\n        const { root, key } = resolve(parent.object, child.props.attach);\n        child.previousAttach = root[key];\n        root[key] = child.object;\n    } else if (is.fun(child.props.attach)) {\n        child.previousAttach = child.props.attach(parent.object, child.object);\n    }\n}\nfunction detach(parent, child) {\n    if (is.str(child.props.attach)) {\n        const { root, key } = resolve(parent.object, child.props.attach);\n        const previous = child.previousAttach;\n        // When the previous value was undefined, it means the value was never set to begin with\n        if (previous === undefined) delete root[key];\n        else root[key] = previous;\n    } else {\n        child.previousAttach == null ? void 0 : child.previousAttach(parent.object, child.object);\n    }\n    delete child.previousAttach;\n}\nconst RESERVED_PROPS = [\n    ...REACT_INTERNAL_PROPS,\n    // Instance props\n    'args',\n    'dispose',\n    'attach',\n    'object',\n    'onUpdate',\n    // Behavior flags\n    'dispose'\n];\nconst MEMOIZED_PROTOTYPES = new Map();\nfunction getMemoizedPrototype(root) {\n    let ctor = MEMOIZED_PROTOTYPES.get(root.constructor);\n    try {\n        if (!ctor) {\n            ctor = new root.constructor();\n            MEMOIZED_PROTOTYPES.set(root.constructor, ctor);\n        }\n    } catch (e) {\n    // ...\n    }\n    return ctor;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, newProps) {\n    const changedProps = {};\n    // Sort through props\n    for(const prop in newProps){\n        // Skip reserved keys\n        if (RESERVED_PROPS.includes(prop)) continue;\n        // Skip if props match\n        if (is.equ(newProps[prop], instance.props[prop])) continue;\n        // Props changed, add them\n        changedProps[prop] = newProps[prop];\n        // Reset pierced props\n        for(const other in newProps){\n            if (other.startsWith(`${prop}-`)) changedProps[other] = newProps[other];\n        }\n    }\n    // Reset removed props for HMR\n    for(const prop in instance.props){\n        if (RESERVED_PROPS.includes(prop) || newProps.hasOwnProperty(prop)) continue;\n        const { root, key } = resolve(instance.object, prop);\n        // https://github.com/mrdoob/three.js/issues/21209\n        // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n        // has no means to do this. Hence we curate a small collection of value-classes\n        // with their respective constructor/set arguments\n        // For removed props, try to set default values, if possible\n        if (root.constructor && root.constructor.length === 0) {\n            // create a blank slate of the instance and copy the particular parameter.\n            const ctor = getMemoizedPrototype(root);\n            if (!is.und(ctor)) changedProps[key] = ctor[key];\n        } else {\n            // instance does not have constructor, just set it to 0\n            changedProps[key] = 0;\n        }\n    }\n    return changedProps;\n}\n// https://github.com/mrdoob/three.js/pull/27042\n// https://github.com/mrdoob/three.js/pull/22748\nconst colorMaps = [\n    'map',\n    'emissiveMap',\n    'sheenColorMap',\n    'specularColorMap',\n    'envMap'\n];\nconst EVENT_REGEX = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;\n// This function applies a set of changes to the instance\nfunction applyProps(object, props) {\n    var _instance$object;\n    const instance = object.__r3f;\n    const rootState = instance && findInitialRoot(instance).getState();\n    const prevHandlers = instance == null ? void 0 : instance.eventCount;\n    for(const prop in props){\n        let value = props[prop];\n        // Don't mutate reserved keys\n        if (RESERVED_PROPS.includes(prop)) continue;\n        // Deal with pointer events, including removing them if undefined\n        if (instance && EVENT_REGEX.test(prop)) {\n            if (typeof value === 'function') instance.handlers[prop] = value;\n            else delete instance.handlers[prop];\n            instance.eventCount = Object.keys(instance.handlers).length;\n            continue;\n        }\n        // Ignore setting undefined props\n        // https://github.com/pmndrs/react-three-fiber/issues/274\n        if (value === undefined) continue;\n        let { root, key, target } = resolve(object, prop);\n        // Layers must be written to the mask property\n        if (target instanceof three__WEBPACK_IMPORTED_MODULE_6__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_6__.Layers) {\n            target.mask = value.mask;\n        } else if (target instanceof three__WEBPACK_IMPORTED_MODULE_6__.Color && isColorRepresentation(value)) {\n            target.set(value);\n        } else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && typeof target.copy === 'function' && value != null && value.constructor && target.constructor === value.constructor) {\n            target.copy(value);\n        } else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && Array.isArray(value)) {\n            if (typeof target.fromArray === 'function') target.fromArray(value);\n            else target.set(...value);\n        } else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && typeof value === 'number') {\n            // Allow setting array scalars\n            if (typeof target.setScalar === 'function') target.setScalar(value);\n            else target.set(value);\n        } else {\n            var _root$key;\n            root[key] = value;\n            // Auto-convert sRGB texture parameters for built-in materials\n            // https://github.com/pmndrs/react-three-fiber/issues/344\n            // https://github.com/mrdoob/three.js/pull/25857\n            if (rootState && !rootState.linear && colorMaps.includes(key) && (_root$key = root[key]) != null && _root$key.isTexture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n            root[key].format === three__WEBPACK_IMPORTED_MODULE_6__.RGBAFormat && root[key].type === three__WEBPACK_IMPORTED_MODULE_6__.UnsignedByteType) {\n                // NOTE: this cannot be set from the renderer (e.g. sRGB source textures rendered to P3)\n                root[key].colorSpace = three__WEBPACK_IMPORTED_MODULE_6__.SRGBColorSpace;\n            }\n        }\n    }\n    // Register event handlers\n    if (instance != null && instance.parent && rootState != null && rootState.internal && (_instance$object = instance.object) != null && _instance$object.isObject3D && prevHandlers !== instance.eventCount) {\n        const object = instance.object;\n        // Pre-emptively remove the instance from the interaction manager\n        const index = rootState.internal.interaction.indexOf(object);\n        if (index > -1) rootState.internal.interaction.splice(index, 1);\n        // Add the instance to the interaction manager only when it has handlers\n        if (instance.eventCount && object.raycast !== null) {\n            rootState.internal.interaction.push(object);\n        }\n    }\n    // Auto-attach geometries and materials\n    if (instance && instance.props.attach === undefined) {\n        if (instance.object.isBufferGeometry) instance.props.attach = 'geometry';\n        else if (instance.object.isMaterial) instance.props.attach = 'material';\n    }\n    // Instance was updated, request a frame\n    if (instance) invalidateInstance(instance);\n    return object;\n}\nfunction invalidateInstance(instance) {\n    var _instance$root;\n    if (!instance.parent) return;\n    instance.props.onUpdate == null ? void 0 : instance.props.onUpdate(instance.object);\n    const state = (_instance$root = instance.root) == null ? void 0 : _instance$root.getState == null ? void 0 : _instance$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateCamera(camera, size) {\n    // Do not mess with the camera if it belongs to the user\n    // https://github.com/pmndrs/react-three-fiber/issues/92\n    if (camera.manual) return;\n    if (isOrthographicCamera(camera)) {\n        camera.left = size.width / -2;\n        camera.right = size.width / 2;\n        camera.top = size.height / 2;\n        camera.bottom = size.height / -2;\n    } else {\n        camera.aspect = size.width / size.height;\n    }\n    camera.updateProjectionMatrix();\n}\nconst isObject3D = (object)=>object == null ? void 0 : object.isObject3D;\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + '/' + event.index + event.instanceId;\n}\n/**\r\n * Release pointer captures.\r\n * This is called by releasePointerCapture in the API, and when an object is removed.\r\n */ function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n    const captureData = captures.get(obj);\n    if (captureData) {\n        captures.delete(obj);\n        // If this was the last capturing object for this pointer\n        if (captures.size === 0) {\n            capturedMap.delete(pointerId);\n            captureData.target.releasePointerCapture(pointerId);\n        }\n    }\n}\nfunction removeInteractivity(store, object) {\n    const { internal } = store.getState();\n    // Removes every trace of an object from the data store\n    internal.interaction = internal.interaction.filter((o)=>o !== object);\n    internal.initialHits = internal.initialHits.filter((o)=>o !== object);\n    internal.hovered.forEach((value, key)=>{\n        if (value.eventObject === object || value.object === object) {\n            // Clear out intersects, they are outdated by now\n            internal.hovered.delete(key);\n        }\n    });\n    internal.capturedMap.forEach((captures, pointerId)=>{\n        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n    });\n}\nfunction createEvents(store) {\n    /** Calculates delta */ function calculateDistance(event) {\n        const { internal } = store.getState();\n        const dx = event.offsetX - internal.initialClick[0];\n        const dy = event.offsetY - internal.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }\n    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */ function filterPointerEvents(objects) {\n        return objects.filter((obj)=>[\n                'Move',\n                'Over',\n                'Enter',\n                'Out',\n                'Leave'\n            ].some((name)=>{\n                var _r3f;\n                return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers['onPointer' + name];\n            }));\n    }\n    function intersect(event, filter) {\n        const state = store.getState();\n        const duplicates = new Set();\n        const intersections = [];\n        // Allow callers to eliminate event objects\n        const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n        // Reset all raycaster cameras to undefined\n        for(let i = 0; i < eventsObjects.length; i++){\n            const state = getRootState(eventsObjects[i]);\n            if (state) {\n                state.raycaster.camera = undefined;\n            }\n        }\n        if (!state.previousRoot) {\n            // Make sure root-level pointer and ray are set up\n            state.events.compute == null ? void 0 : state.events.compute(event, state);\n        }\n        function handleRaycast(obj) {\n            const state = getRootState(obj);\n            // Skip event handling when noEvents is set, or when the raycasters camera is null\n            if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n            // When the camera is undefined we have to call the event layers update function\n            if (state.raycaster.camera === undefined) {\n                var _state$previousRoot;\n                state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n                // If the camera is still undefined we have to skip this layer entirely\n                if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n            }\n            // Intersect object by object\n            return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n        }\n        // Collect events\n        let hits = eventsObjects// Intersect objects\n        .flatMap(handleRaycast)// Sort by event priority and distance\n        .sort((a, b)=>{\n            const aState = getRootState(a.object);\n            const bState = getRootState(b.object);\n            if (!aState || !bState) return a.distance - b.distance;\n            return bState.events.priority - aState.events.priority || a.distance - b.distance;\n        })// Filter out duplicates\n        .filter((item)=>{\n            const id = makeId(item);\n            if (duplicates.has(id)) return false;\n            duplicates.add(id);\n            return true;\n        });\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n        if (state.events.filter) hits = state.events.filter(hits, state);\n        // Bubble up the events, find the event source (eventObject)\n        for (const hit of hits){\n            let eventObject = hit.object;\n            // Bubble event up\n            while(eventObject){\n                var _r3f2;\n                if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n                    ...hit,\n                    eventObject\n                });\n                eventObject = eventObject.parent;\n            }\n        }\n        // If the interaction is captured, make all capturing targets part of the intersect.\n        if ('pointerId' in event && state.internal.capturedMap.has(event.pointerId)) {\n            for (let captureData of state.internal.capturedMap.get(event.pointerId).values()){\n                if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n            }\n        }\n        return intersections;\n    }\n    /**  Handles intersections by forwarding them to handlers */ function handleIntersects(intersections, event, delta, callback) {\n        // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            const localState = {\n                stopped: false\n            };\n            for (const hit of intersections){\n                let state = getRootState(hit.object);\n                // If the object is not managed by R3F, it might be parented to an element which is.\n                // Traverse upwards until we find a managed parent and use its state instead.\n                if (!state) {\n                    hit.object.traverseAncestors((obj)=>{\n                        const parentState = getRootState(obj);\n                        if (parentState) {\n                            state = parentState;\n                            return false;\n                        }\n                    });\n                }\n                if (state) {\n                    const { raycaster, pointer, camera, internal } = state;\n                    const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n                    const hasPointerCapture = (id)=>{\n                        var _internal$capturedMap, _internal$capturedMap2;\n                        return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n                    };\n                    const setPointerCapture = (id)=>{\n                        const captureData = {\n                            intersection: hit,\n                            target: event.target\n                        };\n                        if (internal.capturedMap.has(id)) {\n                            // if the pointerId was previously captured, we add the hit to the\n                            // event capturedMap.\n                            internal.capturedMap.get(id).set(hit.eventObject, captureData);\n                        } else {\n                            // if the pointerId was not previously captured, we create a map\n                            // containing the hitObject, and the hit. hitObject is used for\n                            // faster access.\n                            internal.capturedMap.set(id, new Map([\n                                [\n                                    hit.eventObject,\n                                    captureData\n                                ]\n                            ]));\n                        }\n                        event.target.setPointerCapture(id);\n                    };\n                    const releasePointerCapture = (id)=>{\n                        const captures = internal.capturedMap.get(id);\n                        if (captures) {\n                            releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n                        }\n                    };\n                    // Add native event props\n                    let extractEventProps = {};\n                    // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n                    for(let prop in event){\n                        let property = event[prop];\n                        // Only copy over atomics, leave functions alone as these should be\n                        // called as event.nativeEvent.fn()\n                        if (typeof property !== 'function') extractEventProps[prop] = property;\n                    }\n                    let raycastEvent = {\n                        ...hit,\n                        ...extractEventProps,\n                        pointer,\n                        intersections,\n                        stopped: localState.stopped,\n                        delta,\n                        unprojectedPoint,\n                        ray: raycaster.ray,\n                        camera: camera,\n                        // Hijack stopPropagation, which just sets a flag\n                        stopPropagation () {\n                            // https://github.com/pmndrs/react-three-fiber/issues/596\n                            // Events are not allowed to stop propagation if the pointer has been captured\n                            const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId);\n                            // We only authorize stopPropagation...\n                            if (// ...if this pointer hasn't been captured\n                            !capturesForPointer || // ... or if the hit object is capturing the pointer\n                            capturesForPointer.has(hit.eventObject)) {\n                                raycastEvent.stopped = localState.stopped = true;\n                                // Propagation is stopped, remove all other hover records\n                                // An event handler is only allowed to flush other handlers if it is hovered itself\n                                if (internal.hovered.size && Array.from(internal.hovered.values()).find((i)=>i.eventObject === hit.eventObject)) {\n                                    // Objects cannot flush out higher up objects that have already caught the event\n                                    const higher = intersections.slice(0, intersections.indexOf(hit));\n                                    cancelPointer([\n                                        ...higher,\n                                        hit\n                                    ]);\n                                }\n                            }\n                        },\n                        // there should be a distinction between target and currentTarget\n                        target: {\n                            hasPointerCapture,\n                            setPointerCapture,\n                            releasePointerCapture\n                        },\n                        currentTarget: {\n                            hasPointerCapture,\n                            setPointerCapture,\n                            releasePointerCapture\n                        },\n                        nativeEvent: event\n                    };\n                    // Call subscribers\n                    callback(raycastEvent);\n                    // Event bubbling may be interrupted by stopPropagation\n                    if (localState.stopped === true) break;\n                }\n            }\n        }\n        return intersections;\n    }\n    function cancelPointer(intersections) {\n        const { internal } = store.getState();\n        for (const hoveredObj of internal.hovered.values()){\n            // When no objects were hit or the the hovered object wasn't found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (!intersections.length || !intersections.find((hit)=>hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n                const eventObject = hoveredObj.eventObject;\n                const instance = eventObject.__r3f;\n                internal.hovered.delete(makeId(hoveredObj));\n                if (instance != null && instance.eventCount) {\n                    const handlers = instance.handlers;\n                    // Clear out intersects, they are outdated by now\n                    const data = {\n                        ...hoveredObj,\n                        intersections\n                    };\n                    handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n                    handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n                }\n            }\n        }\n    }\n    function pointerMissed(event, objects) {\n        for(let i = 0; i < objects.length; i++){\n            const instance = objects[i].__r3f;\n            instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n        }\n    }\n    function handlePointer(name) {\n        // Deal with cancelation\n        switch(name){\n            case 'onPointerLeave':\n            case 'onPointerCancel':\n                return ()=>cancelPointer([]);\n            case 'onLostPointerCapture':\n                return (event)=>{\n                    const { internal } = store.getState();\n                    if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n                        // If the object event interface had onLostPointerCapture, we'd call it here on every\n                        // object that's getting removed. We call it on the next frame because onLostPointerCapture\n                        // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n                        // happen in the object it originated from, leaving components in a in-between state.\n                        requestAnimationFrame(()=>{\n                            // Only release if pointer-up didn't do it already\n                            if (internal.capturedMap.has(event.pointerId)) {\n                                internal.capturedMap.delete(event.pointerId);\n                                cancelPointer([]);\n                            }\n                        });\n                    }\n                };\n        }\n        // Any other pointer goes here ...\n        return function handleEvent(event) {\n            const { onPointerMissed, internal } = store.getState();\n            // prepareRay(event)\n            internal.lastEvent.current = event;\n            // Get fresh intersects\n            const isPointerMove = name === 'onPointerMove';\n            const isClickEvent = name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick';\n            const filter = isPointerMove ? filterPointerEvents : undefined;\n            const hits = intersect(event, filter);\n            const delta = isClickEvent ? calculateDistance(event) : 0;\n            // Save initial coordinates on pointer-down\n            if (name === 'onPointerDown') {\n                internal.initialClick = [\n                    event.offsetX,\n                    event.offsetY\n                ];\n                internal.initialHits = hits.map((hit)=>hit.eventObject);\n            }\n            // If a click yields no results, pass it back to the user as a miss\n            // Missed events have to come first in order to establish user-land side-effect clean up\n            if (isClickEvent && !hits.length) {\n                if (delta <= 2) {\n                    pointerMissed(event, internal.interaction);\n                    if (onPointerMissed) onPointerMissed(event);\n                }\n            }\n            // Take care of unhover\n            if (isPointerMove) cancelPointer(hits);\n            function onIntersect(data) {\n                const eventObject = data.eventObject;\n                const instance = eventObject.__r3f;\n                // Check presence of handlers\n                if (!(instance != null && instance.eventCount)) return;\n                const handlers = instance.handlers;\n                /*\r\n        MAYBE TODO, DELETE IF NOT: \r\n          Check if the object is captured, captured events should not have intersects running in parallel\r\n          But wouldn't it be better to just replace capturedMap with a single entry?\r\n          Also, are we OK with straight up making picking up multiple objects impossible?\r\n          \r\n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \r\n        if (pointerId !== undefined) {\r\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\r\n          if (capturedMeshSet) {\r\n            const captured = capturedMeshSet.get(eventObject)\r\n            if (captured && captured.localState.stopped) return\r\n          }\r\n        }*/ if (isPointerMove) {\n                    // Move event ...\n                    if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n                        // When enter or out is present take care of hover-state\n                        const id = makeId(data);\n                        const hoveredItem = internal.hovered.get(id);\n                        if (!hoveredItem) {\n                            // If the object wasn't previously hovered, book it and call its handler\n                            internal.hovered.set(id, data);\n                            handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n                            handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n                        } else if (hoveredItem.stopped) {\n                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n                            data.stopPropagation();\n                        }\n                    }\n                    // Call mouse move\n                    handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n                } else {\n                    // All other events ...\n                    const handler = handlers[name];\n                    if (handler) {\n                        // Forward all events back to their respective handlers with the exception of click events,\n                        // which must use the initial target\n                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n                            // Missed events have to come first\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                            // Now call the handler\n                            handler(data);\n                        }\n                    } else {\n                        // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n                        if (isClickEvent && internal.initialHits.includes(eventObject)) {\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                        }\n                    }\n                }\n            }\n            handleIntersects(hits, event, delta, onIntersect);\n        };\n    }\n    return {\n        handlePointer\n    };\n}\nconst isRenderer = (def)=>!!(def != null && def.render);\nconst context = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance)=>{\n    const rootStore = (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_7__.createWithEqualityFn)((set, get)=>{\n        const position = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n        const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n        const tempTarget = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n        function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n            const { width, height, top, left } = size;\n            const aspect = width / height;\n            if (target.isVector3) tempTarget.copy(target);\n            else tempTarget.set(...target);\n            const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n            if (isOrthographicCamera(camera)) {\n                return {\n                    width: width / camera.zoom,\n                    height: height / camera.zoom,\n                    top,\n                    left,\n                    factor: 1,\n                    distance,\n                    aspect\n                };\n            } else {\n                const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n                const h = 2 * Math.tan(fov / 2) * distance; // visible height\n                const w = h * (width / height);\n                return {\n                    width: w,\n                    height: h,\n                    top,\n                    left,\n                    factor: width / w,\n                    distance,\n                    aspect\n                };\n            }\n        }\n        let performanceTimeout = undefined;\n        const setPerformanceCurrent = (current)=>set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        current\n                    }\n                }));\n        const pointer = new three__WEBPACK_IMPORTED_MODULE_6__.Vector2();\n        const rootState = {\n            set,\n            get,\n            // Mock objects that have to be configured\n            gl: null,\n            camera: null,\n            raycaster: null,\n            events: {\n                priority: 1,\n                enabled: true,\n                connected: false\n            },\n            scene: null,\n            xr: null,\n            invalidate: (frames = 1)=>invalidate(get(), frames),\n            advance: (timestamp, runGlobalEffects)=>advance(timestamp, runGlobalEffects, get()),\n            legacy: false,\n            linear: false,\n            flat: false,\n            controls: null,\n            clock: new three__WEBPACK_IMPORTED_MODULE_6__.Clock(),\n            pointer,\n            mouse: pointer,\n            frameloop: 'always',\n            onPointerMissed: undefined,\n            performance: {\n                current: 1,\n                min: 0.5,\n                max: 1,\n                debounce: 200,\n                regress: ()=>{\n                    const state = get();\n                    // Clear timeout\n                    if (performanceTimeout) clearTimeout(performanceTimeout);\n                    // Set lower bound performance\n                    if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n                    // Go back to upper bound performance after a while unless something regresses meanwhile\n                    performanceTimeout = setTimeout(()=>setPerformanceCurrent(get().performance.max), state.performance.debounce);\n                }\n            },\n            size: {\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0\n            },\n            viewport: {\n                initialDpr: 0,\n                dpr: 0,\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                aspect: 0,\n                distance: 0,\n                factor: 0,\n                getCurrentViewport\n            },\n            setEvents: (events)=>set((state)=>({\n                        ...state,\n                        events: {\n                            ...state.events,\n                            ...events\n                        }\n                    })),\n            setSize: (width, height, top = 0, left = 0)=>{\n                const camera = get().camera;\n                const size = {\n                    width,\n                    height,\n                    top,\n                    left\n                };\n                set((state)=>({\n                        size,\n                        viewport: {\n                            ...state.viewport,\n                            ...getCurrentViewport(camera, defaultTarget, size)\n                        }\n                    }));\n            },\n            setDpr: (dpr)=>set((state)=>{\n                    const resolved = calculateDpr(dpr);\n                    return {\n                        viewport: {\n                            ...state.viewport,\n                            dpr: resolved,\n                            initialDpr: state.viewport.initialDpr || resolved\n                        }\n                    };\n                }),\n            setFrameloop: (frameloop = 'always')=>{\n                const clock = get().clock;\n                // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n                clock.stop();\n                clock.elapsedTime = 0;\n                if (frameloop !== 'never') {\n                    clock.start();\n                    clock.elapsedTime = 0;\n                }\n                set(()=>({\n                        frameloop\n                    }));\n            },\n            previousRoot: undefined,\n            internal: {\n                // Events\n                interaction: [],\n                hovered: new Map(),\n                subscribers: [],\n                initialClick: [\n                    0,\n                    0\n                ],\n                initialHits: [],\n                capturedMap: new Map(),\n                lastEvent: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n                // Updates\n                active: false,\n                frames: 0,\n                priority: 0,\n                subscribe: (ref, priority, store)=>{\n                    const internal = get().internal;\n                    // If this subscription was given a priority, it takes rendering into its own hands\n                    // For that reason we switch off automatic rendering and increase the manual flag\n                    // As long as this flag is positive there can be no internal rendering at all\n                    // because there could be multiple render subscriptions\n                    internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n                    internal.subscribers.push({\n                        ref,\n                        priority,\n                        store\n                    });\n                    // Register subscriber and sort layers from lowest to highest, meaning,\n                    // highest priority renders last (on top of the other frames)\n                    internal.subscribers = internal.subscribers.sort((a, b)=>a.priority - b.priority);\n                    return ()=>{\n                        const internal = get().internal;\n                        if (internal != null && internal.subscribers) {\n                            // Decrease manual flag if this subscription had a priority\n                            internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n                            // Remove subscriber from list\n                            internal.subscribers = internal.subscribers.filter((s)=>s.ref !== ref);\n                        }\n                    };\n                }\n            }\n        };\n        return rootState;\n    });\n    const state = rootStore.getState();\n    let oldSize = state.size;\n    let oldDpr = state.viewport.dpr;\n    let oldCamera = state.camera;\n    rootStore.subscribe(()=>{\n        const { camera, size, viewport, gl, set } = rootStore.getState();\n        // Resize camera and renderer on changes to size and pixelratio\n        if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n            oldSize = size;\n            oldDpr = viewport.dpr;\n            // Update camera & renderer\n            updateCamera(camera, size);\n            if (viewport.dpr > 0) gl.setPixelRatio(viewport.dpr);\n            const updateStyle = typeof HTMLCanvasElement !== 'undefined' && gl.domElement instanceof HTMLCanvasElement;\n            gl.setSize(size.width, size.height, updateStyle);\n        }\n        // Update viewport once the camera changes\n        if (camera !== oldCamera) {\n            oldCamera = camera;\n            // Update viewport\n            set((state)=>({\n                    viewport: {\n                        ...state.viewport,\n                        ...state.viewport.getCurrentViewport(camera)\n                    }\n                }));\n        }\n    });\n    // Invalidate on any change\n    rootStore.subscribe((state)=>invalidate(state));\n    // Return root state\n    return rootStore;\n};\n/**\r\n * Exposes an object's {@link Instance}.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\r\n *\r\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\r\n */ function useInstanceHandle(ref) {\n    const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(instance, {\n        \"useInstanceHandle.useImperativeHandle\": ()=>ref.current.__r3f\n    }[\"useInstanceHandle.useImperativeHandle\"], [\n        ref\n    ]);\n    return instance;\n}\n/**\r\n * Returns the R3F Canvas' Zustand store. Useful for [transient updates](https://github.com/pmndrs/zustand#transient-updates-for-often-occurring-state-changes).\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usestore\r\n */ function useStore() {\n    const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (!store) throw new Error('R3F: Hooks can only be used within the Canvas component!');\n    return store;\n}\n/**\r\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\r\n */ function useThree(selector = (state)=>state, equalityFn) {\n    return useStore()(selector, equalityFn);\n}\n/**\r\n * Executes a callback before render in a shared frame loop.\r\n * Can order effects with render priority or manually render with a positive priority.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\r\n */ function useFrame(callback, renderPriority = 0) {\n    const store = useStore();\n    const subscribe = store.getState().internal.subscribe;\n    // Memoize ref\n    const ref = useMutableCallback(callback);\n    // Subscribe on mount, unsubscribe on unmount\n    useIsomorphicLayoutEffect({\n        \"useFrame.useIsomorphicLayoutEffect\": ()=>subscribe(ref, renderPriority, store)\n    }[\"useFrame.useIsomorphicLayoutEffect\"], [\n        renderPriority,\n        subscribe,\n        store\n    ]);\n    return null;\n}\n/**\r\n * Returns a node graph of an object with named nodes & materials.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\r\n */ function useGraph(object) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"useGraph.useMemo\": ()=>buildGraph(object)\n    }[\"useGraph.useMemo\"], [\n        object\n    ]);\n}\nconst memoizedLoaders = new WeakMap();\nconst isConstructor$1 = (value)=>{\n    var _value$prototype;\n    return typeof value === 'function' && (value == null ? void 0 : (_value$prototype = value.prototype) == null ? void 0 : _value$prototype.constructor) === value;\n};\nfunction loadingFn(extensions, onProgress) {\n    return function(Proto, ...input) {\n        let loader;\n        // Construct and cache loader if constructor was passed\n        if (isConstructor$1(Proto)) {\n            loader = memoizedLoaders.get(Proto);\n            if (!loader) {\n                loader = new Proto();\n                memoizedLoaders.set(Proto, loader);\n            }\n        } else {\n            loader = Proto;\n        }\n        // Apply loader extensions\n        if (extensions) extensions(loader);\n        // Go through the urls and load them\n        return Promise.all(input.map((input)=>new Promise((res, reject)=>loader.load(input, (data)=>{\n                    if (isObject3D(data == null ? void 0 : data.scene)) Object.assign(data, buildGraph(data.scene));\n                    res(data);\n                }, onProgress, (error)=>reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`))))));\n    };\n}\n/**\r\n * Synchronously loads and caches assets with a three loader.\r\n *\r\n * Note: this hook's caller must be wrapped with `React.Suspense`\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\r\n */ function useLoader(loader, input, extensions, onProgress) {\n    // Use suspense to load async assets\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.suspend)(loadingFn(extensions, onProgress), [\n        loader,\n        ...keys\n    ], {\n        equal: is.equ\n    });\n    // Return the object(s)\n    return Array.isArray(input) ? results : results[0];\n}\n/**\r\n * Preloads an asset into cache as a side-effect.\r\n */ useLoader.preload = function(loader, input, extensions) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.preload)(loadingFn(extensions), [\n        loader,\n        ...keys\n    ]);\n};\n/**\r\n * Removes a loaded asset from cache.\r\n */ useLoader.clear = function(loader, input) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.clear)([\n        loader,\n        ...keys\n    ]);\n};\nfunction createReconciler(config) {\n    const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_2___default()(config);\n    reconciler.injectIntoDevTools({\n        bundleType: typeof process !== 'undefined' && \"development\" !== 'production' ? 1 : 0,\n        rendererPackageName: '@react-three/fiber',\n        version: react__WEBPACK_IMPORTED_MODULE_0__.version\n    });\n    return reconciler;\n}\nconst NoEventPriority = 0;\n// TODO: handle constructor overloads\n// https://github.com/pmndrs/react-three-fiber/pull/2931\n// https://github.com/microsoft/TypeScript/issues/37079\nconst catalogue = {};\nconst PREFIX_REGEX = /^three(?=[A-Z])/;\nconst toPascalCase = (type)=>`${type[0].toUpperCase()}${type.slice(1)}`;\nlet i = 0;\nconst isConstructor = (object)=>typeof object === 'function';\nfunction extend(objects) {\n    if (isConstructor(objects)) {\n        const Component = `${i++}`;\n        catalogue[Component] = objects;\n        return Component;\n    } else {\n        Object.assign(catalogue, objects);\n    }\n}\nfunction validateInstance(type, props) {\n    // Get target from catalogue\n    const name = toPascalCase(type);\n    const target = catalogue[name];\n    // Validate element target\n    if (type !== 'primitive' && !target) throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n    // Validate primitives\n    if (type === 'primitive' && !props.object) throw new Error(`R3F: Primitives without 'object' are invalid!`);\n    // Throw if an object or literal was passed for args\n    if (props.args !== undefined && !Array.isArray(props.args)) throw new Error('R3F: The args prop must be an array!');\n}\nfunction createInstance(type, props, root) {\n    var _props$object;\n    // Remove three* prefix from elements if native element not present\n    type = toPascalCase(type) in catalogue ? type : type.replace(PREFIX_REGEX, '');\n    validateInstance(type, props);\n    // Regenerate the R3F instance for primitives to simulate a new object\n    if (type === 'primitive' && (_props$object = props.object) != null && _props$object.__r3f) delete props.object.__r3f;\n    return prepare(props.object, root, type, props);\n}\nfunction hideInstance(instance) {\n    if (!instance.isHidden) {\n        var _instance$parent;\n        if (instance.props.attach && (_instance$parent = instance.parent) != null && _instance$parent.object) {\n            detach(instance.parent, instance);\n        } else if (isObject3D(instance.object)) {\n            instance.object.visible = false;\n        }\n        instance.isHidden = true;\n        invalidateInstance(instance);\n    }\n}\nfunction unhideInstance(instance) {\n    if (instance.isHidden) {\n        var _instance$parent2;\n        if (instance.props.attach && (_instance$parent2 = instance.parent) != null && _instance$parent2.object) {\n            attach(instance.parent, instance);\n        } else if (isObject3D(instance.object) && instance.props.visible !== false) {\n            instance.object.visible = true;\n        }\n        instance.isHidden = false;\n        invalidateInstance(instance);\n    }\n}\n// https://github.com/facebook/react/issues/20271\n// This will make sure events and attach are only handled once when trees are complete\nfunction handleContainerEffects(parent, child, beforeChild) {\n    // Bail if tree isn't mounted or parent is not a container.\n    // This ensures that the tree is finalized and React won't discard results to Suspense\n    const state = child.root.getState();\n    if (!parent.parent && parent.object !== state.scene) return;\n    // Create & link object on first run\n    if (!child.object) {\n        var _child$props$object, _child$props$args;\n        // Get target from catalogue\n        const target = catalogue[toPascalCase(child.type)];\n        // Create object\n        child.object = (_child$props$object = child.props.object) != null ? _child$props$object : new target(...(_child$props$args = child.props.args) != null ? _child$props$args : []);\n        child.object.__r3f = child;\n    }\n    // Set initial props\n    applyProps(child.object, child.props);\n    // Append instance\n    if (child.props.attach) {\n        attach(parent, child);\n    } else if (isObject3D(child.object) && isObject3D(parent.object)) {\n        const childIndex = parent.object.children.indexOf(beforeChild == null ? void 0 : beforeChild.object);\n        if (beforeChild && childIndex !== -1) {\n            // If the child is already in the parent's children array, move it to the new position\n            // Otherwise, just insert it at the target position\n            const existingIndex = parent.object.children.indexOf(child.object);\n            if (existingIndex !== -1) {\n                parent.object.children.splice(existingIndex, 1);\n                const adjustedIndex = existingIndex < childIndex ? childIndex - 1 : childIndex;\n                parent.object.children.splice(adjustedIndex, 0, child.object);\n            } else {\n                child.object.parent = parent.object;\n                parent.object.children.splice(childIndex, 0, child.object);\n                child.object.dispatchEvent({\n                    type: 'added'\n                });\n                parent.object.dispatchEvent({\n                    type: 'childadded',\n                    child: child.object\n                });\n            }\n        } else {\n            parent.object.add(child.object);\n        }\n    }\n    // Link subtree\n    for (const childInstance of child.children)handleContainerEffects(child, childInstance);\n    // Tree was updated, request a frame\n    invalidateInstance(child);\n}\nfunction appendChild(parent, child) {\n    if (!child) return;\n    // Link instances\n    child.parent = parent;\n    parent.children.push(child);\n    // Attach tree once complete\n    handleContainerEffects(parent, child);\n}\nfunction insertBefore(parent, child, beforeChild) {\n    if (!child || !beforeChild) return;\n    // Link instances\n    child.parent = parent;\n    const childIndex = parent.children.indexOf(beforeChild);\n    if (childIndex !== -1) parent.children.splice(childIndex, 0, child);\n    else parent.children.push(child);\n    // Attach tree once complete\n    handleContainerEffects(parent, child, beforeChild);\n}\nfunction disposeOnIdle(object) {\n    if (typeof object.dispose === 'function') {\n        const handleDispose = ()=>{\n            try {\n                object.dispose();\n            } catch  {\n            // no-op\n            }\n        };\n        // In a testing environment, cleanup immediately\n        if (typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined') handleDispose();\n        else (0,scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_IdlePriority, handleDispose);\n    }\n}\nfunction removeChild(parent, child, dispose) {\n    if (!child) return;\n    // Unlink instances\n    child.parent = null;\n    const childIndex = parent.children.indexOf(child);\n    if (childIndex !== -1) parent.children.splice(childIndex, 1);\n    // Eagerly tear down tree\n    if (child.props.attach) {\n        detach(parent, child);\n    } else if (isObject3D(child.object) && isObject3D(parent.object)) {\n        parent.object.remove(child.object);\n        removeInteractivity(findInitialRoot(child), child.object);\n    }\n    // Allow objects to bail out of unmount disposal with dispose={null}\n    const shouldDispose = child.props.dispose !== null && dispose !== false;\n    // Recursively remove instance children\n    for(let i = child.children.length - 1; i >= 0; i--){\n        const node = child.children[i];\n        removeChild(child, node, shouldDispose);\n    }\n    child.children.length = 0;\n    // Unlink instance object\n    delete child.object.__r3f;\n    // Dispose object whenever the reconciler feels like it.\n    // Never dispose of primitives because their state may be kept outside of React!\n    // In order for an object to be able to dispose it\n    //   - has a dispose method\n    //   - cannot be a <primitive object={...} />\n    //   - cannot be a THREE.Scene, because three has broken its own API\n    if (shouldDispose && child.type !== 'primitive' && child.object.type !== 'Scene') {\n        disposeOnIdle(child.object);\n    }\n    // Tree was updated, request a frame for top-level instance\n    if (dispose === undefined) invalidateInstance(child);\n}\nfunction setFiberRef(fiber, publicInstance) {\n    for (const _fiber of [\n        fiber,\n        fiber.alternate\n    ]){\n        if (_fiber !== null) {\n            if (typeof _fiber.ref === 'function') {\n                _fiber.refCleanup == null ? void 0 : _fiber.refCleanup();\n                const cleanup = _fiber.ref(publicInstance);\n                if (typeof cleanup === 'function') _fiber.refCleanup = cleanup;\n            } else if (_fiber.ref) {\n                _fiber.ref.current = publicInstance;\n            }\n        }\n    }\n}\nconst reconstructed = [];\nfunction swapInstances() {\n    // Detach instance\n    for (const [instance] of reconstructed){\n        const parent = instance.parent;\n        if (parent) {\n            if (instance.props.attach) {\n                detach(parent, instance);\n            } else if (isObject3D(instance.object) && isObject3D(parent.object)) {\n                parent.object.remove(instance.object);\n            }\n            for (const child of instance.children){\n                if (child.props.attach) {\n                    detach(instance, child);\n                } else if (isObject3D(child.object) && isObject3D(instance.object)) {\n                    instance.object.remove(child.object);\n                }\n            }\n        }\n        // If the old instance is hidden, we need to unhide it.\n        // React assumes it can discard instances since they're pure for DOM.\n        // This isn't true for us since our lifetimes are impure and longliving.\n        // So, we manually check if an instance was hidden and unhide it.\n        if (instance.isHidden) unhideInstance(instance);\n        // Dispose of old object if able\n        if (instance.object.__r3f) delete instance.object.__r3f;\n        if (instance.type !== 'primitive') disposeOnIdle(instance.object);\n    }\n    // Update instance\n    for (const [instance, props, fiber] of reconstructed){\n        instance.props = props;\n        const parent = instance.parent;\n        if (parent) {\n            var _instance$props$objec, _instance$props$args;\n            // Get target from catalogue\n            const target = catalogue[toPascalCase(instance.type)];\n            // Create object\n            instance.object = (_instance$props$objec = instance.props.object) != null ? _instance$props$objec : new target(...(_instance$props$args = instance.props.args) != null ? _instance$props$args : []);\n            instance.object.__r3f = instance;\n            setFiberRef(fiber, instance.object);\n            // Set initial props\n            applyProps(instance.object, instance.props);\n            if (instance.props.attach) {\n                attach(parent, instance);\n            } else if (isObject3D(instance.object) && isObject3D(parent.object)) {\n                parent.object.add(instance.object);\n            }\n            for (const child of instance.children){\n                if (child.props.attach) {\n                    attach(instance, child);\n                } else if (isObject3D(child.object) && isObject3D(instance.object)) {\n                    instance.object.add(child.object);\n                }\n            }\n            // Tree was updated, request a frame\n            invalidateInstance(instance);\n        }\n    }\n    reconstructed.length = 0;\n}\n// Don't handle text instances, make it no-op\nconst handleTextInstance = ()=>{};\nconst NO_CONTEXT = {};\nlet currentUpdatePriority = NoEventPriority;\n// https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberFlags.js\nconst NoFlags = 0;\nconst Update = 4;\nconst reconciler = /* @__PURE__ */ createReconciler({\n    isPrimaryRenderer: false,\n    warnsIfNotActing: false,\n    supportsMutation: true,\n    supportsPersistence: false,\n    supportsHydration: false,\n    createInstance,\n    removeChild,\n    appendChild,\n    appendInitialChild: appendChild,\n    insertBefore,\n    appendChildToContainer (container, child) {\n        const scene = container.getState().scene.__r3f;\n        if (!child || !scene) return;\n        appendChild(scene, child);\n    },\n    removeChildFromContainer (container, child) {\n        const scene = container.getState().scene.__r3f;\n        if (!child || !scene) return;\n        removeChild(scene, child);\n    },\n    insertInContainerBefore (container, child, beforeChild) {\n        const scene = container.getState().scene.__r3f;\n        if (!child || !beforeChild || !scene) return;\n        insertBefore(scene, child, beforeChild);\n    },\n    getRootHostContext: ()=>NO_CONTEXT,\n    getChildHostContext: ()=>NO_CONTEXT,\n    commitUpdate (instance, type, oldProps, newProps, fiber) {\n        var _newProps$args, _oldProps$args, _newProps$args2;\n        validateInstance(type, newProps);\n        let reconstruct = false;\n        // Reconstruct primitives if object prop changes\n        if (instance.type === 'primitive' && oldProps.object !== newProps.object) reconstruct = true;\n        else if (((_newProps$args = newProps.args) == null ? void 0 : _newProps$args.length) !== ((_oldProps$args = oldProps.args) == null ? void 0 : _oldProps$args.length)) reconstruct = true;\n        else if ((_newProps$args2 = newProps.args) != null && _newProps$args2.some((value, index)=>{\n            var _oldProps$args2;\n            return value !== ((_oldProps$args2 = oldProps.args) == null ? void 0 : _oldProps$args2[index]);\n        })) reconstruct = true;\n        // Reconstruct when args or <primitive object={...} have changes\n        if (reconstruct) {\n            reconstructed.push([\n                instance,\n                {\n                    ...newProps\n                },\n                fiber\n            ]);\n        } else {\n            // Create a diff-set, flag if there are any changes\n            const changedProps = diffProps(instance, newProps);\n            if (Object.keys(changedProps).length) {\n                Object.assign(instance.props, changedProps);\n                applyProps(instance.object, changedProps);\n            }\n        }\n        // Flush reconstructed siblings when we hit the last updated child in a sequence\n        const isTailSibling = fiber.sibling === null || (fiber.flags & Update) === NoFlags;\n        if (isTailSibling) swapInstances();\n    },\n    finalizeInitialChildren: ()=>false,\n    commitMount () {},\n    getPublicInstance: (instance)=>instance == null ? void 0 : instance.object,\n    prepareForCommit: ()=>null,\n    preparePortalMount: (container)=>prepare(container.getState().scene, container, '', {}),\n    resetAfterCommit: ()=>{},\n    shouldSetTextContent: ()=>false,\n    clearContainer: ()=>false,\n    hideInstance,\n    unhideInstance,\n    createTextInstance: handleTextInstance,\n    hideTextInstance: handleTextInstance,\n    unhideTextInstance: handleTextInstance,\n    scheduleTimeout: typeof setTimeout === 'function' ? setTimeout : undefined,\n    cancelTimeout: typeof clearTimeout === 'function' ? clearTimeout : undefined,\n    noTimeout: -1,\n    getInstanceFromNode: ()=>null,\n    beforeActiveInstanceBlur () {},\n    afterActiveInstanceBlur () {},\n    detachDeletedInstance () {},\n    prepareScopeUpdate () {},\n    getInstanceFromScope: ()=>null,\n    shouldAttemptEagerTransition: ()=>false,\n    trackSchedulerEvent: ()=>{},\n    resolveEventType: ()=>null,\n    resolveEventTimeStamp: ()=>-1.1,\n    requestPostPaintCallback () {},\n    maySuspendCommit: ()=>false,\n    preloadInstance: ()=>true,\n    // true indicates already loaded\n    startSuspendingCommit () {},\n    suspendInstance () {},\n    waitForCommitToBeReady: ()=>null,\n    NotPendingTransition: null,\n    // The reconciler types use the internal ReactContext with all the hidden properties\n    // so we have to cast from the public React.Context type\n    HostTransitionContext: /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null),\n    setCurrentUpdatePriority (newPriority) {\n        currentUpdatePriority = newPriority;\n    },\n    getCurrentUpdatePriority () {\n        return currentUpdatePriority;\n    },\n    resolveUpdatePriority () {\n        var _window$event;\n        if (currentUpdatePriority !== NoEventPriority) return currentUpdatePriority;\n        switch( false && (0)){\n            case 'click':\n            case 'contextmenu':\n            case 'dblclick':\n            case 'pointercancel':\n            case 'pointerdown':\n            case 'pointerup':\n                return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n            case 'pointermove':\n            case 'pointerout':\n            case 'pointerover':\n            case 'pointerenter':\n            case 'pointerleave':\n            case 'wheel':\n                return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n            default:\n                return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n        }\n    },\n    resetFormInstance () {}\n});\nconst _roots = new Map();\nconst shallowLoose = {\n    objects: 'shallow',\n    strict: false\n};\nfunction computeInitialSize(canvas, size) {\n    if (!size && typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n        const { width, height, top, left } = canvas.parentElement.getBoundingClientRect();\n        return {\n            width,\n            height,\n            top,\n            left\n        };\n    } else if (!size && typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            top: 0,\n            left: 0\n        };\n    }\n    return {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        ...size\n    };\n}\nfunction createRoot(canvas) {\n    // Check against mistaken use of createRoot\n    const prevRoot = _roots.get(canvas);\n    const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n    const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n    if (prevRoot) console.warn('R3F.createRoot should only be called once!');\n    // Report when an error was detected in a previous render\n    // https://github.com/pmndrs/react-three-fiber/pull/2261\n    const logRecoverableError = typeof reportError === 'function' ? // In modern browsers, reportError will dispatch an error event,\n    // emulating an uncaught JavaScript error.\n    reportError : // In older browsers and test environments, fallback to console.error.\n    console.error;\n    // Create store\n    const store = prevStore || createStore(invalidate, advance);\n    // Create renderer\n    const fiber = prevFiber || reconciler.createContainer(store, // container\n    react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot, // tag\n    null, // hydration callbacks\n    false, // isStrictMode\n    null, // concurrentUpdatesByDefaultOverride\n    '', // identifierPrefix\n    logRecoverableError, // onUncaughtError\n    logRecoverableError, // onCaughtError\n    logRecoverableError, // onRecoverableError\n    null // transitionCallbacks\n    );\n    // Map it\n    if (!prevRoot) _roots.set(canvas, {\n        fiber,\n        store\n    });\n    // Locals\n    let onCreated;\n    let lastCamera;\n    let configured = false;\n    let pending = null;\n    return {\n        async configure (props = {}) {\n            let resolve;\n            pending = new Promise((_resolve)=>resolve = _resolve);\n            let { gl: glConfig, size: propsSize, scene: sceneOptions, events, onCreated: onCreatedCallback, shadows = false, linear = false, flat = false, legacy = false, orthographic = false, frameloop = 'always', dpr = [\n                1,\n                2\n            ], performance, raycaster: raycastOptions, camera: cameraOptions, onPointerMissed } = props;\n            let state = store.getState();\n            // Set up renderer (one time only!)\n            let gl = state.gl;\n            if (!state.gl) {\n                const defaultProps = {\n                    canvas: canvas,\n                    powerPreference: 'high-performance',\n                    antialias: true,\n                    alpha: true\n                };\n                const customRenderer = typeof glConfig === 'function' ? await glConfig(defaultProps) : glConfig;\n                if (isRenderer(customRenderer)) {\n                    gl = customRenderer;\n                } else {\n                    gl = new three__WEBPACK_IMPORTED_MODULE_9__.WebGLRenderer({\n                        ...defaultProps,\n                        ...glConfig\n                    });\n                }\n                state.set({\n                    gl\n                });\n            }\n            // Set up raycaster (one time only!)\n            let raycaster = state.raycaster;\n            if (!raycaster) state.set({\n                raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_6__.Raycaster()\n            });\n            // Set raycaster options\n            const { params, ...options } = raycastOptions || {};\n            if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n                ...options\n            });\n            if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n                params: {\n                    ...raycaster.params,\n                    ...params\n                }\n            });\n            // Create default camera, don't overwrite any user-set state\n            if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n                lastCamera = cameraOptions;\n                const isCamera = cameraOptions == null ? void 0 : cameraOptions.isCamera;\n                const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_6__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_6__.PerspectiveCamera(75, 0, 0.1, 1000);\n                if (!isCamera) {\n                    camera.position.z = 5;\n                    if (cameraOptions) {\n                        applyProps(camera, cameraOptions);\n                        // Preserve user-defined frustum if possible\n                        // https://github.com/pmndrs/react-three-fiber/issues/3160\n                        if (!camera.manual) {\n                            if ('aspect' in cameraOptions || 'left' in cameraOptions || 'right' in cameraOptions || 'bottom' in cameraOptions || 'top' in cameraOptions) {\n                                camera.manual = true;\n                                camera.updateProjectionMatrix();\n                            }\n                        }\n                    }\n                    // Always look at center by default\n                    if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n                }\n                state.set({\n                    camera\n                });\n                // Configure raycaster\n                // https://github.com/pmndrs/react-xr/issues/300\n                raycaster.camera = camera;\n            }\n            // Set up scene (one time only!)\n            if (!state.scene) {\n                let scene;\n                if (sceneOptions != null && sceneOptions.isScene) {\n                    scene = sceneOptions;\n                    prepare(scene, store, '', {});\n                } else {\n                    scene = new three__WEBPACK_IMPORTED_MODULE_6__.Scene();\n                    prepare(scene, store, '', {});\n                    if (sceneOptions) applyProps(scene, sceneOptions);\n                }\n                state.set({\n                    scene\n                });\n            }\n            // Store events internally\n            if (events && !state.events.handlers) state.set({\n                events: events(store)\n            });\n            // Check size, allow it to take on container bounds initially\n            const size = computeInitialSize(canvas, propsSize);\n            if (!is.equ(size, state.size, shallowLoose)) {\n                state.setSize(size.width, size.height, size.top, size.left);\n            }\n            // Check pixelratio\n            if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n            // Check frameloop\n            if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n            // Check pointer missed\n            if (!state.onPointerMissed) state.set({\n                onPointerMissed\n            });\n            // Check performance\n            if (performance && !is.equ(performance, state.performance, shallowLoose)) state.set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        ...performance\n                    }\n                }));\n            // Set up XR (one time only!)\n            if (!state.xr) {\n                var _gl$xr;\n                // Handle frame behavior in WebXR\n                const handleXRFrame = (timestamp, frame)=>{\n                    const state = store.getState();\n                    if (state.frameloop === 'never') return;\n                    advance(timestamp, true, state, frame);\n                };\n                // Toggle render switching on session\n                const handleSessionChange = ()=>{\n                    const state = store.getState();\n                    state.gl.xr.enabled = state.gl.xr.isPresenting;\n                    state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n                    if (!state.gl.xr.isPresenting) invalidate(state);\n                };\n                // WebXR session manager\n                const xr = {\n                    connect () {\n                        const gl = store.getState().gl;\n                        gl.xr.addEventListener('sessionstart', handleSessionChange);\n                        gl.xr.addEventListener('sessionend', handleSessionChange);\n                    },\n                    disconnect () {\n                        const gl = store.getState().gl;\n                        gl.xr.removeEventListener('sessionstart', handleSessionChange);\n                        gl.xr.removeEventListener('sessionend', handleSessionChange);\n                    }\n                };\n                // Subscribe to WebXR session events\n                if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === 'function') xr.connect();\n                state.set({\n                    xr\n                });\n            }\n            // Set shadowmap\n            if (gl.shadowMap) {\n                const oldEnabled = gl.shadowMap.enabled;\n                const oldType = gl.shadowMap.type;\n                gl.shadowMap.enabled = !!shadows;\n                if (is.boo(shadows)) {\n                    gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap;\n                } else if (is.str(shadows)) {\n                    var _types$shadows;\n                    const types = {\n                        basic: three__WEBPACK_IMPORTED_MODULE_6__.BasicShadowMap,\n                        percentage: three__WEBPACK_IMPORTED_MODULE_6__.PCFShadowMap,\n                        soft: three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap,\n                        variance: three__WEBPACK_IMPORTED_MODULE_6__.VSMShadowMap\n                    };\n                    gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap;\n                } else if (is.obj(shadows)) {\n                    Object.assign(gl.shadowMap, shadows);\n                }\n                if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n            }\n            three__WEBPACK_IMPORTED_MODULE_6__.ColorManagement.enabled = !legacy;\n            // Set color space and tonemapping preferences\n            if (!configured) {\n                gl.outputColorSpace = linear ? three__WEBPACK_IMPORTED_MODULE_6__.LinearSRGBColorSpace : three__WEBPACK_IMPORTED_MODULE_6__.SRGBColorSpace;\n                gl.toneMapping = flat ? three__WEBPACK_IMPORTED_MODULE_6__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_6__.ACESFilmicToneMapping;\n            }\n            // Update color management state\n            if (state.legacy !== legacy) state.set(()=>({\n                    legacy\n                }));\n            if (state.linear !== linear) state.set(()=>({\n                    linear\n                }));\n            if (state.flat !== flat) state.set(()=>({\n                    flat\n                }));\n            // Set gl props\n            if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n            // Set locals\n            onCreated = onCreatedCallback;\n            configured = true;\n            resolve();\n            return this;\n        },\n        render (children) {\n            // The root has to be configured before it can be rendered\n            if (!configured && !pending) this.configure();\n            pending.then(()=>{\n                reconciler.updateContainer(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Provider, {\n                    store: store,\n                    children: children,\n                    onCreated: onCreated,\n                    rootElement: canvas\n                }), fiber, null, ()=>undefined);\n            });\n            return store;\n        },\n        unmount () {\n            unmountComponentAtNode(canvas);\n        }\n    };\n}\nfunction Provider({ store, children, onCreated, rootElement }) {\n    useIsomorphicLayoutEffect({\n        \"Provider.useIsomorphicLayoutEffect\": ()=>{\n            const state = store.getState();\n            // Flag the canvas active, rendering will now begin\n            state.set({\n                \"Provider.useIsomorphicLayoutEffect\": (state)=>({\n                        internal: {\n                            ...state.internal,\n                            active: true\n                        }\n                    })\n            }[\"Provider.useIsomorphicLayoutEffect\"]);\n            // Notify that init is completed, the scene graph exists, but nothing has yet rendered\n            if (onCreated) onCreated(state);\n            // Connect events to the targets parent, this is done to ensure events are registered on\n            // a shared target, and not on the canvas itself\n            if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"Provider.useIsomorphicLayoutEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(context.Provider, {\n        value: store,\n        children: children\n    });\n}\nfunction unmountComponentAtNode(canvas, callback) {\n    const root = _roots.get(canvas);\n    const fiber = root == null ? void 0 : root.fiber;\n    if (fiber) {\n        const state = root == null ? void 0 : root.store.getState();\n        if (state) state.internal.active = false;\n        reconciler.updateContainer(null, fiber, null, ()=>{\n            if (state) {\n                setTimeout(()=>{\n                    try {\n                        var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n                        state.events.disconnect == null ? void 0 : state.events.disconnect();\n                        (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n                        (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n                        if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n                        dispose(state.scene);\n                        _roots.delete(canvas);\n                        if (callback) callback(canvas);\n                    } catch (e) {\n                    /* ... */ }\n                }, 500);\n            }\n        });\n    }\n}\nfunction createPortal(children, container, state) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Portal, {\n        children: children,\n        container: container,\n        state: state\n    });\n}\nfunction Portal({ state = {}, children, container }) {\n    /** This has to be a component because it would not be able to call useThree/useStore otherwise since\r\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\r\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\r\n   *  <Canvas>\r\n   *    {createPortal(...)} */ const { events, size, ...rest } = state;\n    const previousRoot = useStore();\n    const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        \"Portal.useState\": ()=>new three__WEBPACK_IMPORTED_MODULE_6__.Raycaster()\n    }[\"Portal.useState\"]);\n    const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        \"Portal.useState\": ()=>new three__WEBPACK_IMPORTED_MODULE_6__.Vector2()\n    }[\"Portal.useState\"]);\n    const inject = useMutableCallback({\n        \"Portal.useMutableCallback[inject]\": (rootState, injectState)=>{\n            let viewport = undefined;\n            if (injectState.camera && size) {\n                const camera = injectState.camera;\n                // Calculate the override viewport, if present\n                viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(), size);\n                // Update the portal camera, if it differs from the previous layer\n                if (camera !== rootState.camera) updateCamera(camera, size);\n            }\n            return {\n                // The intersect consists of the previous root state\n                ...rootState,\n                ...injectState,\n                // Portals have their own scene, which forms the root, a raycaster and a pointer\n                scene: container,\n                raycaster,\n                pointer,\n                mouse: pointer,\n                // Their previous root is the layer before it\n                previousRoot,\n                // Events, size and viewport can be overridden by the inject layer\n                events: {\n                    ...rootState.events,\n                    ...injectState.events,\n                    ...events\n                },\n                size: {\n                    ...rootState.size,\n                    ...size\n                },\n                viewport: {\n                    ...rootState.viewport,\n                    ...viewport\n                },\n                // Layers are allowed to override events\n                setEvents: ({\n                    \"Portal.useMutableCallback[inject]\": (events)=>injectState.set({\n                            \"Portal.useMutableCallback[inject]\": (state)=>({\n                                    ...state,\n                                    events: {\n                                        ...state.events,\n                                        ...events\n                                    }\n                                })\n                        }[\"Portal.useMutableCallback[inject]\"])\n                })[\"Portal.useMutableCallback[inject]\"]\n            };\n        }\n    }[\"Portal.useMutableCallback[inject]\"]);\n    const usePortalStore = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"Portal.useMemo[usePortalStore]\": ()=>{\n            // Create a mirrored store, based on the previous root with a few overrides ...\n            const store = (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_7__.createWithEqualityFn)({\n                \"Portal.useMemo[usePortalStore].store\": (set, get)=>({\n                        ...rest,\n                        set,\n                        get\n                    })\n            }[\"Portal.useMemo[usePortalStore].store\"]);\n            // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n            const onMutate = {\n                \"Portal.useMemo[usePortalStore].onMutate\": (prev)=>store.setState({\n                        \"Portal.useMemo[usePortalStore].onMutate\": (state)=>inject.current(prev, state)\n                    }[\"Portal.useMemo[usePortalStore].onMutate\"])\n            }[\"Portal.useMemo[usePortalStore].onMutate\"];\n            onMutate(previousRoot.getState());\n            previousRoot.subscribe(onMutate);\n            return store;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"Portal.useMemo[usePortalStore]\"], [\n        previousRoot,\n        container\n    ]);\n    return(/*#__PURE__*/ // @ts-ignore, reconciler types are not maintained\n    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {\n        children: reconciler.createPortal(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(context.Provider, {\n            value: usePortalStore,\n            children: children\n        }), usePortalStore, null)\n    }));\n}\n/**\r\n * Force React to flush any updates inside the provided callback synchronously and immediately.\r\n * All the same caveats documented for react-dom's `flushSync` apply here (see https://react.dev/reference/react-dom/flushSync).\r\n * Nevertheless, sometimes one needs to render synchronously, for example to keep DOM and 3D changes in lock-step without\r\n * having to revert to a non-React solution. Note: this will only flush updates within the `Canvas` root.\r\n */ function flushSync(fn) {\n    // @ts-ignore - reconciler types are not maintained\n    return reconciler.flushSyncFromReconciler(fn);\n}\nfunction createSubs(callback, subs) {\n    const sub = {\n        callback\n    };\n    subs.add(sub);\n    return ()=>void subs.delete(sub);\n}\nconst globalEffects = new Set();\nconst globalAfterEffects = new Set();\nconst globalTailEffects = new Set();\n/**\r\n * Adds a global render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\r\n */ const addEffect = (callback)=>createSubs(callback, globalEffects);\n/**\r\n * Adds a global after-render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\r\n */ const addAfterEffect = (callback)=>createSubs(callback, globalAfterEffects);\n/**\r\n * Adds a global callback which is called when rendering stops.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\r\n */ const addTail = (callback)=>createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n    if (!effects.size) return;\n    for (const { callback } of effects.values()){\n        callback(timestamp);\n    }\n}\nfunction flushGlobalEffects(type, timestamp) {\n    switch(type){\n        case 'before':\n            return run(globalEffects, timestamp);\n        case 'after':\n            return run(globalAfterEffects, timestamp);\n        case 'tail':\n            return run(globalTailEffects, timestamp);\n    }\n}\nlet subscribers;\nlet subscription;\nfunction update(timestamp, state, frame) {\n    // Run local effects\n    let delta = state.clock.getDelta();\n    // In frameloop='never' mode, clock times are updated using the provided timestamp\n    if (state.frameloop === 'never' && typeof timestamp === 'number') {\n        delta = timestamp - state.clock.elapsedTime;\n        state.clock.oldTime = state.clock.elapsedTime;\n        state.clock.elapsedTime = timestamp;\n    }\n    // Call subscribers (useFrame)\n    subscribers = state.internal.subscribers;\n    for(let i = 0; i < subscribers.length; i++){\n        subscription = subscribers[i];\n        subscription.ref.current(subscription.store.getState(), delta, frame);\n    }\n    // Render content\n    if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n    // Decrease frame count\n    state.internal.frames = Math.max(0, state.internal.frames - 1);\n    return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\nlet running = false;\nlet useFrameInProgress = false;\nlet repeat;\nlet frame;\nlet state;\nfunction loop(timestamp) {\n    frame = requestAnimationFrame(loop);\n    running = true;\n    repeat = 0;\n    // Run effects\n    flushGlobalEffects('before', timestamp);\n    // Render all roots\n    useFrameInProgress = true;\n    for (const root of _roots.values()){\n        var _state$gl$xr;\n        state = root.store.getState();\n        // If the frameloop is invalidated, do not run another frame\n        if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n            repeat += update(timestamp, state);\n        }\n    }\n    useFrameInProgress = false;\n    // Run after-effects\n    flushGlobalEffects('after', timestamp);\n    // Stop the loop if nothing invalidates it\n    if (repeat === 0) {\n        // Tail call effects, they are called when rendering stops\n        flushGlobalEffects('tail', timestamp);\n        // Flag end of operation\n        running = false;\n        return cancelAnimationFrame(frame);\n    }\n}\n/**\r\n * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\r\n */ function invalidate(state, frames = 1) {\n    var _state$gl$xr2;\n    if (!state) return _roots.forEach((root)=>invalidate(root.store.getState(), frames));\n    if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === 'never') return;\n    if (frames > 1) {\n        // legacy support for people using frames parameters\n        // Increase frames, do not go higher than 60\n        state.internal.frames = Math.min(60, state.internal.frames + frames);\n    } else {\n        if (useFrameInProgress) {\n            //called from within a useFrame, it means the user wants an additional frame\n            state.internal.frames = 2;\n        } else {\n            //the user need a new frame, no need to increment further than 1\n            state.internal.frames = 1;\n        }\n    }\n    // If the render-loop isn't active, start it\n    if (!running) {\n        running = true;\n        requestAnimationFrame(loop);\n    }\n}\n/**\r\n * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\r\n */ function advance(timestamp, runGlobalEffects = true, state, frame) {\n    if (runGlobalEffects) flushGlobalEffects('before', timestamp);\n    if (!state) for (const root of _roots.values())update(timestamp, root.store.getState());\n    else update(timestamp, state, frame);\n    if (runGlobalEffects) flushGlobalEffects('after', timestamp);\n}\nconst DOM_EVENTS = {\n    onClick: [\n        'click',\n        false\n    ],\n    onContextMenu: [\n        'contextmenu',\n        false\n    ],\n    onDoubleClick: [\n        'dblclick',\n        false\n    ],\n    onWheel: [\n        'wheel',\n        true\n    ],\n    onPointerDown: [\n        'pointerdown',\n        true\n    ],\n    onPointerUp: [\n        'pointerup',\n        true\n    ],\n    onPointerLeave: [\n        'pointerleave',\n        true\n    ],\n    onPointerMove: [\n        'pointermove',\n        true\n    ],\n    onPointerCancel: [\n        'pointercancel',\n        true\n    ],\n    onLostPointerCapture: [\n        'lostpointercapture',\n        true\n    ]\n};\n/** Default R3F event manager for web */ function createPointerEvents(store) {\n    const { handlePointer } = createEvents(store);\n    return {\n        priority: 1,\n        enabled: true,\n        compute (event, state, previous) {\n            // https://github.com/pmndrs/react-three-fiber/pull/782\n            // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n            state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n            state.raycaster.setFromCamera(state.pointer, state.camera);\n        },\n        connected: undefined,\n        handlers: Object.keys(DOM_EVENTS).reduce((acc, key)=>({\n                ...acc,\n                [key]: handlePointer(key)\n            }), {}),\n        update: ()=>{\n            var _internal$lastEvent;\n            const { events, internal } = store.getState();\n            if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n        },\n        connect: (target)=>{\n            const { set, events } = store.getState();\n            events.disconnect == null ? void 0 : events.disconnect();\n            set((state)=>({\n                    events: {\n                        ...state.events,\n                        connected: target\n                    }\n                }));\n            if (events.handlers) {\n                for(const name in events.handlers){\n                    const event = events.handlers[name];\n                    const [eventName, passive] = DOM_EVENTS[name];\n                    target.addEventListener(eventName, event, {\n                        passive\n                    });\n                }\n            }\n        },\n        disconnect: ()=>{\n            const { set, events } = store.getState();\n            if (events.connected) {\n                if (events.handlers) {\n                    for(const name in events.handlers){\n                        const event = events.handlers[name];\n                        const [eventName] = DOM_EVENTS[name];\n                        events.connected.removeEventListener(eventName, event);\n                    }\n                }\n                set((state)=>({\n                        events: {\n                            ...state.events,\n                            connected: undefined\n                        }\n                    }));\n            }\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvZXZlbnRzLWUzY2I2NmUyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNtRztBQUNuRztBQUM0QjtBQUNIO0FBQ2Q7QUFDbUM7QUFDM0I7QUFDbUI7QUFFckUsSUFBSWtCLGFBQWEsV0FBVyxHQUFFQyxPQUFPQyxNQUFNLENBQUM7SUFDMUNDLFdBQVc7QUFDYjtBQUVBOztDQUVDLEdBQ0QsU0FBU0MsZ0JBQWdCQyxRQUFRO0lBQy9CLElBQUlDLE9BQU9ELFNBQVNDLElBQUk7SUFDeEIsTUFBT0EsS0FBS0MsUUFBUSxHQUFHQyxZQUFZLENBQUVGLE9BQU9BLEtBQUtDLFFBQVEsR0FBR0MsWUFBWTtJQUN4RSxPQUFPRjtBQUNUO0FBQ0E7OztDQUdDLEdBQ0QsK0RBQStEO0FBQy9ELGtEQUFrRDtBQUNsRCxNQUFNRyxNQUFNM0Isa0NBQUssQ0FBQyxRQUFRLEdBQUc7QUFDN0IsTUFBTTRCLHVCQUF1QkMsQ0FBQUEsTUFBT0EsT0FBT0EsSUFBSUQsb0JBQW9CO0FBQ25FLE1BQU1FLFFBQVFDLENBQUFBLE1BQU9BLE9BQU9BLElBQUlDLGNBQWMsQ0FBQztBQUMvQyxNQUFNQyx3QkFBd0JDLENBQUFBLFFBQVNBLFNBQVMsUUFBUyxRQUFPQSxVQUFVLFlBQVksT0FBT0EsVUFBVSxZQUFZQSxNQUFNQyxPQUFPO0FBRWhJOzs7Ozs7OztDQVFDLEdBQ0QsTUFBTUMsNEJBQTJDLGFBQUYsR0FBRyxFQUFDQyxrQkFBa0JDLG9CQUFzQixNQUE2QixJQUFLLEVBQWtNLENBQUMsTUFBT3RDLGtEQUFxQixHQUFHQSw0Q0FBZTtBQUM5VyxTQUFTOEMsbUJBQW1CQyxFQUFFO0lBQzVCLE1BQU1DLE1BQU1oRCx5Q0FBWSxDQUFDK0M7SUFDekJYO3dEQUEwQixJQUFNLEtBQU1ZLENBQUFBLElBQUlFLE9BQU8sR0FB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QU07d0JBQ2Y4RixXQUFXN1A7b0JBQ2I7Z0JBQ0Y7WUFDQSxJQUFJK0osT0FBTzlHLFFBQVEsRUFBRTtnQkFDbkIsSUFBSyxNQUFNZCxRQUFRNEgsT0FBTzlHLFFBQVEsQ0FBRTtvQkFDbEMsTUFBTTJFLFFBQVFtQyxPQUFPOUcsUUFBUSxDQUFDZCxLQUFLO29CQUNuQyxNQUFNLENBQUM0aEIsV0FBV0MsUUFBUSxHQUFHZixVQUFVLENBQUM5Z0IsS0FBSztvQkFDN0NuQyxPQUFPMmUsZ0JBQWdCLENBQUNvRixXQUFXbmMsT0FBTzt3QkFDeENvYztvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQXBGLFlBQVk7WUFDVixNQUFNLEVBQ0o3ZixHQUFHLEVBQ0hnTCxNQUFNLEVBQ1AsR0FBR3ZCLE1BQU05TCxRQUFRO1lBQ2xCLElBQUlxTixPQUFPOEYsU0FBUyxFQUFFO2dCQUNwQixJQUFJOUYsT0FBTzlHLFFBQVEsRUFBRTtvQkFDbkIsSUFBSyxNQUFNZCxRQUFRNEgsT0FBTzlHLFFBQVEsQ0FBRTt3QkFDbEMsTUFBTTJFLFFBQVFtQyxPQUFPOUcsUUFBUSxDQUFDZCxLQUFLO3dCQUNuQyxNQUFNLENBQUM0aEIsVUFBVSxHQUFHZCxVQUFVLENBQUM5Z0IsS0FBSzt3QkFDcEM0SCxPQUFPOEYsU0FBUyxDQUFDZ1AsbUJBQW1CLENBQUNrRixXQUFXbmM7b0JBQ2xEO2dCQUNGO2dCQUNBN0ksSUFBSU8sQ0FBQUEsUUFBVTt3QkFDWnlLLFFBQVE7NEJBQ04sR0FBR3pLLE1BQU15SyxNQUFNOzRCQUNmOEYsV0FBVzdMO3dCQUNiO29CQUNGO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFbW1CIiwic291cmNlcyI6WyJEOlxcV2ViX0FwcHNcXFJlYWN0LVByb2plY3RzXFxxdW90ZS1kZWNvZGVyXFxub2RlX21vZHVsZXNcXEByZWFjdC10aHJlZVxcZmliZXJcXGRpc3RcXGV2ZW50cy1lM2NiNjZlMi5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGVmYXVsdEV2ZW50UHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5LCBEaXNjcmV0ZUV2ZW50UHJpb3JpdHksIENvbmN1cnJlbnRSb290IH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgY3JlYXRlV2l0aEVxdWFsaXR5Rm4gfSBmcm9tICd6dXN0YW5kL3RyYWRpdGlvbmFsJztcbmltcG9ydCB7IHN1c3BlbmQsIHByZWxvYWQsIGNsZWFyIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5pbXBvcnQgUmVjb25jaWxlciBmcm9tICdyZWFjdC1yZWNvbmNpbGVyJztcbmltcG9ydCB7IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssIHVuc3RhYmxlX0lkbGVQcmlvcml0eSB9IGZyb20gJ3NjaGVkdWxlcic7XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgdXNlRmliZXIsIHVzZUNvbnRleHRCcmlkZ2UsIHRyYXZlcnNlRmliZXIgfSBmcm9tICdpdHMtZmluZSc7XG5cbnZhciB0aHJlZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgaW5zdGFuY2UncyBpbml0aWFsIChvdXRtb3N0KSByb290LlxyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbml0aWFsUm9vdChpbnN0YW5jZSkge1xuICBsZXQgcm9vdCA9IGluc3RhbmNlLnJvb3Q7XG4gIHdoaWxlIChyb290LmdldFN0YXRlKCkucHJldmlvdXNSb290KSByb290ID0gcm9vdC5nZXRTdGF0ZSgpLnByZXZpb3VzUm9vdDtcbiAgcmV0dXJuIHJvb3Q7XG59XG4vKipcclxuICogU2FmZWx5IGZsdXNoIGFzeW5jIGVmZmVjdHMgd2hlbiB0ZXN0aW5nLCBzaW11bGF0aW5nIGEgbGVnYWN5IHJvb3QuXHJcbiAqIEBkZXByZWNhdGVkIEltcG9ydCBmcm9tIFJlYWN0IGluc3RlYWQuIGltcG9ydCB7IGFjdCB9IGZyb20gJ3JlYWN0J1xyXG4gKi9cbi8vIFJlZmVyZW5jZSB3aXRoIGNvbXB1dGVkIGtleSB0byBicmVhayBXZWJwYWNrIHN0YXRpYyBhbmFseXNpc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvMTQ4MTRcbmNvbnN0IGFjdCA9IFJlYWN0WydhY3QnICsgJyddO1xuY29uc3QgaXNPcnRob2dyYXBoaWNDYW1lcmEgPSBkZWYgPT4gZGVmICYmIGRlZi5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcbmNvbnN0IGlzUmVmID0gb2JqID0+IG9iaiAmJiBvYmouaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKTtcbmNvbnN0IGlzQ29sb3JSZXByZXNlbnRhdGlvbiA9IHZhbHVlID0+IHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZS5pc0NvbG9yKTtcblxuLyoqXHJcbiAqIEFuIFNTUi1mcmllbmRseSB1c2VMYXlvdXRFZmZlY3QuXHJcbiAqXHJcbiAqIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXHJcbiAqIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXHJcbiAqIHVzZUxheW91dEVmZmVjdCBlbHNld2hlcmUuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDkyN1xyXG4gKi9cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSAvKiBAX19QVVJFX18gKi8oKF93aW5kb3ckZG9jdW1lbnQsIF93aW5kb3ckbmF2aWdhdG9yKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKChfd2luZG93JGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyRkb2N1bWVudC5jcmVhdGVFbGVtZW50KSB8fCAoKF93aW5kb3ckbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckbmF2aWdhdG9yLnByb2R1Y3QpID09PSAnUmVhY3ROYXRpdmUnKSkoKSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbmZ1bmN0aW9uIHVzZU11dGFibGVDYWxsYmFjayhmbikge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoZm4pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKHJlZi5jdXJyZW50ID0gZm4pLCBbZm5dKTtcbiAgcmV0dXJuIHJlZjtcbn1cbi8qKlxyXG4gKiBCcmlkZ2VzIHJlbmRlcmVyIENvbnRleHQgYW5kIFN0cmljdE1vZGUgZnJvbSBhIHByaW1hcnkgcmVuZGVyZXIuXHJcbiAqL1xuZnVuY3Rpb24gdXNlQnJpZGdlKCkge1xuICBjb25zdCBmaWJlciA9IHVzZUZpYmVyKCk7XG4gIGNvbnN0IENvbnRleHRCcmlkZ2UgPSB1c2VDb250ZXh0QnJpZGdlKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4ge1xuICAgIGNvbnN0IHN0cmljdCA9ICEhdHJhdmVyc2VGaWJlcihmaWJlciwgdHJ1ZSwgbm9kZSA9PiBub2RlLnR5cGUgPT09IFJlYWN0LlN0cmljdE1vZGUpO1xuICAgIGNvbnN0IFJvb3QgPSBzdHJpY3QgPyBSZWFjdC5TdHJpY3RNb2RlIDogUmVhY3QuRnJhZ21lbnQ7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goUm9vdCwge1xuICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goQ29udGV4dEJyaWRnZSwge1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pXG4gICAgfSk7XG4gIH0sIFtmaWJlciwgQ29udGV4dEJyaWRnZV0pO1xufVxuZnVuY3Rpb24gQmxvY2soe1xuICBzZXRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2V0KG5ldyBQcm9taXNlKCgpID0+IG51bGwpKTtcbiAgICByZXR1cm4gKCkgPT4gc2V0KGZhbHNlKTtcbiAgfSwgW3NldF0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gTk9URTogc3RhdGljIG1lbWJlcnMgZ2V0IGRvd24tbGV2ZWwgdHJhbnNwaWxlZCB0byBtdXRhdGlvbnMgd2hpY2ggYnJlYWsgdHJlZS1zaGFraW5nXG5jb25zdCBFcnJvckJvdW5kYXJ5ID0gLyogQF9fUFVSRV9fICovKF9FcnJvckJvdW5kYXJ5ID0+IChfRXJyb3JCb3VuZGFyeSA9IGNsYXNzIEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgdGhpcy5wcm9wcy5zZXQoZXJyKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgPyBudWxsIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufSwgX0Vycm9yQm91bmRhcnkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gKCkgPT4gKHtcbiAgZXJyb3I6IHRydWVcbn0pLCBfRXJyb3JCb3VuZGFyeSkpKCk7XG5mdW5jdGlvbiBjYWxjdWxhdGVEcHIoZHByKSB7XG4gIHZhciBfd2luZG93JGRldmljZVBpeGVsUmE7XG4gIC8vIEVyciBvbiB0aGUgc2lkZSBvZiBwcm9ncmVzcyBieSBhc3N1bWluZyAyeCBkcHIgaWYgd2UgY2FuJ3QgZGV0ZWN0IGl0XG4gIC8vIFRoaXMgd2lsbCBoYXBwZW4gaW4gd29ya2VycyB3aGVyZSB3aW5kb3cgaXMgZGVmaW5lZCBidXQgZHByIGlzbid0LlxuICBjb25zdCB0YXJnZXQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IChfd2luZG93JGRldmljZVBpeGVsUmEgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgIT0gbnVsbCA/IF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA6IDIgOiAxO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkcHIpID8gTWF0aC5taW4oTWF0aC5tYXgoZHByWzBdLCB0YXJnZXQpLCBkcHJbMV0pIDogZHByO1xufVxuXG4vKipcclxuICogUmV0dXJucyBpbnN0YW5jZSByb290IHN0YXRlXHJcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdFN0YXRlKG9iaikge1xuICB2YXIgX3IzZjtcbiAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5yb290LmdldFN0YXRlKCk7XG59XG4vLyBBIGNvbGxlY3Rpb24gb2YgY29tcGFyZSBmdW5jdGlvbnNcbmNvbnN0IGlzID0ge1xuICBvYmo6IGEgPT4gYSA9PT0gT2JqZWN0KGEpICYmICFpcy5hcnIoYSkgJiYgdHlwZW9mIGEgIT09ICdmdW5jdGlvbicsXG4gIGZ1bjogYSA9PiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyxcbiAgc3RyOiBhID0+IHR5cGVvZiBhID09PSAnc3RyaW5nJyxcbiAgbnVtOiBhID0+IHR5cGVvZiBhID09PSAnbnVtYmVyJyxcbiAgYm9vOiBhID0+IHR5cGVvZiBhID09PSAnYm9vbGVhbicsXG4gIHVuZDogYSA9PiBhID09PSB2b2lkIDAsXG4gIG51bDogYSA9PiBhID09PSBudWxsLFxuICBhcnI6IGEgPT4gQXJyYXkuaXNBcnJheShhKSxcbiAgZXF1KGEsIGIsIHtcbiAgICBhcnJheXMgPSAnc2hhbGxvdycsXG4gICAgb2JqZWN0cyA9ICdyZWZlcmVuY2UnLFxuICAgIHN0cmljdCA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgLy8gV3JvbmcgdHlwZSBvciBvbmUgb2YgdGhlIHR3byB1bmRlZmluZWQsIGRvZXNuJ3QgbWF0Y2hcbiAgICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiIHx8ICEhYSAhPT0gISFiKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXRvbWljLCBqdXN0IGNvbXBhcmUgYSBhZ2FpbnN0IGJcbiAgICBpZiAoaXMuc3RyKGEpIHx8IGlzLm51bShhKSB8fCBpcy5ib28oYSkpIHJldHVybiBhID09PSBiO1xuICAgIGNvbnN0IGlzT2JqID0gaXMub2JqKGEpO1xuICAgIGlmIChpc09iaiAmJiBvYmplY3RzID09PSAncmVmZXJlbmNlJykgcmV0dXJuIGEgPT09IGI7XG4gICAgY29uc3QgaXNBcnIgPSBpcy5hcnIoYSk7XG4gICAgaWYgKGlzQXJyICYmIGFycmF5cyA9PT0gJ3JlZmVyZW5jZScpIHJldHVybiBhID09PSBiO1xuICAgIC8vIEFycmF5IG9yIE9iamVjdCwgc2hhbGxvdyBjb21wYXJlIGZpcnN0IHRvIHNlZSBpZiBpdCdzIGEgbWF0Y2hcbiAgICBpZiAoKGlzQXJyIHx8IGlzT2JqKSAmJiBhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBMYXN0IHJlc29ydCwgZ28gdGhyb3VnaCBrZXlzXG4gICAgbGV0IGk7XG4gICAgLy8gQ2hlY2sgaWYgYSBoYXMgYWxsIHRoZSBrZXlzIG9mIGJcbiAgICBmb3IgKGkgaW4gYSkgaWYgKCEoaSBpbiBiKSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIENoZWNrIGlmIHZhbHVlcyBiZXR3ZWVuIGtleXMgbWF0Y2hcbiAgICBpZiAoaXNPYmogJiYgYXJyYXlzID09PSAnc2hhbGxvdycgJiYgb2JqZWN0cyA9PT0gJ3NoYWxsb3cnKSB7XG4gICAgICBmb3IgKGkgaW4gc3RyaWN0ID8gYiA6IGEpIGlmICghaXMuZXF1KGFbaV0sIGJbaV0sIHtcbiAgICAgICAgc3RyaWN0LFxuICAgICAgICBvYmplY3RzOiAncmVmZXJlbmNlJ1xuICAgICAgfSkpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpIGluIHN0cmljdCA/IGIgOiBhKSBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiBpIGlzIHVuZGVmaW5lZFxuICAgIGlmIChpcy51bmQoaSkpIHtcbiAgICAgIC8vIElmIGJvdGggYXJyYXlzIGFyZSBlbXB0eSB3ZSBjb25zaWRlciB0aGVtIGVxdWFsXG4gICAgICBpZiAoaXNBcnIgJiYgYS5sZW5ndGggPT09IDAgJiYgYi5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgLy8gSWYgYm90aCBvYmplY3RzIGFyZSBlbXB0eSB3ZSBjb25zaWRlciB0aGVtIGVxdWFsXG4gICAgICBpZiAoaXNPYmogJiYgT2JqZWN0LmtleXMoYSkubGVuZ3RoID09PSAwICYmIE9iamVjdC5rZXlzKGIpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBPdGhlcndpc2UgbWF0Y2ggdGhlbSBieSB2YWx1ZVxuICAgICAgaWYgKGEgIT09IGIpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIENvbGxlY3RzIG5vZGVzIGFuZCBtYXRlcmlhbHMgZnJvbSBhIFRIUkVFLk9iamVjdDNEXG5mdW5jdGlvbiBidWlsZEdyYXBoKG9iamVjdCkge1xuICBjb25zdCBkYXRhID0ge1xuICAgIG5vZGVzOiB7fSxcbiAgICBtYXRlcmlhbHM6IHt9LFxuICAgIG1lc2hlczoge31cbiAgfTtcbiAgaWYgKG9iamVjdCkge1xuICAgIG9iamVjdC50cmF2ZXJzZShvYmogPT4ge1xuICAgICAgaWYgKG9iai5uYW1lKSBkYXRhLm5vZGVzW29iai5uYW1lXSA9IG9iajtcbiAgICAgIGlmIChvYmoubWF0ZXJpYWwgJiYgIWRhdGEubWF0ZXJpYWxzW29iai5tYXRlcmlhbC5uYW1lXSkgZGF0YS5tYXRlcmlhbHNbb2JqLm1hdGVyaWFsLm5hbWVdID0gb2JqLm1hdGVyaWFsO1xuICAgICAgaWYgKG9iai5pc01lc2ggJiYgIWRhdGEubWVzaGVzW29iai5uYW1lXSkgZGF0YS5tZXNoZXNbb2JqLm5hbWVdID0gb2JqO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuLy8gRGlzcG9zZXMgYW4gb2JqZWN0IGFuZCBhbGwgaXRzIHByb3BlcnRpZXNcbmZ1bmN0aW9uIGRpc3Bvc2Uob2JqKSB7XG4gIGlmIChvYmoudHlwZSAhPT0gJ1NjZW5lJykgb2JqLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IG9iai5kaXNwb3NlKCk7XG4gIGZvciAoY29uc3QgcCBpbiBvYmopIHtcbiAgICBjb25zdCBwcm9wID0gb2JqW3BdO1xuICAgIGlmICgocHJvcCA9PSBudWxsID8gdm9pZCAwIDogcHJvcC50eXBlKSAhPT0gJ1NjZW5lJykgcHJvcCA9PSBudWxsID8gdm9pZCAwIDogcHJvcC5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBwcm9wLmRpc3Bvc2UoKTtcbiAgfVxufVxuY29uc3QgUkVBQ1RfSU5URVJOQUxfUFJPUFMgPSBbJ2NoaWxkcmVuJywgJ2tleScsICdyZWYnXTtcblxuLy8gR2V0cyBvbmx5IGluc3RhbmNlIHByb3BzIGZyb20gcmVjb25jaWxlciBmaWJlcnNcbmZ1bmN0aW9uIGdldEluc3RhbmNlUHJvcHMocXVldWUpIHtcbiAgY29uc3QgcHJvcHMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcXVldWUpIHtcbiAgICBpZiAoIVJFQUNUX0lOVEVSTkFMX1BST1BTLmluY2x1ZGVzKGtleSkpIHByb3BzW2tleV0gPSBxdWV1ZVtrZXldO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuLy8gRWFjaCBvYmplY3QgaW4gdGhlIHNjZW5lIGNhcnJpZXMgYSBzbWFsbCBMb2NhbFN0YXRlIGRlc2NyaXB0b3JcbmZ1bmN0aW9uIHByZXBhcmUodGFyZ2V0LCByb290LCB0eXBlLCBwcm9wcykge1xuICBjb25zdCBvYmplY3QgPSB0YXJnZXQ7XG5cbiAgLy8gQ3JlYXRlIGluc3RhbmNlIGRlc2NyaXB0b3JcbiAgbGV0IGluc3RhbmNlID0gb2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBvYmplY3QuX19yM2Y7XG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZSA9IHtcbiAgICAgIHJvb3QsXG4gICAgICB0eXBlLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgcHJvcHM6IGdldEluc3RhbmNlUHJvcHMocHJvcHMpLFxuICAgICAgb2JqZWN0LFxuICAgICAgZXZlbnRDb3VudDogMCxcbiAgICAgIGhhbmRsZXJzOiB7fSxcbiAgICAgIGlzSGlkZGVuOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKG9iamVjdCkgb2JqZWN0Ll9fcjNmID0gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZShyb290LCBrZXkpIHtcbiAgbGV0IHRhcmdldCA9IHJvb3Rba2V5XTtcbiAgaWYgKCFrZXkuaW5jbHVkZXMoJy0nKSkgcmV0dXJuIHtcbiAgICByb290LFxuICAgIGtleSxcbiAgICB0YXJnZXRcbiAgfTtcblxuICAvLyBSZXNvbHZlIHBpZXJjZWQgdGFyZ2V0XG4gIHRhcmdldCA9IHJvb3Q7XG4gIGZvciAoY29uc3QgcGFydCBvZiBrZXkuc3BsaXQoJy0nKSkge1xuICAgIHZhciBfdGFyZ2V0O1xuICAgIGtleSA9IHBhcnQ7XG4gICAgcm9vdCA9IHRhcmdldDtcbiAgICB0YXJnZXQgPSAoX3RhcmdldCA9IHRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXRba2V5XTtcbiAgfVxuXG4gIC8vIFRPRE86IGNoYW5nZSBrZXkgdG8gJ2Zvby1iYXInIGlmIHRhcmdldCBpcyB1bmRlZmluZWQ/XG5cbiAgcmV0dXJuIHtcbiAgICByb290LFxuICAgIGtleSxcbiAgICB0YXJnZXRcbiAgfTtcbn1cblxuLy8gQ2hlY2tzIGlmIGEgZGFzaC1jYXNlZCBzdHJpbmcgZW5kcyB3aXRoIGFuIGludGVnZXJcbmNvbnN0IElOREVYX1JFR0VYID0gLy1cXGQrJC87XG5mdW5jdGlvbiBhdHRhY2gocGFyZW50LCBjaGlsZCkge1xuICBpZiAoaXMuc3RyKGNoaWxkLnByb3BzLmF0dGFjaCkpIHtcbiAgICAvLyBJZiBhdHRhY2hpbmcgaW50byBhbiBhcnJheSAoZm9vLTApLCBjcmVhdGUgb25lXG4gICAgaWYgKElOREVYX1JFR0VYLnRlc3QoY2hpbGQucHJvcHMuYXR0YWNoKSkge1xuICAgICAgY29uc3QgaW5kZXggPSBjaGlsZC5wcm9wcy5hdHRhY2gucmVwbGFjZShJTkRFWF9SRUdFWCwgJycpO1xuICAgICAgY29uc3Qge1xuICAgICAgICByb290LFxuICAgICAgICBrZXlcbiAgICAgIH0gPSByZXNvbHZlKHBhcmVudC5vYmplY3QsIGluZGV4KTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyb290W2tleV0pKSByb290W2tleV0gPSBbXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcm9vdCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKHBhcmVudC5vYmplY3QsIGNoaWxkLnByb3BzLmF0dGFjaCk7XG4gICAgY2hpbGQucHJldmlvdXNBdHRhY2ggPSByb290W2tleV07XG4gICAgcm9vdFtrZXldID0gY2hpbGQub2JqZWN0O1xuICB9IGVsc2UgaWYgKGlzLmZ1bihjaGlsZC5wcm9wcy5hdHRhY2gpKSB7XG4gICAgY2hpbGQucHJldmlvdXNBdHRhY2ggPSBjaGlsZC5wcm9wcy5hdHRhY2gocGFyZW50Lm9iamVjdCwgY2hpbGQub2JqZWN0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGV0YWNoKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKGlzLnN0cihjaGlsZC5wcm9wcy5hdHRhY2gpKSB7XG4gICAgY29uc3Qge1xuICAgICAgcm9vdCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKHBhcmVudC5vYmplY3QsIGNoaWxkLnByb3BzLmF0dGFjaCk7XG4gICAgY29uc3QgcHJldmlvdXMgPSBjaGlsZC5wcmV2aW91c0F0dGFjaDtcbiAgICAvLyBXaGVuIHRoZSBwcmV2aW91cyB2YWx1ZSB3YXMgdW5kZWZpbmVkLCBpdCBtZWFucyB0aGUgdmFsdWUgd2FzIG5ldmVyIHNldCB0byBiZWdpbiB3aXRoXG4gICAgaWYgKHByZXZpb3VzID09PSB1bmRlZmluZWQpIGRlbGV0ZSByb290W2tleV07XG4gICAgLy8gT3RoZXJ3aXNlIHNldCB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICBlbHNlIHJvb3Rba2V5XSA9IHByZXZpb3VzO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkLnByZXZpb3VzQXR0YWNoID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZC5wcmV2aW91c0F0dGFjaChwYXJlbnQub2JqZWN0LCBjaGlsZC5vYmplY3QpO1xuICB9XG4gIGRlbGV0ZSBjaGlsZC5wcmV2aW91c0F0dGFjaDtcbn1cbmNvbnN0IFJFU0VSVkVEX1BST1BTID0gWy4uLlJFQUNUX0lOVEVSTkFMX1BST1BTLFxuLy8gSW5zdGFuY2UgcHJvcHNcbidhcmdzJywgJ2Rpc3Bvc2UnLCAnYXR0YWNoJywgJ29iamVjdCcsICdvblVwZGF0ZScsXG4vLyBCZWhhdmlvciBmbGFnc1xuJ2Rpc3Bvc2UnXTtcbmNvbnN0IE1FTU9JWkVEX1BST1RPVFlQRVMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRNZW1vaXplZFByb3RvdHlwZShyb290KSB7XG4gIGxldCBjdG9yID0gTUVNT0laRURfUFJPVE9UWVBFUy5nZXQocm9vdC5jb25zdHJ1Y3Rvcik7XG4gIHRyeSB7XG4gICAgaWYgKCFjdG9yKSB7XG4gICAgICBjdG9yID0gbmV3IHJvb3QuY29uc3RydWN0b3IoKTtcbiAgICAgIE1FTU9JWkVEX1BST1RPVFlQRVMuc2V0KHJvb3QuY29uc3RydWN0b3IsIGN0b3IpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIC4uLlxuICB9XG4gIHJldHVybiBjdG9yO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHByZXBhcmVzIGEgc2V0IG9mIGNoYW5nZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgaW5zdGFuY2VcbmZ1bmN0aW9uIGRpZmZQcm9wcyhpbnN0YW5jZSwgbmV3UHJvcHMpIHtcbiAgY29uc3QgY2hhbmdlZFByb3BzID0ge307XG5cbiAgLy8gU29ydCB0aHJvdWdoIHByb3BzXG4gIGZvciAoY29uc3QgcHJvcCBpbiBuZXdQcm9wcykge1xuICAgIC8vIFNraXAgcmVzZXJ2ZWQga2V5c1xuICAgIGlmIChSRVNFUlZFRF9QUk9QUy5pbmNsdWRlcyhwcm9wKSkgY29udGludWU7XG4gICAgLy8gU2tpcCBpZiBwcm9wcyBtYXRjaFxuICAgIGlmIChpcy5lcXUobmV3UHJvcHNbcHJvcF0sIGluc3RhbmNlLnByb3BzW3Byb3BdKSkgY29udGludWU7XG5cbiAgICAvLyBQcm9wcyBjaGFuZ2VkLCBhZGQgdGhlbVxuICAgIGNoYW5nZWRQcm9wc1twcm9wXSA9IG5ld1Byb3BzW3Byb3BdO1xuXG4gICAgLy8gUmVzZXQgcGllcmNlZCBwcm9wc1xuICAgIGZvciAoY29uc3Qgb3RoZXIgaW4gbmV3UHJvcHMpIHtcbiAgICAgIGlmIChvdGhlci5zdGFydHNXaXRoKGAke3Byb3B9LWApKSBjaGFuZ2VkUHJvcHNbb3RoZXJdID0gbmV3UHJvcHNbb3RoZXJdO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlc2V0IHJlbW92ZWQgcHJvcHMgZm9yIEhNUlxuICBmb3IgKGNvbnN0IHByb3AgaW4gaW5zdGFuY2UucHJvcHMpIHtcbiAgICBpZiAoUkVTRVJWRURfUFJPUFMuaW5jbHVkZXMocHJvcCkgfHwgbmV3UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvb3QsXG4gICAgICBrZXlcbiAgICB9ID0gcmVzb2x2ZShpbnN0YW5jZS5vYmplY3QsIHByb3ApO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMjEyMDlcbiAgICAvLyBITVIvZmFzdC1yZWZyZXNoIHJlbGllcyBvbiB0aGUgYWJpbGl0eSB0byBjYW5jZWwgb3V0IHByb3BzLCBidXQgdGhyZWVqc1xuICAgIC8vIGhhcyBubyBtZWFucyB0byBkbyB0aGlzLiBIZW5jZSB3ZSBjdXJhdGUgYSBzbWFsbCBjb2xsZWN0aW9uIG9mIHZhbHVlLWNsYXNzZXNcbiAgICAvLyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUgY29uc3RydWN0b3Ivc2V0IGFyZ3VtZW50c1xuICAgIC8vIEZvciByZW1vdmVkIHByb3BzLCB0cnkgdG8gc2V0IGRlZmF1bHQgdmFsdWVzLCBpZiBwb3NzaWJsZVxuICAgIGlmIChyb290LmNvbnN0cnVjdG9yICYmIHJvb3QuY29uc3RydWN0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBjcmVhdGUgYSBibGFuayBzbGF0ZSBvZiB0aGUgaW5zdGFuY2UgYW5kIGNvcHkgdGhlIHBhcnRpY3VsYXIgcGFyYW1ldGVyLlxuICAgICAgY29uc3QgY3RvciA9IGdldE1lbW9pemVkUHJvdG90eXBlKHJvb3QpO1xuICAgICAgaWYgKCFpcy51bmQoY3RvcikpIGNoYW5nZWRQcm9wc1trZXldID0gY3RvcltrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIGNvbnN0cnVjdG9yLCBqdXN0IHNldCBpdCB0byAwXG4gICAgICBjaGFuZ2VkUHJvcHNba2V5XSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGFuZ2VkUHJvcHM7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNzA0MlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIyNzQ4XG5jb25zdCBjb2xvck1hcHMgPSBbJ21hcCcsICdlbWlzc2l2ZU1hcCcsICdzaGVlbkNvbG9yTWFwJywgJ3NwZWN1bGFyQ29sb3JNYXAnLCAnZW52TWFwJ107XG5jb25zdCBFVkVOVF9SRUdFWCA9IC9eb24oUG9pbnRlcnxDbGlja3xEb3VibGVDbGlja3xDb250ZXh0TWVudXxXaGVlbCkvO1xuLy8gVGhpcyBmdW5jdGlvbiBhcHBsaWVzIGEgc2V0IG9mIGNoYW5nZXMgdG8gdGhlIGluc3RhbmNlXG5mdW5jdGlvbiBhcHBseVByb3BzKG9iamVjdCwgcHJvcHMpIHtcbiAgdmFyIF9pbnN0YW5jZSRvYmplY3Q7XG4gIGNvbnN0IGluc3RhbmNlID0gb2JqZWN0Ll9fcjNmO1xuICBjb25zdCByb290U3RhdGUgPSBpbnN0YW5jZSAmJiBmaW5kSW5pdGlhbFJvb3QoaW5zdGFuY2UpLmdldFN0YXRlKCk7XG4gIGNvbnN0IHByZXZIYW5kbGVycyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5ldmVudENvdW50O1xuICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICBsZXQgdmFsdWUgPSBwcm9wc1twcm9wXTtcblxuICAgIC8vIERvbid0IG11dGF0ZSByZXNlcnZlZCBrZXlzXG4gICAgaWYgKFJFU0VSVkVEX1BST1BTLmluY2x1ZGVzKHByb3ApKSBjb250aW51ZTtcblxuICAgIC8vIERlYWwgd2l0aCBwb2ludGVyIGV2ZW50cywgaW5jbHVkaW5nIHJlbW92aW5nIHRoZW0gaWYgdW5kZWZpbmVkXG4gICAgaWYgKGluc3RhbmNlICYmIEVWRU5UX1JFR0VYLnRlc3QocHJvcCkpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIGluc3RhbmNlLmhhbmRsZXJzW3Byb3BdID0gdmFsdWU7ZWxzZSBkZWxldGUgaW5zdGFuY2UuaGFuZGxlcnNbcHJvcF07XG4gICAgICBpbnN0YW5jZS5ldmVudENvdW50ID0gT2JqZWN0LmtleXMoaW5zdGFuY2UuaGFuZGxlcnMpLmxlbmd0aDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIElnbm9yZSBzZXR0aW5nIHVuZGVmaW5lZCBwcm9wc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzI3NFxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICBsZXQge1xuICAgICAgcm9vdCxcbiAgICAgIGtleSxcbiAgICAgIHRhcmdldFxuICAgIH0gPSByZXNvbHZlKG9iamVjdCwgcHJvcCk7XG5cbiAgICAvLyBMYXllcnMgbXVzdCBiZSB3cml0dGVuIHRvIHRoZSBtYXNrIHByb3BlcnR5XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLkxheWVycyAmJiB2YWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkxheWVycykge1xuICAgICAgdGFyZ2V0Lm1hc2sgPSB2YWx1ZS5tYXNrO1xuICAgIH1cbiAgICAvLyBTZXQgY29sb3JzIGlmIHZhbGlkIGNvbG9yIHJlcHJlc2VudGF0aW9uIGZvciBhdXRvbWF0aWMgY29udmVyc2lvbiAoY29weSlcbiAgICBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciAmJiBpc0NvbG9yUmVwcmVzZW50YXRpb24odmFsdWUpKSB7XG4gICAgICB0YXJnZXQuc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgLy8gQ29weSBpZiBwcm9wZXJ0aWVzIG1hdGNoIHNpZ25hdHVyZXMgYW5kIGltcGxlbWVudCBtYXRoIGludGVyZmFjZSAobGlrZWx5IHJlYWQtb25seSlcbiAgICBlbHNlIGlmICh0YXJnZXQgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRhcmdldC5zZXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHRhcmdldC5jb3B5ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSB2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgdGFyZ2V0LmNvcHkodmFsdWUpO1xuICAgIH1cbiAgICAvLyBTZXQgYXJyYXkgdHlwZXNcbiAgICBlbHNlIGlmICh0YXJnZXQgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRhcmdldC5zZXQgPT09ICdmdW5jdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0LmZyb21BcnJheSA9PT0gJ2Z1bmN0aW9uJykgdGFyZ2V0LmZyb21BcnJheSh2YWx1ZSk7ZWxzZSB0YXJnZXQuc2V0KC4uLnZhbHVlKTtcbiAgICB9XG4gICAgLy8gU2V0IGxpdGVyYWwgdHlwZXNcbiAgICBlbHNlIGlmICh0YXJnZXQgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRhcmdldC5zZXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gQWxsb3cgc2V0dGluZyBhcnJheSBzY2FsYXJzXG4gICAgICBpZiAodHlwZW9mIHRhcmdldC5zZXRTY2FsYXIgPT09ICdmdW5jdGlvbicpIHRhcmdldC5zZXRTY2FsYXIodmFsdWUpO1xuICAgICAgLy8gT3RoZXJ3aXNlIGp1c3Qgc2V0IHNpbmdsZSB2YWx1ZVxuICAgICAgZWxzZSB0YXJnZXQuc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgLy8gRWxzZSwganVzdCBvdmVyd3JpdGUgdGhlIHZhbHVlXG4gICAgZWxzZSB7XG4gICAgICB2YXIgX3Jvb3Qka2V5O1xuICAgICAgcm9vdFtrZXldID0gdmFsdWU7XG5cbiAgICAgIC8vIEF1dG8tY29udmVydCBzUkdCIHRleHR1cmUgcGFyYW1ldGVycyBmb3IgYnVpbHQtaW4gbWF0ZXJpYWxzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8zNDRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNTg1N1xuICAgICAgaWYgKHJvb3RTdGF0ZSAmJiAhcm9vdFN0YXRlLmxpbmVhciAmJiBjb2xvck1hcHMuaW5jbHVkZXMoa2V5KSAmJiAoX3Jvb3Qka2V5ID0gcm9vdFtrZXldKSAhPSBudWxsICYmIF9yb290JGtleS5pc1RleHR1cmUgJiZcbiAgICAgIC8vIHNSR0IgdGV4dHVyZXMgbXVzdCBiZSBSR0JBOCBzaW5jZSByMTM3IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMzEyOVxuICAgICAgcm9vdFtrZXldLmZvcm1hdCA9PT0gVEhSRUUuUkdCQUZvcm1hdCAmJiByb290W2tleV0udHlwZSA9PT0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZSkge1xuICAgICAgICAvLyBOT1RFOiB0aGlzIGNhbm5vdCBiZSBzZXQgZnJvbSB0aGUgcmVuZGVyZXIgKGUuZy4gc1JHQiBzb3VyY2UgdGV4dHVyZXMgcmVuZGVyZWQgdG8gUDMpXG4gICAgICAgIHJvb3Rba2V5XS5jb2xvclNwYWNlID0gVEhSRUUuU1JHQkNvbG9yU3BhY2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGluc3RhbmNlICE9IG51bGwgJiYgaW5zdGFuY2UucGFyZW50ICYmIHJvb3RTdGF0ZSAhPSBudWxsICYmIHJvb3RTdGF0ZS5pbnRlcm5hbCAmJiAoX2luc3RhbmNlJG9iamVjdCA9IGluc3RhbmNlLm9iamVjdCkgIT0gbnVsbCAmJiBfaW5zdGFuY2Ukb2JqZWN0LmlzT2JqZWN0M0QgJiYgcHJldkhhbmRsZXJzICE9PSBpbnN0YW5jZS5ldmVudENvdW50KSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gaW5zdGFuY2Uub2JqZWN0O1xuICAgIC8vIFByZS1lbXB0aXZlbHkgcmVtb3ZlIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBpbnRlcmFjdGlvbiBtYW5hZ2VyXG4gICAgY29uc3QgaW5kZXggPSByb290U3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24uaW5kZXhPZihvYmplY3QpO1xuICAgIGlmIChpbmRleCA+IC0xKSByb290U3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAvLyBBZGQgdGhlIGluc3RhbmNlIHRvIHRoZSBpbnRlcmFjdGlvbiBtYW5hZ2VyIG9ubHkgd2hlbiBpdCBoYXMgaGFuZGxlcnNcbiAgICBpZiAoaW5zdGFuY2UuZXZlbnRDb3VudCAmJiBvYmplY3QucmF5Y2FzdCAhPT0gbnVsbCkge1xuICAgICAgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnB1c2gob2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICAvLyBBdXRvLWF0dGFjaCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLnByb3BzLmF0dGFjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGluc3RhbmNlLm9iamVjdC5pc0J1ZmZlckdlb21ldHJ5KSBpbnN0YW5jZS5wcm9wcy5hdHRhY2ggPSAnZ2VvbWV0cnknO2Vsc2UgaWYgKGluc3RhbmNlLm9iamVjdC5pc01hdGVyaWFsKSBpbnN0YW5jZS5wcm9wcy5hdHRhY2ggPSAnbWF0ZXJpYWwnO1xuICB9XG5cbiAgLy8gSW5zdGFuY2Ugd2FzIHVwZGF0ZWQsIHJlcXVlc3QgYSBmcmFtZVxuICBpZiAoaW5zdGFuY2UpIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgdmFyIF9pbnN0YW5jZSRyb290O1xuICBpZiAoIWluc3RhbmNlLnBhcmVudCkgcmV0dXJuO1xuICBpbnN0YW5jZS5wcm9wcy5vblVwZGF0ZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UucHJvcHMub25VcGRhdGUoaW5zdGFuY2Uub2JqZWN0KTtcbiAgY29uc3Qgc3RhdGUgPSAoX2luc3RhbmNlJHJvb3QgPSBpbnN0YW5jZS5yb290KSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJHJvb3QuZ2V0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRyb290LmdldFN0YXRlKCk7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPT09IDApIHN0YXRlLmludmFsaWRhdGUoKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpIHtcbiAgLy8gRG8gbm90IG1lc3Mgd2l0aCB0aGUgY2FtZXJhIGlmIGl0IGJlbG9uZ3MgdG8gdGhlIHVzZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvOTJcbiAgaWYgKGNhbWVyYS5tYW51YWwpIHJldHVybjtcbiAgaWYgKGlzT3J0aG9ncmFwaGljQ2FtZXJhKGNhbWVyYSkpIHtcbiAgICBjYW1lcmEubGVmdCA9IHNpemUud2lkdGggLyAtMjtcbiAgICBjYW1lcmEucmlnaHQgPSBzaXplLndpZHRoIC8gMjtcbiAgICBjYW1lcmEudG9wID0gc2l6ZS5oZWlnaHQgLyAyO1xuICAgIGNhbWVyYS5ib3R0b20gPSBzaXplLmhlaWdodCAvIC0yO1xuICB9IGVsc2Uge1xuICAgIGNhbWVyYS5hc3BlY3QgPSBzaXplLndpZHRoIC8gc2l6ZS5oZWlnaHQ7XG4gIH1cbiAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbn1cbmNvbnN0IGlzT2JqZWN0M0QgPSBvYmplY3QgPT4gb2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBvYmplY3QuaXNPYmplY3QzRDtcblxuZnVuY3Rpb24gbWFrZUlkKGV2ZW50KSB7XG4gIHJldHVybiAoZXZlbnQuZXZlbnRPYmplY3QgfHwgZXZlbnQub2JqZWN0KS51dWlkICsgJy8nICsgZXZlbnQuaW5kZXggKyBldmVudC5pbnN0YW5jZUlkO1xufVxuXG4vKipcclxuICogUmVsZWFzZSBwb2ludGVyIGNhcHR1cmVzLlxyXG4gKiBUaGlzIGlzIGNhbGxlZCBieSByZWxlYXNlUG9pbnRlckNhcHR1cmUgaW4gdGhlIEFQSSwgYW5kIHdoZW4gYW4gb2JqZWN0IGlzIHJlbW92ZWQuXHJcbiAqL1xuZnVuY3Rpb24gcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoY2FwdHVyZWRNYXAsIG9iaiwgY2FwdHVyZXMsIHBvaW50ZXJJZCkge1xuICBjb25zdCBjYXB0dXJlRGF0YSA9IGNhcHR1cmVzLmdldChvYmopO1xuICBpZiAoY2FwdHVyZURhdGEpIHtcbiAgICBjYXB0dXJlcy5kZWxldGUob2JqKTtcbiAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBjYXB0dXJpbmcgb2JqZWN0IGZvciB0aGlzIHBvaW50ZXJcbiAgICBpZiAoY2FwdHVyZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgY2FwdHVyZWRNYXAuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICBjYXB0dXJlRGF0YS50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKHBvaW50ZXJJZCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZW1vdmVJbnRlcmFjdGl2aXR5KHN0b3JlLCBvYmplY3QpIHtcbiAgY29uc3Qge1xuICAgIGludGVybmFsXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAvLyBSZW1vdmVzIGV2ZXJ5IHRyYWNlIG9mIGFuIG9iamVjdCBmcm9tIHRoZSBkYXRhIHN0b3JlXG4gIGludGVybmFsLmludGVyYWN0aW9uID0gaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBpbnRlcm5hbC5pbml0aWFsSGl0cy5maWx0ZXIobyA9PiBvICE9PSBvYmplY3QpO1xuICBpbnRlcm5hbC5ob3ZlcmVkLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodmFsdWUuZXZlbnRPYmplY3QgPT09IG9iamVjdCB8fCB2YWx1ZS5vYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgaW50ZXJuYWwuaG92ZXJlZC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0pO1xuICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5mb3JFYWNoKChjYXB0dXJlcywgcG9pbnRlcklkKSA9PiB7XG4gICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIG9iamVjdCwgY2FwdHVyZXMsIHBvaW50ZXJJZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnRzKHN0b3JlKSB7XG4gIC8qKiBDYWxjdWxhdGVzIGRlbHRhICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkeCA9IGV2ZW50Lm9mZnNldFggLSBpbnRlcm5hbC5pbml0aWFsQ2xpY2tbMF07XG4gICAgY29uc3QgZHkgPSBldmVudC5vZmZzZXRZIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzFdO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbnN0YW5jZSBoYXMgYSB2YWxpZCBwb2ludGVyLWV2ZW50IHJlZ2lzdGVyZWQsIHRoaXMgZXhjbHVkZXMgc2Nyb2xsLCBjbGlja3MgZXRjICovXG4gIGZ1bmN0aW9uIGZpbHRlclBvaW50ZXJFdmVudHMob2JqZWN0cykge1xuICAgIHJldHVybiBvYmplY3RzLmZpbHRlcihvYmogPT4gWydNb3ZlJywgJ092ZXInLCAnRW50ZXInLCAnT3V0JywgJ0xlYXZlJ10uc29tZShuYW1lID0+IHtcbiAgICAgIHZhciBfcjNmO1xuICAgICAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5oYW5kbGVyc1snb25Qb2ludGVyJyArIG5hbWVdO1xuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcikge1xuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkdXBsaWNhdGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAvLyBBbGxvdyBjYWxsZXJzIHRvIGVsaW1pbmF0ZSBldmVudCBvYmplY3RzXG4gICAgY29uc3QgZXZlbnRzT2JqZWN0cyA9IGZpbHRlciA/IGZpbHRlcihzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbikgOiBzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbjtcbiAgICAvLyBSZXNldCBhbGwgcmF5Y2FzdGVyIGNhbWVyYXMgdG8gdW5kZWZpbmVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHNPYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShldmVudHNPYmplY3RzW2ldKTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YXRlLnByZXZpb3VzUm9vdCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHJvb3QtbGV2ZWwgcG9pbnRlciBhbmQgcmF5IGFyZSBzZXQgdXBcbiAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSYXljYXN0KG9iaikge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUob2JqKTtcbiAgICAgIC8vIFNraXAgZXZlbnQgaGFuZGxpbmcgd2hlbiBub0V2ZW50cyBpcyBzZXQsIG9yIHdoZW4gdGhlIHJheWNhc3RlcnMgY2FtZXJhIGlzIG51bGxcbiAgICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmV2ZW50cy5lbmFibGVkIHx8IHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICAgICAgLy8gV2hlbiB0aGUgY2FtZXJhIGlzIHVuZGVmaW5lZCB3ZSBoYXZlIHRvIGNhbGwgdGhlIGV2ZW50IGxheWVycyB1cGRhdGUgZnVuY3Rpb25cbiAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRwcmV2aW91c1Jvb3Q7XG4gICAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUsIChfc3RhdGUkcHJldmlvdXNSb290ID0gc3RhdGUucHJldmlvdXNSb290KSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gSWYgdGhlIGNhbWVyYSBpcyBzdGlsbCB1bmRlZmluZWQgd2UgaGF2ZSB0byBza2lwIHRoaXMgbGF5ZXIgZW50aXJlbHlcbiAgICAgICAgaWYgKHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IHVuZGVmaW5lZCkgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVyc2VjdCBvYmplY3QgYnkgb2JqZWN0XG4gICAgICByZXR1cm4gc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA/IHN0YXRlLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3Qob2JqLCB0cnVlKSA6IFtdO1xuICAgIH1cblxuICAgIC8vIENvbGxlY3QgZXZlbnRzXG4gICAgbGV0IGhpdHMgPSBldmVudHNPYmplY3RzXG4gICAgLy8gSW50ZXJzZWN0IG9iamVjdHNcbiAgICAuZmxhdE1hcChoYW5kbGVSYXljYXN0KVxuICAgIC8vIFNvcnQgYnkgZXZlbnQgcHJpb3JpdHkgYW5kIGRpc3RhbmNlXG4gICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldFJvb3RTdGF0ZShhLm9iamVjdCk7XG4gICAgICBjb25zdCBiU3RhdGUgPSBnZXRSb290U3RhdGUoYi5vYmplY3QpO1xuICAgICAgaWYgKCFhU3RhdGUgfHwgIWJTdGF0ZSkgcmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgICAgcmV0dXJuIGJTdGF0ZS5ldmVudHMucHJpb3JpdHkgLSBhU3RhdGUuZXZlbnRzLnByaW9yaXR5IHx8IGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgIH0pXG4gICAgLy8gRmlsdGVyIG91dCBkdXBsaWNhdGVzXG4gICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGl0ZW0pO1xuICAgICAgaWYgKGR1cGxpY2F0ZXMuaGFzKGlkKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZHVwbGljYXRlcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xNjAzMVxuICAgIC8vIEFsbG93IGN1c3RvbSB1c2VybGFuZCBpbnRlcnNlY3Qgc29ydCBvcmRlciwgdGhpcyBsaWtlbHkgb25seSBtYWtlcyBzZW5zZSBvbiB0aGUgcm9vdCBmaWx0ZXJcbiAgICBpZiAoc3RhdGUuZXZlbnRzLmZpbHRlcikgaGl0cyA9IHN0YXRlLmV2ZW50cy5maWx0ZXIoaGl0cywgc3RhdGUpO1xuXG4gICAgLy8gQnViYmxlIHVwIHRoZSBldmVudHMsIGZpbmQgdGhlIGV2ZW50IHNvdXJjZSAoZXZlbnRPYmplY3QpXG4gICAgZm9yIChjb25zdCBoaXQgb2YgaGl0cykge1xuICAgICAgbGV0IGV2ZW50T2JqZWN0ID0gaGl0Lm9iamVjdDtcbiAgICAgIC8vIEJ1YmJsZSBldmVudCB1cFxuICAgICAgd2hpbGUgKGV2ZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBfcjNmMjtcbiAgICAgICAgaWYgKChfcjNmMiA9IGV2ZW50T2JqZWN0Ll9fcjNmKSAhPSBudWxsICYmIF9yM2YyLmV2ZW50Q291bnQpIGludGVyc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgLi4uaGl0LFxuICAgICAgICAgIGV2ZW50T2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudE9iamVjdCA9IGV2ZW50T2JqZWN0LnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaW50ZXJhY3Rpb24gaXMgY2FwdHVyZWQsIG1ha2UgYWxsIGNhcHR1cmluZyB0YXJnZXRzIHBhcnQgb2YgdGhlIGludGVyc2VjdC5cbiAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgc3RhdGUuaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgIGZvciAobGV0IGNhcHR1cmVEYXRhIG9mIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICghZHVwbGljYXRlcy5oYXMobWFrZUlkKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbikpKSBpbnRlcnNlY3Rpb25zLnB1c2goY2FwdHVyZURhdGEuaW50ZXJzZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICAvKiogIEhhbmRsZXMgaW50ZXJzZWN0aW9ucyBieSBmb3J3YXJkaW5nIHRoZW0gdG8gaGFuZGxlcnMgKi9cbiAgZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0cyhpbnRlcnNlY3Rpb25zLCBldmVudCwgZGVsdGEsIGNhbGxiYWNrKSB7XG4gICAgLy8gSWYgYW55dGhpbmcgaGFzIGJlZW4gZm91bmQsIGZvcndhcmQgaXQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHtcbiAgICAgICAgc3RvcHBlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGhpdCBvZiBpbnRlcnNlY3Rpb25zKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShoaXQub2JqZWN0KTtcblxuICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGlzIG5vdCBtYW5hZ2VkIGJ5IFIzRiwgaXQgbWlnaHQgYmUgcGFyZW50ZWQgdG8gYW4gZWxlbWVudCB3aGljaCBpcy5cbiAgICAgICAgLy8gVHJhdmVyc2UgdXB3YXJkcyB1bnRpbCB3ZSBmaW5kIGEgbWFuYWdlZCBwYXJlbnQgYW5kIHVzZSBpdHMgc3RhdGUgaW5zdGVhZC5cbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgIGhpdC5vYmplY3QudHJhdmVyc2VBbmNlc3RvcnMob2JqID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFN0YXRlID0gZ2V0Um9vdFN0YXRlKG9iaik7XG4gICAgICAgICAgICBpZiAocGFyZW50U3RhdGUpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBwYXJlbnRTdGF0ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHJheWNhc3RlcixcbiAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICBjYW1lcmEsXG4gICAgICAgICAgICBpbnRlcm5hbFxuICAgICAgICAgIH0gPSBzdGF0ZTtcbiAgICAgICAgICBjb25zdCB1bnByb2plY3RlZFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMocG9pbnRlci54LCBwb2ludGVyLnksIDApLnVucHJvamVjdChjYW1lcmEpO1xuICAgICAgICAgIGNvbnN0IGhhc1BvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgICAgdmFyIF9pbnRlcm5hbCRjYXB0dXJlZE1hcCwgX2ludGVybmFsJGNhcHR1cmVkTWFwMjtcbiAgICAgICAgICAgIHJldHVybiAoX2ludGVybmFsJGNhcHR1cmVkTWFwID0gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2ludGVybmFsJGNhcHR1cmVkTWFwMi5oYXMoaGl0LmV2ZW50T2JqZWN0KSkgIT0gbnVsbCA/IF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA6IGZhbHNlO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3Qgc2V0UG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlRGF0YSA9IHtcbiAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uOiBoaXQsXG4gICAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50ZXJJZCB3YXMgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgYWRkIHRoZSBoaXQgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGV2ZW50IGNhcHR1cmVkTWFwLlxuICAgICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpLnNldChoaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVEYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludGVySWQgd2FzIG5vdCBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBjcmVhdGUgYSBtYXBcbiAgICAgICAgICAgICAgLy8gY29udGFpbmluZyB0aGUgaGl0T2JqZWN0LCBhbmQgdGhlIGhpdC4gaGl0T2JqZWN0IGlzIHVzZWQgZm9yXG4gICAgICAgICAgICAgIC8vIGZhc3RlciBhY2Nlc3MuXG4gICAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLnNldChpZCwgbmV3IE1hcChbW2hpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGFdXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGlkKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHJlbGVhc2VQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVzID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICAgICAgICByZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZShpbnRlcm5hbC5jYXB0dXJlZE1hcCwgaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlcywgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBBZGQgbmF0aXZlIGV2ZW50IHByb3BzXG4gICAgICAgICAgbGV0IGV4dHJhY3RFdmVudFByb3BzID0ge307XG4gICAgICAgICAgLy8gVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBldmVudCdzIHByb3BlcnRpZXMgaW5jbHVkaW5nIHRoZSBpbmhlcml0ZWQgb25lcy4gTmF0aXZlIFBvaW50ZXJFdmVudHMgaGF2ZSBtb3N0IG9mIHRoZWlyIHByb3BzIGFzIGdldHRlcnMgd2hpY2ggYXJlIGluaGVyaXRlZCwgYnV0IHBvbHlmaWxsZWQgUG9pbnRlckV2ZW50cyBoYXZlIHRoZW0gYWxsIGFzIHRoZWlyIG93biBwcm9wZXJ0aWVzIChpLmUuIG5vdCBpbmhlcml0ZWQpLiBXZSBjYW4ndCB1c2UgT2JqZWN0LmtleXMoKSBvciBPYmplY3QuZW50cmllcygpIGFzIHRoZXkgb25seSByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzOyBub3IgT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSBhcyB0aGF0ICpkb2Vzbid0KiByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzLCBvbmx5IGluaGVyaXRlZCBvbmVzLlxuICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGV2ZW50W3Byb3BdO1xuICAgICAgICAgICAgLy8gT25seSBjb3B5IG92ZXIgYXRvbWljcywgbGVhdmUgZnVuY3Rpb25zIGFsb25lIGFzIHRoZXNlIHNob3VsZCBiZVxuICAgICAgICAgICAgLy8gY2FsbGVkIGFzIGV2ZW50Lm5hdGl2ZUV2ZW50LmZuKClcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdmdW5jdGlvbicpIGV4dHJhY3RFdmVudFByb3BzW3Byb3BdID0gcHJvcGVydHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByYXljYXN0RXZlbnQgPSB7XG4gICAgICAgICAgICAuLi5oaXQsXG4gICAgICAgICAgICAuLi5leHRyYWN0RXZlbnRQcm9wcyxcbiAgICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zLFxuICAgICAgICAgICAgc3RvcHBlZDogbG9jYWxTdGF0ZS5zdG9wcGVkLFxuICAgICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgICB1bnByb2plY3RlZFBvaW50LFxuICAgICAgICAgICAgcmF5OiByYXljYXN0ZXIucmF5LFxuICAgICAgICAgICAgY2FtZXJhOiBjYW1lcmEsXG4gICAgICAgICAgICAvLyBIaWphY2sgc3RvcFByb3BhZ2F0aW9uLCB3aGljaCBqdXN0IHNldHMgYSBmbGFnXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzU5NlxuICAgICAgICAgICAgICAvLyBFdmVudHMgYXJlIG5vdCBhbGxvd2VkIHRvIHN0b3AgcHJvcGFnYXRpb24gaWYgdGhlIHBvaW50ZXIgaGFzIGJlZW4gY2FwdHVyZWRcbiAgICAgICAgICAgICAgY29uc3QgY2FwdHVyZXNGb3JQb2ludGVyID0gJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGV2ZW50LnBvaW50ZXJJZCk7XG5cbiAgICAgICAgICAgICAgLy8gV2Ugb25seSBhdXRob3JpemUgc3RvcFByb3BhZ2F0aW9uLi4uXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgLy8gLi4uaWYgdGhpcyBwb2ludGVyIGhhc24ndCBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgICAgICFjYXB0dXJlc0ZvclBvaW50ZXIgfHxcbiAgICAgICAgICAgICAgLy8gLi4uIG9yIGlmIHRoZSBoaXQgb2JqZWN0IGlzIGNhcHR1cmluZyB0aGUgcG9pbnRlclxuICAgICAgICAgICAgICBjYXB0dXJlc0ZvclBvaW50ZXIuaGFzKGhpdC5ldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByYXljYXN0RXZlbnQuc3RvcHBlZCA9IGxvY2FsU3RhdGUuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUHJvcGFnYXRpb24gaXMgc3RvcHBlZCwgcmVtb3ZlIGFsbCBvdGhlciBob3ZlciByZWNvcmRzXG4gICAgICAgICAgICAgICAgLy8gQW4gZXZlbnQgaGFuZGxlciBpcyBvbmx5IGFsbG93ZWQgdG8gZmx1c2ggb3RoZXIgaGFuZGxlcnMgaWYgaXQgaXMgaG92ZXJlZCBpdHNlbGZcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWwuaG92ZXJlZC5zaXplICYmIEFycmF5LmZyb20oaW50ZXJuYWwuaG92ZXJlZC52YWx1ZXMoKSkuZmluZChpID0+IGkuZXZlbnRPYmplY3QgPT09IGhpdC5ldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE9iamVjdHMgY2Fubm90IGZsdXNoIG91dCBoaWdoZXIgdXAgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBjYXVnaHQgdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgICBjb25zdCBoaWdoZXIgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDAsIGludGVyc2VjdGlvbnMuaW5kZXhPZihoaXQpKTtcbiAgICAgICAgICAgICAgICAgIGNhbmNlbFBvaW50ZXIoWy4uLmhpZ2hlciwgaGl0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gdGhlcmUgc2hvdWxkIGJlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB0YXJnZXQgYW5kIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICBoYXNQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHtcbiAgICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICAgIHNldFBvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gQ2FsbCBzdWJzY3JpYmVyc1xuICAgICAgICAgIGNhbGxiYWNrKHJheWNhc3RFdmVudCk7XG4gICAgICAgICAgLy8gRXZlbnQgYnViYmxpbmcgbWF5IGJlIGludGVycnVwdGVkIGJ5IHN0b3BQcm9wYWdhdGlvblxuICAgICAgICAgIGlmIChsb2NhbFN0YXRlLnN0b3BwZWQgPT09IHRydWUpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbFBvaW50ZXIoaW50ZXJzZWN0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgZm9yIChjb25zdCBob3ZlcmVkT2JqIG9mIGludGVybmFsLmhvdmVyZWQudmFsdWVzKCkpIHtcbiAgICAgIC8vIFdoZW4gbm8gb2JqZWN0cyB3ZXJlIGhpdCBvciB0aGUgdGhlIGhvdmVyZWQgb2JqZWN0IHdhc24ndCBmb3VuZCB1bmRlcm5lYXRoIHRoZSBjdXJzb3JcbiAgICAgIC8vIHdlIGNhbGwgb25Qb2ludGVyT3V0IGFuZCBkZWxldGUgdGhlIG9iamVjdCBmcm9tIHRoZSBob3ZlcmVkLWVsZW1lbnRzIG1hcFxuICAgICAgaWYgKCFpbnRlcnNlY3Rpb25zLmxlbmd0aCB8fCAhaW50ZXJzZWN0aW9ucy5maW5kKGhpdCA9PiBoaXQub2JqZWN0ID09PSBob3ZlcmVkT2JqLm9iamVjdCAmJiBoaXQuaW5kZXggPT09IGhvdmVyZWRPYmouaW5kZXggJiYgaGl0Lmluc3RhbmNlSWQgPT09IGhvdmVyZWRPYmouaW5zdGFuY2VJZCkpIHtcbiAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBob3ZlcmVkT2JqLmV2ZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGV2ZW50T2JqZWN0Ll9fcjNmO1xuICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLmRlbGV0ZShtYWtlSWQoaG92ZXJlZE9iaikpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5ldmVudENvdW50KSB7XG4gICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZS5oYW5kbGVycztcbiAgICAgICAgICAvLyBDbGVhciBvdXQgaW50ZXJzZWN0cywgdGhleSBhcmUgb3V0ZGF0ZWQgYnkgbm93XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmhvdmVyZWRPYmosXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdXQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck91dChkYXRhKTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyTGVhdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlck1pc3NlZChldmVudCwgb2JqZWN0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3RzW2ldLl9fcjNmO1xuICAgICAgaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZCA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnMub25Qb2ludGVyTWlzc2VkKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlcihuYW1lKSB7XG4gICAgLy8gRGVhbCB3aXRoIGNhbmNlbGF0aW9uXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdvblBvaW50ZXJMZWF2ZSc6XG4gICAgICBjYXNlICdvblBvaW50ZXJDYW5jZWwnOlxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICBjYXNlICdvbkxvc3RQb2ludGVyQ2FwdHVyZSc6XG4gICAgICAgIHJldHVybiBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgZXZlbnQgaW50ZXJmYWNlIGhhZCBvbkxvc3RQb2ludGVyQ2FwdHVyZSwgd2UnZCBjYWxsIGl0IGhlcmUgb24gZXZlcnlcbiAgICAgICAgICAgIC8vIG9iamVjdCB0aGF0J3MgZ2V0dGluZyByZW1vdmVkLiBXZSBjYWxsIGl0IG9uIHRoZSBuZXh0IGZyYW1lIGJlY2F1c2Ugb25Mb3N0UG9pbnRlckNhcHR1cmVcbiAgICAgICAgICAgIC8vIGZpcmVzIGJlZm9yZSBvblBvaW50ZXJVcC4gT3RoZXJ3aXNlIHBvaW50ZXJVcCB3b3VsZCBuZXZlciBiZSBjYWxsZWQgaWYgdGhlIGV2ZW50IGRpZG4ndFxuICAgICAgICAgICAgLy8gaGFwcGVuIGluIHRoZSBvYmplY3QgaXQgb3JpZ2luYXRlZCBmcm9tLCBsZWF2aW5nIGNvbXBvbmVudHMgaW4gYSBpbi1iZXR3ZWVuIHN0YXRlLlxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgLy8gT25seSByZWxlYXNlIGlmIHBvaW50ZXItdXAgZGlkbid0IGRvIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBbnkgb3RoZXIgcG9pbnRlciBnb2VzIGhlcmUgLi4uXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZCxcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBwcmVwYXJlUmF5KGV2ZW50KVxuICAgICAgaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQgPSBldmVudDtcblxuICAgICAgLy8gR2V0IGZyZXNoIGludGVyc2VjdHNcbiAgICAgIGNvbnN0IGlzUG9pbnRlck1vdmUgPSBuYW1lID09PSAnb25Qb2ludGVyTW92ZSc7XG4gICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBuYW1lID09PSAnb25DbGljaycgfHwgbmFtZSA9PT0gJ29uQ29udGV4dE1lbnUnIHx8IG5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJztcbiAgICAgIGNvbnN0IGZpbHRlciA9IGlzUG9pbnRlck1vdmUgPyBmaWx0ZXJQb2ludGVyRXZlbnRzIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaGl0cyA9IGludGVyc2VjdChldmVudCwgZmlsdGVyKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gaXNDbGlja0V2ZW50ID8gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIDogMDtcblxuICAgICAgLy8gU2F2ZSBpbml0aWFsIGNvb3JkaW5hdGVzIG9uIHBvaW50ZXItZG93blxuICAgICAgaWYgKG5hbWUgPT09ICdvblBvaW50ZXJEb3duJykge1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsQ2xpY2sgPSBbZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gICAgICAgIGludGVybmFsLmluaXRpYWxIaXRzID0gaGl0cy5tYXAoaGl0ID0+IGhpdC5ldmVudE9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgY2xpY2sgeWllbGRzIG5vIHJlc3VsdHMsIHBhc3MgaXQgYmFjayB0byB0aGUgdXNlciBhcyBhIG1pc3NcbiAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0IGluIG9yZGVyIHRvIGVzdGFibGlzaCB1c2VyLWxhbmQgc2lkZS1lZmZlY3QgY2xlYW4gdXBcbiAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgIWhpdHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkZWx0YSA8PSAyKSB7XG4gICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIGlmIChvblBvaW50ZXJNaXNzZWQpIG9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRha2UgY2FyZSBvZiB1bmhvdmVyXG4gICAgICBpZiAoaXNQb2ludGVyTW92ZSkgY2FuY2VsUG9pbnRlcihoaXRzKTtcbiAgICAgIGZ1bmN0aW9uIG9uSW50ZXJzZWN0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBkYXRhLmV2ZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGV2ZW50T2JqZWN0Ll9fcjNmO1xuXG4gICAgICAgIC8vIENoZWNrIHByZXNlbmNlIG9mIGhhbmRsZXJzXG4gICAgICAgIGlmICghKGluc3RhbmNlICE9IG51bGwgJiYgaW5zdGFuY2UuZXZlbnRDb3VudCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZS5oYW5kbGVycztcblxuICAgICAgICAvKlxyXG4gICAgICAgIE1BWUJFIFRPRE8sIERFTEVURSBJRiBOT1Q6IFxyXG4gICAgICAgICAgQ2hlY2sgaWYgdGhlIG9iamVjdCBpcyBjYXB0dXJlZCwgY2FwdHVyZWQgZXZlbnRzIHNob3VsZCBub3QgaGF2ZSBpbnRlcnNlY3RzIHJ1bm5pbmcgaW4gcGFyYWxsZWxcclxuICAgICAgICAgIEJ1dCB3b3VsZG4ndCBpdCBiZSBiZXR0ZXIgdG8ganVzdCByZXBsYWNlIGNhcHR1cmVkTWFwIHdpdGggYSBzaW5nbGUgZW50cnk/XHJcbiAgICAgICAgICBBbHNvLCBhcmUgd2UgT0sgd2l0aCBzdHJhaWdodCB1cCBtYWtpbmcgcGlja2luZyB1cCBtdWx0aXBsZSBvYmplY3RzIGltcG9zc2libGU/XHJcbiAgICAgICAgICBcclxuICAgICAgICBjb25zdCBwb2ludGVySWQgPSAoZGF0YSBhcyBUaHJlZUV2ZW50PFBvaW50ZXJFdmVudD4pLnBvaW50ZXJJZCAgICAgICAgXHJcbiAgICAgICAgaWYgKHBvaW50ZXJJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBjb25zdCBjYXB0dXJlZE1lc2hTZXQgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQocG9pbnRlcklkKVxyXG4gICAgICAgICAgaWYgKGNhcHR1cmVkTWVzaFNldCkge1xyXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlZCA9IGNhcHR1cmVkTWVzaFNldC5nZXQoZXZlbnRPYmplY3QpXHJcbiAgICAgICAgICAgIGlmIChjYXB0dXJlZCAmJiBjYXB0dXJlZC5sb2NhbFN0YXRlLnN0b3BwZWQpIHJldHVyblxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0qL1xuXG4gICAgICAgIGlmIChpc1BvaW50ZXJNb3ZlKSB7XG4gICAgICAgICAgLy8gTW92ZSBldmVudCAuLi5cbiAgICAgICAgICBpZiAoaGFuZGxlcnMub25Qb2ludGVyT3ZlciB8fCBoYW5kbGVycy5vblBvaW50ZXJFbnRlciB8fCBoYW5kbGVycy5vblBvaW50ZXJPdXQgfHwgaGFuZGxlcnMub25Qb2ludGVyTGVhdmUpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZW50ZXIgb3Igb3V0IGlzIHByZXNlbnQgdGFrZSBjYXJlIG9mIGhvdmVyLXN0YXRlXG4gICAgICAgICAgICBjb25zdCBpZCA9IG1ha2VJZChkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gaW50ZXJuYWwuaG92ZXJlZC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKCFob3ZlcmVkSXRlbSkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhc24ndCBwcmV2aW91c2x5IGhvdmVyZWQsIGJvb2sgaXQgYW5kIGNhbGwgaXRzIGhhbmRsZXJcbiAgICAgICAgICAgICAgaW50ZXJuYWwuaG92ZXJlZC5zZXQoaWQsIGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdmVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJPdmVyKGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJFbnRlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyRW50ZXIoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCB3YXMgcHJldmlvdXNseSBob3ZlcmVkIGFuZCBzdG9wcGVkLCB3ZSBzaG91bGRuJ3QgYWxsb3cgb3RoZXIgaXRlbXMgdG8gcHJvY2VlZFxuICAgICAgICAgICAgICBkYXRhLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG1vdXNlIG1vdmVcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJNb3ZlID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJNb3ZlKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFsbCBvdGhlciBldmVudHMgLi4uXG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW25hbWVdO1xuICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyBGb3J3YXJkIGFsbCBldmVudHMgYmFjayB0byB0aGVpciByZXNwZWN0aXZlIGhhbmRsZXJzIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBjbGljayBldmVudHMsXG4gICAgICAgICAgICAvLyB3aGljaCBtdXN0IHVzZSB0aGUgaW5pdGlhbCB0YXJnZXRcbiAgICAgICAgICAgIGlmICghaXNDbGlja0V2ZW50IHx8IGludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdFxuICAgICAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIob2JqZWN0ID0+ICFpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhvYmplY3QpKSk7XG4gICAgICAgICAgICAgIC8vIE5vdyBjYWxsIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICAgIGhhbmRsZXIoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgb25Qb2ludGVyTWlzc2VkIG9uIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgcG9pbnRlciBvdmVyL291dCBoYW5kbGVycywgYnV0IG5vdCBjbGljayBhbmQgd2VyZW4ndCBoaXRcbiAgICAgICAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhbmRsZUludGVyc2VjdHMoaGl0cywgZXZlbnQsIGRlbHRhLCBvbkludGVyc2VjdCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfTtcbn1cblxuY29uc3QgaXNSZW5kZXJlciA9IGRlZiA9PiAhIShkZWYgIT0gbnVsbCAmJiBkZWYucmVuZGVyKTtcbmNvbnN0IGNvbnRleHQgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoaW52YWxpZGF0ZSwgYWR2YW5jZSkgPT4ge1xuICBjb25zdCByb290U3RvcmUgPSBjcmVhdGVXaXRoRXF1YWxpdHlGbigoc2V0LCBnZXQpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgZGVmYXVsdFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgdGVtcFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSA9IGdldCgpLmNhbWVyYSwgdGFyZ2V0ID0gZGVmYXVsdFRhcmdldCwgc2l6ZSA9IGdldCgpLnNpemUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdG9wLFxuICAgICAgICBsZWZ0XG4gICAgICB9ID0gc2l6ZTtcbiAgICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgaWYgKHRhcmdldC5pc1ZlY3RvcjMpIHRlbXBUYXJnZXQuY29weSh0YXJnZXQpO2Vsc2UgdGVtcFRhcmdldC5zZXQoLi4udGFyZ2V0KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gY2FtZXJhLmdldFdvcmxkUG9zaXRpb24ocG9zaXRpb24pLmRpc3RhbmNlVG8odGVtcFRhcmdldCk7XG4gICAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC8gY2FtZXJhLnpvb20sXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgZmFjdG9yOiAxLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm92ID0gY2FtZXJhLmZvdiAqIE1hdGguUEkgLyAxODA7IC8vIGNvbnZlcnQgdmVydGljYWwgZm92IHRvIHJhZGlhbnNcbiAgICAgICAgY29uc3QgaCA9IDIgKiBNYXRoLnRhbihmb3YgLyAyKSAqIGRpc3RhbmNlOyAvLyB2aXNpYmxlIGhlaWdodFxuICAgICAgICBjb25zdCB3ID0gaCAqICh3aWR0aCAvIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3Rvcjogd2lkdGggLyB3LFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcGVyZm9ybWFuY2VUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNldFBlcmZvcm1hbmNlQ3VycmVudCA9IGN1cnJlbnQgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgY3VycmVudFxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBwb2ludGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICBjb25zdCByb290U3RhdGUgPSB7XG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBNb2NrIG9iamVjdHMgdGhhdCBoYXZlIHRvIGJlIGNvbmZpZ3VyZWRcbiAgICAgIGdsOiBudWxsLFxuICAgICAgY2FtZXJhOiBudWxsLFxuICAgICAgcmF5Y2FzdGVyOiBudWxsLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIHByaW9yaXR5OiAxLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc2NlbmU6IG51bGwsXG4gICAgICB4cjogbnVsbCxcbiAgICAgIGludmFsaWRhdGU6IChmcmFtZXMgPSAxKSA9PiBpbnZhbGlkYXRlKGdldCgpLCBmcmFtZXMpLFxuICAgICAgYWR2YW5jZTogKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cykgPT4gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMsIGdldCgpKSxcbiAgICAgIGxlZ2FjeTogZmFsc2UsXG4gICAgICBsaW5lYXI6IGZhbHNlLFxuICAgICAgZmxhdDogZmFsc2UsXG4gICAgICBjb250cm9sczogbnVsbCxcbiAgICAgIGNsb2NrOiBuZXcgVEhSRUUuQ2xvY2soKSxcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIGZyYW1lbG9vcDogJ2Fsd2F5cycsXG4gICAgICBvblBvaW50ZXJNaXNzZWQ6IHVuZGVmaW5lZCxcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIGN1cnJlbnQ6IDEsXG4gICAgICAgIG1pbjogMC41LFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIGRlYm91bmNlOiAyMDAsXG4gICAgICAgIHJlZ3Jlc3M6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXRcbiAgICAgICAgICBpZiAocGVyZm9ybWFuY2VUaW1lb3V0KSBjbGVhclRpbWVvdXQocGVyZm9ybWFuY2VUaW1lb3V0KTtcbiAgICAgICAgICAvLyBTZXQgbG93ZXIgYm91bmQgcGVyZm9ybWFuY2VcbiAgICAgICAgICBpZiAoc3RhdGUucGVyZm9ybWFuY2UuY3VycmVudCAhPT0gc3RhdGUucGVyZm9ybWFuY2UubWluKSBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoc3RhdGUucGVyZm9ybWFuY2UubWluKTtcbiAgICAgICAgICAvLyBHbyBiYWNrIHRvIHVwcGVyIGJvdW5kIHBlcmZvcm1hbmNlIGFmdGVyIGEgd2hpbGUgdW5sZXNzIHNvbWV0aGluZyByZWdyZXNzZXMgbWVhbndoaWxlXG4gICAgICAgICAgcGVyZm9ybWFuY2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoZ2V0KCkucGVyZm9ybWFuY2UubWF4KSwgc3RhdGUucGVyZm9ybWFuY2UuZGVib3VuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICBpbml0aWFsRHByOiAwLFxuICAgICAgICBkcHI6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYXNwZWN0OiAwLFxuICAgICAgICBkaXN0YW5jZTogMCxcbiAgICAgICAgZmFjdG9yOiAwLFxuICAgICAgICBnZXRDdXJyZW50Vmlld3BvcnRcbiAgICAgIH0sXG4gICAgICBzZXRFdmVudHM6IGV2ZW50cyA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSkpLFxuICAgICAgc2V0U2l6ZTogKHdpZHRoLCBoZWlnaHQsIHRvcCA9IDAsIGxlZnQgPSAwKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGdldCgpLmNhbWVyYTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnRcbiAgICAgICAgfTtcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICAuLi5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBkZWZhdWx0VGFyZ2V0LCBzaXplKVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHNldERwcjogZHByID0+IHNldChzdGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gY2FsY3VsYXRlRHByKGRwcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgZHByOiByZXNvbHZlZCxcbiAgICAgICAgICAgIGluaXRpYWxEcHI6IHN0YXRlLnZpZXdwb3J0LmluaXRpYWxEcHIgfHwgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHNldEZyYW1lbG9vcDogKGZyYW1lbG9vcCA9ICdhbHdheXMnKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb2NrID0gZ2V0KCkuY2xvY2s7XG5cbiAgICAgICAgLy8gaWYgZnJhbWVsb29wID09PSBcIm5ldmVyXCIgY2xvY2suZWxhcHNlZFRpbWUgaXMgdXBkYXRlZCB1c2luZyBhZHZhbmNlKHRpbWVzdGFtcClcbiAgICAgICAgY2xvY2suc3RvcCgpO1xuICAgICAgICBjbG9jay5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIGlmIChmcmFtZWxvb3AgIT09ICduZXZlcicpIHtcbiAgICAgICAgICBjbG9jay5zdGFydCgpO1xuICAgICAgICAgIGNsb2NrLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzZXQoKCkgPT4gKHtcbiAgICAgICAgICBmcmFtZWxvb3BcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHByZXZpb3VzUm9vdDogdW5kZWZpbmVkLFxuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgLy8gRXZlbnRzXG4gICAgICAgIGludGVyYWN0aW9uOiBbXSxcbiAgICAgICAgaG92ZXJlZDogbmV3IE1hcCgpLFxuICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgIGluaXRpYWxDbGljazogWzAsIDBdLFxuICAgICAgICBpbml0aWFsSGl0czogW10sXG4gICAgICAgIGNhcHR1cmVkTWFwOiBuZXcgTWFwKCksXG4gICAgICAgIGxhc3RFdmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpLFxuICAgICAgICAvLyBVcGRhdGVzXG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGZyYW1lczogMCxcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIHN1YnNjcmliZTogKHJlZiwgcHJpb3JpdHksIHN0b3JlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW50ZXJuYWwgPSBnZXQoKS5pbnRlcm5hbDtcbiAgICAgICAgICAvLyBJZiB0aGlzIHN1YnNjcmlwdGlvbiB3YXMgZ2l2ZW4gYSBwcmlvcml0eSwgaXQgdGFrZXMgcmVuZGVyaW5nIGludG8gaXRzIG93biBoYW5kc1xuICAgICAgICAgIC8vIEZvciB0aGF0IHJlYXNvbiB3ZSBzd2l0Y2ggb2ZmIGF1dG9tYXRpYyByZW5kZXJpbmcgYW5kIGluY3JlYXNlIHRoZSBtYW51YWwgZmxhZ1xuICAgICAgICAgIC8vIEFzIGxvbmcgYXMgdGhpcyBmbGFnIGlzIHBvc2l0aXZlIHRoZXJlIGNhbiBiZSBubyBpbnRlcm5hbCByZW5kZXJpbmcgYXQgYWxsXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSByZW5kZXIgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgIGludGVybmFsLnByaW9yaXR5ID0gaW50ZXJuYWwucHJpb3JpdHkgKyAocHJpb3JpdHkgPiAwID8gMSA6IDApO1xuICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzLnB1c2goe1xuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICBzdG9yZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFJlZ2lzdGVyIHN1YnNjcmliZXIgYW5kIHNvcnQgbGF5ZXJzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QsIG1lYW5pbmcsXG4gICAgICAgICAgLy8gaGlnaGVzdCBwcmlvcml0eSByZW5kZXJzIGxhc3QgKG9uIHRvcCBvZiB0aGUgb3RoZXIgZnJhbWVzKVxuICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzID0gaW50ZXJuYWwuc3Vic2NyaWJlcnMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGdldCgpLmludGVybmFsO1xuICAgICAgICAgICAgaWYgKGludGVybmFsICE9IG51bGwgJiYgaW50ZXJuYWwuc3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgICAgLy8gRGVjcmVhc2UgbWFudWFsIGZsYWcgaWYgdGhpcyBzdWJzY3JpcHRpb24gaGFkIGEgcHJpb3JpdHlcbiAgICAgICAgICAgICAgaW50ZXJuYWwucHJpb3JpdHkgPSBpbnRlcm5hbC5wcmlvcml0eSAtIChwcmlvcml0eSA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyIGZyb20gbGlzdFxuICAgICAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycyA9IGludGVybmFsLnN1YnNjcmliZXJzLmZpbHRlcihzID0+IHMucmVmICE9PSByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByb290U3RhdGU7XG4gIH0pO1xuICBjb25zdCBzdGF0ZSA9IHJvb3RTdG9yZS5nZXRTdGF0ZSgpO1xuICBsZXQgb2xkU2l6ZSA9IHN0YXRlLnNpemU7XG4gIGxldCBvbGREcHIgPSBzdGF0ZS52aWV3cG9ydC5kcHI7XG4gIGxldCBvbGRDYW1lcmEgPSBzdGF0ZS5jYW1lcmE7XG4gIHJvb3RTdG9yZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbWVyYSxcbiAgICAgIHNpemUsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGdsLFxuICAgICAgc2V0XG4gICAgfSA9IHJvb3RTdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgLy8gUmVzaXplIGNhbWVyYSBhbmQgcmVuZGVyZXIgb24gY2hhbmdlcyB0byBzaXplIGFuZCBwaXhlbHJhdGlvXG4gICAgaWYgKHNpemUud2lkdGggIT09IG9sZFNpemUud2lkdGggfHwgc2l6ZS5oZWlnaHQgIT09IG9sZFNpemUuaGVpZ2h0IHx8IHZpZXdwb3J0LmRwciAhPT0gb2xkRHByKSB7XG4gICAgICBvbGRTaXplID0gc2l6ZTtcbiAgICAgIG9sZERwciA9IHZpZXdwb3J0LmRwcjtcbiAgICAgIC8vIFVwZGF0ZSBjYW1lcmEgJiByZW5kZXJlclxuICAgICAgdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSk7XG4gICAgICBpZiAodmlld3BvcnQuZHByID4gMCkgZ2wuc2V0UGl4ZWxSYXRpbyh2aWV3cG9ydC5kcHIpO1xuICAgICAgY29uc3QgdXBkYXRlU3R5bGUgPSB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGdsLmRvbUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgIGdsLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHVwZGF0ZVN0eWxlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdmlld3BvcnQgb25jZSB0aGUgY2FtZXJhIGNoYW5nZXNcbiAgICBpZiAoY2FtZXJhICE9PSBvbGRDYW1lcmEpIHtcbiAgICAgIG9sZENhbWVyYSA9IGNhbWVyYTtcbiAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSlcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW52YWxpZGF0ZSBvbiBhbnkgY2hhbmdlXG4gIHJvb3RTdG9yZS5zdWJzY3JpYmUoc3RhdGUgPT4gaW52YWxpZGF0ZShzdGF0ZSkpO1xuXG4gIC8vIFJldHVybiByb290IHN0YXRlXG4gIHJldHVybiByb290U3RvcmU7XG59O1xuXG4vKipcclxuICogRXhwb3NlcyBhbiBvYmplY3QncyB7QGxpbmsgSW5zdGFuY2V9LlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjdXNlSW5zdGFuY2VIYW5kbGVcclxuICpcclxuICogKipOb3RlKio6IHRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIHRvIHJlYWN0LWludGVybmFsIGZpZWxkcy4gRXhwZWN0IHRoaXMgdG8gY2hhbmdlIHNpZ25pZmljYW50bHkgYmV0d2VlbiB2ZXJzaW9ucy5cclxuICovXG5mdW5jdGlvbiB1c2VJbnN0YW5jZUhhbmRsZShyZWYpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoaW5zdGFuY2UsICgpID0+IHJlZi5jdXJyZW50Ll9fcjNmLCBbcmVmXSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIFIzRiBDYW52YXMnIFp1c3RhbmQgc3RvcmUuIFVzZWZ1bCBmb3IgW3RyYW5zaWVudCB1cGRhdGVzXShodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3p1c3RhbmQjdHJhbnNpZW50LXVwZGF0ZXMtZm9yLW9mdGVuLW9jY3VycmluZy1zdGF0ZS1jaGFuZ2VzKS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlc3RvcmVcclxuICovXG5mdW5jdGlvbiB1c2VTdG9yZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICBpZiAoIXN0b3JlKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogSG9va3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlIENhbnZhcyBjb21wb25lbnQhJyk7XG4gIHJldHVybiBzdG9yZTtcbn1cblxuLyoqXHJcbiAqIEFjY2Vzc2VzIFIzRidzIGludGVybmFsIHN0YXRlLCBjb250YWluaW5nIHJlbmRlcmVyLCBjYW52YXMsIHNjZW5lLCBldGMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZXRocmVlXHJcbiAqL1xuZnVuY3Rpb24gdXNlVGhyZWUoc2VsZWN0b3IgPSBzdGF0ZSA9PiBzdGF0ZSwgZXF1YWxpdHlGbikge1xuICByZXR1cm4gdXNlU3RvcmUoKShzZWxlY3RvciwgZXF1YWxpdHlGbik7XG59XG5cbi8qKlxyXG4gKiBFeGVjdXRlcyBhIGNhbGxiYWNrIGJlZm9yZSByZW5kZXIgaW4gYSBzaGFyZWQgZnJhbWUgbG9vcC5cclxuICogQ2FuIG9yZGVyIGVmZmVjdHMgd2l0aCByZW5kZXIgcHJpb3JpdHkgb3IgbWFudWFsbHkgcmVuZGVyIHdpdGggYSBwb3NpdGl2ZSBwcmlvcml0eS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZnJhbWVcclxuICovXG5mdW5jdGlvbiB1c2VGcmFtZShjYWxsYmFjaywgcmVuZGVyUHJpb3JpdHkgPSAwKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gc3RvcmUuZ2V0U3RhdGUoKS5pbnRlcm5hbC5zdWJzY3JpYmU7XG4gIC8vIE1lbW9pemUgcmVmXG4gIGNvbnN0IHJlZiA9IHVzZU11dGFibGVDYWxsYmFjayhjYWxsYmFjayk7XG4gIC8vIFN1YnNjcmliZSBvbiBtb3VudCwgdW5zdWJzY3JpYmUgb24gdW5tb3VudFxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHN1YnNjcmliZShyZWYsIHJlbmRlclByaW9yaXR5LCBzdG9yZSksIFtyZW5kZXJQcmlvcml0eSwgc3Vic2NyaWJlLCBzdG9yZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGdyYXBoIG9mIGFuIG9iamVjdCB3aXRoIG5hbWVkIG5vZGVzICYgbWF0ZXJpYWxzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VncmFwaFxyXG4gKi9cbmZ1bmN0aW9uIHVzZUdyYXBoKG9iamVjdCkge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBidWlsZEdyYXBoKG9iamVjdCksIFtvYmplY3RdKTtcbn1cbmNvbnN0IG1lbW9pemVkTG9hZGVycyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBpc0NvbnN0cnVjdG9yJDEgPSB2YWx1ZSA9PiB7XG4gIHZhciBfdmFsdWUkcHJvdG90eXBlO1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmICh2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogKF92YWx1ZSRwcm90b3R5cGUgPSB2YWx1ZS5wcm90b3R5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfdmFsdWUkcHJvdG90eXBlLmNvbnN0cnVjdG9yKSA9PT0gdmFsdWU7XG59O1xuZnVuY3Rpb24gbG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChQcm90bywgLi4uaW5wdXQpIHtcbiAgICBsZXQgbG9hZGVyO1xuXG4gICAgLy8gQ29uc3RydWN0IGFuZCBjYWNoZSBsb2FkZXIgaWYgY29uc3RydWN0b3Igd2FzIHBhc3NlZFxuICAgIGlmIChpc0NvbnN0cnVjdG9yJDEoUHJvdG8pKSB7XG4gICAgICBsb2FkZXIgPSBtZW1vaXplZExvYWRlcnMuZ2V0KFByb3RvKTtcbiAgICAgIGlmICghbG9hZGVyKSB7XG4gICAgICAgIGxvYWRlciA9IG5ldyBQcm90bygpO1xuICAgICAgICBtZW1vaXplZExvYWRlcnMuc2V0KFByb3RvLCBsb2FkZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkZXIgPSBQcm90bztcbiAgICB9XG5cbiAgICAvLyBBcHBseSBsb2FkZXIgZXh0ZW5zaW9uc1xuICAgIGlmIChleHRlbnNpb25zKSBleHRlbnNpb25zKGxvYWRlcik7XG5cbiAgICAvLyBHbyB0aHJvdWdoIHRoZSB1cmxzIGFuZCBsb2FkIHRoZW1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoaW5wdXQubWFwKGlucHV0ID0+IG5ldyBQcm9taXNlKChyZXMsIHJlamVjdCkgPT4gbG9hZGVyLmxvYWQoaW5wdXQsIGRhdGEgPT4ge1xuICAgICAgaWYgKGlzT2JqZWN0M0QoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5zY2VuZSkpIE9iamVjdC5hc3NpZ24oZGF0YSwgYnVpbGRHcmFwaChkYXRhLnNjZW5lKSk7XG4gICAgICByZXMoZGF0YSk7XG4gICAgfSwgb25Qcm9ncmVzcywgZXJyb3IgPT4gcmVqZWN0KG5ldyBFcnJvcihgQ291bGQgbm90IGxvYWQgJHtpbnB1dH06ICR7ZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2V9YCkpKSkpKTtcbiAgfTtcbn1cblxuLyoqXHJcbiAqIFN5bmNocm9ub3VzbHkgbG9hZHMgYW5kIGNhY2hlcyBhc3NldHMgd2l0aCBhIHRocmVlIGxvYWRlci5cclxuICpcclxuICogTm90ZTogdGhpcyBob29rJ3MgY2FsbGVyIG11c3QgYmUgd3JhcHBlZCB3aXRoIGBSZWFjdC5TdXNwZW5zZWBcclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlbG9hZGVyXHJcbiAqL1xuZnVuY3Rpb24gdXNlTG9hZGVyKGxvYWRlciwgaW5wdXQsIGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgLy8gVXNlIHN1c3BlbnNlIHRvIGxvYWQgYXN5bmMgYXNzZXRzXG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgY29uc3QgcmVzdWx0cyA9IHN1c3BlbmQobG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpLCBbbG9hZGVyLCAuLi5rZXlzXSwge1xuICAgIGVxdWFsOiBpcy5lcXVcbiAgfSk7XG4gIC8vIFJldHVybiB0aGUgb2JqZWN0KHMpXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSA/IHJlc3VsdHMgOiByZXN1bHRzWzBdO1xufVxuXG4vKipcclxuICogUHJlbG9hZHMgYW4gYXNzZXQgaW50byBjYWNoZSBhcyBhIHNpZGUtZWZmZWN0LlxyXG4gKi9cbnVzZUxvYWRlci5wcmVsb2FkID0gZnVuY3Rpb24gKGxvYWRlciwgaW5wdXQsIGV4dGVuc2lvbnMpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICByZXR1cm4gcHJlbG9hZChsb2FkaW5nRm4oZXh0ZW5zaW9ucyksIFtsb2FkZXIsIC4uLmtleXNdKTtcbn07XG5cbi8qKlxyXG4gKiBSZW1vdmVzIGEgbG9hZGVkIGFzc2V0IGZyb20gY2FjaGUuXHJcbiAqL1xudXNlTG9hZGVyLmNsZWFyID0gZnVuY3Rpb24gKGxvYWRlciwgaW5wdXQpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICByZXR1cm4gY2xlYXIoW2xvYWRlciwgLi4ua2V5c10pO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlUmVjb25jaWxlcihjb25maWcpIHtcbiAgY29uc3QgcmVjb25jaWxlciA9IFJlY29uY2lsZXIoY29uZmlnKTtcbiAgcmVjb25jaWxlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICAgIGJ1bmRsZVR5cGU6IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gMSA6IDAsXG4gICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ0ByZWFjdC10aHJlZS9maWJlcicsXG4gICAgdmVyc2lvbjogUmVhY3QudmVyc2lvblxuICB9KTtcbiAgcmV0dXJuIHJlY29uY2lsZXI7XG59XG5jb25zdCBOb0V2ZW50UHJpb3JpdHkgPSAwO1xuXG4vLyBUT0RPOiBoYW5kbGUgY29uc3RydWN0b3Igb3ZlcmxvYWRzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjkzMVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zNzA3OVxuXG5jb25zdCBjYXRhbG9ndWUgPSB7fTtcbmNvbnN0IFBSRUZJWF9SRUdFWCA9IC9edGhyZWUoPz1bQS1aXSkvO1xuY29uc3QgdG9QYXNjYWxDYXNlID0gdHlwZSA9PiBgJHt0eXBlWzBdLnRvVXBwZXJDYXNlKCl9JHt0eXBlLnNsaWNlKDEpfWA7XG5sZXQgaSA9IDA7XG5jb25zdCBpc0NvbnN0cnVjdG9yID0gb2JqZWN0ID0+IHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG5mdW5jdGlvbiBleHRlbmQob2JqZWN0cykge1xuICBpZiAoaXNDb25zdHJ1Y3RvcihvYmplY3RzKSkge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IGAke2krK31gO1xuICAgIGNhdGFsb2d1ZVtDb21wb25lbnRdID0gb2JqZWN0cztcbiAgICByZXR1cm4gQ29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5hc3NpZ24oY2F0YWxvZ3VlLCBvYmplY3RzKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVJbnN0YW5jZSh0eXBlLCBwcm9wcykge1xuICAvLyBHZXQgdGFyZ2V0IGZyb20gY2F0YWxvZ3VlXG4gIGNvbnN0IG5hbWUgPSB0b1Bhc2NhbENhc2UodHlwZSk7XG4gIGNvbnN0IHRhcmdldCA9IGNhdGFsb2d1ZVtuYW1lXTtcblxuICAvLyBWYWxpZGF0ZSBlbGVtZW50IHRhcmdldFxuICBpZiAodHlwZSAhPT0gJ3ByaW1pdGl2ZScgJiYgIXRhcmdldCkgdGhyb3cgbmV3IEVycm9yKGBSM0Y6ICR7bmFtZX0gaXMgbm90IHBhcnQgb2YgdGhlIFRIUkVFIG5hbWVzcGFjZSEgRGlkIHlvdSBmb3JnZXQgdG8gZXh0ZW5kPyBTZWU6IGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9vYmplY3RzI3VzaW5nLTNyZC1wYXJ0eS1vYmplY3RzLWRlY2xhcmF0aXZlbHlgKTtcblxuICAvLyBWYWxpZGF0ZSBwcmltaXRpdmVzXG4gIGlmICh0eXBlID09PSAncHJpbWl0aXZlJyAmJiAhcHJvcHMub2JqZWN0KSB0aHJvdyBuZXcgRXJyb3IoYFIzRjogUHJpbWl0aXZlcyB3aXRob3V0ICdvYmplY3QnIGFyZSBpbnZhbGlkIWApO1xuXG4gIC8vIFRocm93IGlmIGFuIG9iamVjdCBvciBsaXRlcmFsIHdhcyBwYXNzZWQgZm9yIGFyZ3NcbiAgaWYgKHByb3BzLmFyZ3MgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShwcm9wcy5hcmdzKSkgdGhyb3cgbmV3IEVycm9yKCdSM0Y6IFRoZSBhcmdzIHByb3AgbXVzdCBiZSBhbiBhcnJheSEnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHByb3BzLCByb290KSB7XG4gIHZhciBfcHJvcHMkb2JqZWN0O1xuICAvLyBSZW1vdmUgdGhyZWUqIHByZWZpeCBmcm9tIGVsZW1lbnRzIGlmIG5hdGl2ZSBlbGVtZW50IG5vdCBwcmVzZW50XG4gIHR5cGUgPSB0b1Bhc2NhbENhc2UodHlwZSkgaW4gY2F0YWxvZ3VlID8gdHlwZSA6IHR5cGUucmVwbGFjZShQUkVGSVhfUkVHRVgsICcnKTtcbiAgdmFsaWRhdGVJbnN0YW5jZSh0eXBlLCBwcm9wcyk7XG5cbiAgLy8gUmVnZW5lcmF0ZSB0aGUgUjNGIGluc3RhbmNlIGZvciBwcmltaXRpdmVzIHRvIHNpbXVsYXRlIGEgbmV3IG9iamVjdFxuICBpZiAodHlwZSA9PT0gJ3ByaW1pdGl2ZScgJiYgKF9wcm9wcyRvYmplY3QgPSBwcm9wcy5vYmplY3QpICE9IG51bGwgJiYgX3Byb3BzJG9iamVjdC5fX3IzZikgZGVsZXRlIHByb3BzLm9iamVjdC5fX3IzZjtcbiAgcmV0dXJuIHByZXBhcmUocHJvcHMub2JqZWN0LCByb290LCB0eXBlLCBwcm9wcyk7XG59XG5mdW5jdGlvbiBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaWYgKCFpbnN0YW5jZS5pc0hpZGRlbikge1xuICAgIHZhciBfaW5zdGFuY2UkcGFyZW50O1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hdHRhY2ggJiYgKF9pbnN0YW5jZSRwYXJlbnQgPSBpbnN0YW5jZS5wYXJlbnQpICE9IG51bGwgJiYgX2luc3RhbmNlJHBhcmVudC5vYmplY3QpIHtcbiAgICAgIGRldGFjaChpbnN0YW5jZS5wYXJlbnQsIGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0M0QoaW5zdGFuY2Uub2JqZWN0KSkge1xuICAgICAgaW5zdGFuY2Uub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaW5zdGFuY2UuaXNIaWRkZW4gPSB0cnVlO1xuICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZS5pc0hpZGRlbikge1xuICAgIHZhciBfaW5zdGFuY2UkcGFyZW50MjtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuYXR0YWNoICYmIChfaW5zdGFuY2UkcGFyZW50MiA9IGluc3RhbmNlLnBhcmVudCkgIT0gbnVsbCAmJiBfaW5zdGFuY2UkcGFyZW50Mi5vYmplY3QpIHtcbiAgICAgIGF0dGFjaChpbnN0YW5jZS5wYXJlbnQsIGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0M0QoaW5zdGFuY2Uub2JqZWN0KSAmJiBpbnN0YW5jZS5wcm9wcy52aXNpYmxlICE9PSBmYWxzZSkge1xuICAgICAgaW5zdGFuY2Uub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuICAgIH1cbiAgICBpbnN0YW5jZS5pc0hpZGRlbiA9IGZhbHNlO1xuICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDI3MVxuLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSBldmVudHMgYW5kIGF0dGFjaCBhcmUgb25seSBoYW5kbGVkIG9uY2Ugd2hlbiB0cmVlcyBhcmUgY29tcGxldGVcbmZ1bmN0aW9uIGhhbmRsZUNvbnRhaW5lckVmZmVjdHMocGFyZW50LCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgLy8gQmFpbCBpZiB0cmVlIGlzbid0IG1vdW50ZWQgb3IgcGFyZW50IGlzIG5vdCBhIGNvbnRhaW5lci5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHRyZWUgaXMgZmluYWxpemVkIGFuZCBSZWFjdCB3b24ndCBkaXNjYXJkIHJlc3VsdHMgdG8gU3VzcGVuc2VcbiAgY29uc3Qgc3RhdGUgPSBjaGlsZC5yb290LmdldFN0YXRlKCk7XG4gIGlmICghcGFyZW50LnBhcmVudCAmJiBwYXJlbnQub2JqZWN0ICE9PSBzdGF0ZS5zY2VuZSkgcmV0dXJuO1xuXG4gIC8vIENyZWF0ZSAmIGxpbmsgb2JqZWN0IG9uIGZpcnN0IHJ1blxuICBpZiAoIWNoaWxkLm9iamVjdCkge1xuICAgIHZhciBfY2hpbGQkcHJvcHMkb2JqZWN0LCBfY2hpbGQkcHJvcHMkYXJncztcbiAgICAvLyBHZXQgdGFyZ2V0IGZyb20gY2F0YWxvZ3VlXG4gICAgY29uc3QgdGFyZ2V0ID0gY2F0YWxvZ3VlW3RvUGFzY2FsQ2FzZShjaGlsZC50eXBlKV07XG5cbiAgICAvLyBDcmVhdGUgb2JqZWN0XG4gICAgY2hpbGQub2JqZWN0ID0gKF9jaGlsZCRwcm9wcyRvYmplY3QgPSBjaGlsZC5wcm9wcy5vYmplY3QpICE9IG51bGwgPyBfY2hpbGQkcHJvcHMkb2JqZWN0IDogbmV3IHRhcmdldCguLi4oKF9jaGlsZCRwcm9wcyRhcmdzID0gY2hpbGQucHJvcHMuYXJncykgIT0gbnVsbCA/IF9jaGlsZCRwcm9wcyRhcmdzIDogW10pKTtcbiAgICBjaGlsZC5vYmplY3QuX19yM2YgPSBjaGlsZDtcbiAgfVxuXG4gIC8vIFNldCBpbml0aWFsIHByb3BzXG4gIGFwcGx5UHJvcHMoY2hpbGQub2JqZWN0LCBjaGlsZC5wcm9wcyk7XG5cbiAgLy8gQXBwZW5kIGluc3RhbmNlXG4gIGlmIChjaGlsZC5wcm9wcy5hdHRhY2gpIHtcbiAgICBhdHRhY2gocGFyZW50LCBjaGlsZCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QzRChjaGlsZC5vYmplY3QpICYmIGlzT2JqZWN0M0QocGFyZW50Lm9iamVjdCkpIHtcbiAgICBjb25zdCBjaGlsZEluZGV4ID0gcGFyZW50Lm9iamVjdC5jaGlsZHJlbi5pbmRleE9mKGJlZm9yZUNoaWxkID09IG51bGwgPyB2b2lkIDAgOiBiZWZvcmVDaGlsZC5vYmplY3QpO1xuICAgIGlmIChiZWZvcmVDaGlsZCAmJiBjaGlsZEluZGV4ICE9PSAtMSkge1xuICAgICAgLy8gSWYgdGhlIGNoaWxkIGlzIGFscmVhZHkgaW4gdGhlIHBhcmVudCdzIGNoaWxkcmVuIGFycmF5LCBtb3ZlIGl0IHRvIHRoZSBuZXcgcG9zaXRpb25cbiAgICAgIC8vIE90aGVyd2lzZSwganVzdCBpbnNlcnQgaXQgYXQgdGhlIHRhcmdldCBwb3NpdGlvblxuICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IHBhcmVudC5vYmplY3QuY2hpbGRyZW4uaW5kZXhPZihjaGlsZC5vYmplY3QpO1xuICAgICAgaWYgKGV4aXN0aW5nSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHBhcmVudC5vYmplY3QuY2hpbGRyZW4uc3BsaWNlKGV4aXN0aW5nSW5kZXgsIDEpO1xuICAgICAgICBjb25zdCBhZGp1c3RlZEluZGV4ID0gZXhpc3RpbmdJbmRleCA8IGNoaWxkSW5kZXggPyBjaGlsZEluZGV4IC0gMSA6IGNoaWxkSW5kZXg7XG4gICAgICAgIHBhcmVudC5vYmplY3QuY2hpbGRyZW4uc3BsaWNlKGFkanVzdGVkSW5kZXgsIDAsIGNoaWxkLm9iamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZC5vYmplY3QucGFyZW50ID0gcGFyZW50Lm9iamVjdDtcbiAgICAgICAgcGFyZW50Lm9iamVjdC5jaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMCwgY2hpbGQub2JqZWN0KTtcbiAgICAgICAgY2hpbGQub2JqZWN0LmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdhZGRlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5vYmplY3QuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogJ2NoaWxkYWRkZWQnLFxuICAgICAgICAgIGNoaWxkOiBjaGlsZC5vYmplY3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5vYmplY3QuYWRkKGNoaWxkLm9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgLy8gTGluayBzdWJ0cmVlXG4gIGZvciAoY29uc3QgY2hpbGRJbnN0YW5jZSBvZiBjaGlsZC5jaGlsZHJlbikgaGFuZGxlQ29udGFpbmVyRWZmZWN0cyhjaGlsZCwgY2hpbGRJbnN0YW5jZSk7XG5cbiAgLy8gVHJlZSB3YXMgdXBkYXRlZCwgcmVxdWVzdCBhIGZyYW1lXG4gIGludmFsaWRhdGVJbnN0YW5jZShjaGlsZCk7XG59XG5mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gIGlmICghY2hpbGQpIHJldHVybjtcblxuICAvLyBMaW5rIGluc3RhbmNlc1xuICBjaGlsZC5wYXJlbnQgPSBwYXJlbnQ7XG4gIHBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAvLyBBdHRhY2ggdHJlZSBvbmNlIGNvbXBsZXRlXG4gIGhhbmRsZUNvbnRhaW5lckVmZmVjdHMocGFyZW50LCBjaGlsZCk7XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50LCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgaWYgKCFjaGlsZCB8fCAhYmVmb3JlQ2hpbGQpIHJldHVybjtcblxuICAvLyBMaW5rIGluc3RhbmNlc1xuICBjaGlsZC5wYXJlbnQgPSBwYXJlbnQ7XG4gIGNvbnN0IGNoaWxkSW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihiZWZvcmVDaGlsZCk7XG4gIGlmIChjaGlsZEluZGV4ICE9PSAtMSkgcGFyZW50LmNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAwLCBjaGlsZCk7ZWxzZSBwYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgLy8gQXR0YWNoIHRyZWUgb25jZSBjb21wbGV0ZVxuICBoYW5kbGVDb250YWluZXJFZmZlY3RzKHBhcmVudCwgY2hpbGQsIGJlZm9yZUNoaWxkKTtcbn1cbmZ1bmN0aW9uIGRpc3Bvc2VPbklkbGUob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0LmRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBoYW5kbGVEaXNwb3NlID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2JqZWN0LmRpc3Bvc2UoKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBuby1vcFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJbiBhIHRlc3RpbmcgZW52aXJvbm1lbnQsIGNsZWFudXAgaW1tZWRpYXRlbHlcbiAgICBpZiAodHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCAhPT0gJ3VuZGVmaW5lZCcpIGhhbmRsZURpc3Bvc2UoKTtcbiAgICAvLyBPdGhlcndpc2UsIHVzaW5nIGEgcmVhbCBHUFUgc28gc2NoZWR1bGUgY2xlYW51cCB0byBwcmV2ZW50IHN0YWxsc1xuICAgIGVsc2UgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayh1bnN0YWJsZV9JZGxlUHJpb3JpdHksIGhhbmRsZURpc3Bvc2UpO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnQsIGNoaWxkLCBkaXNwb3NlKSB7XG4gIGlmICghY2hpbGQpIHJldHVybjtcblxuICAvLyBVbmxpbmsgaW5zdGFuY2VzXG4gIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gIGNvbnN0IGNoaWxkSW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gIGlmIChjaGlsZEluZGV4ICE9PSAtMSkgcGFyZW50LmNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAxKTtcblxuICAvLyBFYWdlcmx5IHRlYXIgZG93biB0cmVlXG4gIGlmIChjaGlsZC5wcm9wcy5hdHRhY2gpIHtcbiAgICBkZXRhY2gocGFyZW50LCBjaGlsZCk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QzRChjaGlsZC5vYmplY3QpICYmIGlzT2JqZWN0M0QocGFyZW50Lm9iamVjdCkpIHtcbiAgICBwYXJlbnQub2JqZWN0LnJlbW92ZShjaGlsZC5vYmplY3QpO1xuICAgIHJlbW92ZUludGVyYWN0aXZpdHkoZmluZEluaXRpYWxSb290KGNoaWxkKSwgY2hpbGQub2JqZWN0KTtcbiAgfVxuXG4gIC8vIEFsbG93IG9iamVjdHMgdG8gYmFpbCBvdXQgb2YgdW5tb3VudCBkaXNwb3NhbCB3aXRoIGRpc3Bvc2U9e251bGx9XG4gIGNvbnN0IHNob3VsZERpc3Bvc2UgPSBjaGlsZC5wcm9wcy5kaXNwb3NlICE9PSBudWxsICYmIGRpc3Bvc2UgIT09IGZhbHNlO1xuXG4gIC8vIFJlY3Vyc2l2ZWx5IHJlbW92ZSBpbnN0YW5jZSBjaGlsZHJlblxuICBmb3IgKGxldCBpID0gY2hpbGQuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBub2RlID0gY2hpbGQuY2hpbGRyZW5baV07XG4gICAgcmVtb3ZlQ2hpbGQoY2hpbGQsIG5vZGUsIHNob3VsZERpc3Bvc2UpO1xuICB9XG4gIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgLy8gVW5saW5rIGluc3RhbmNlIG9iamVjdFxuICBkZWxldGUgY2hpbGQub2JqZWN0Ll9fcjNmO1xuXG4gIC8vIERpc3Bvc2Ugb2JqZWN0IHdoZW5ldmVyIHRoZSByZWNvbmNpbGVyIGZlZWxzIGxpa2UgaXQuXG4gIC8vIE5ldmVyIGRpc3Bvc2Ugb2YgcHJpbWl0aXZlcyBiZWNhdXNlIHRoZWlyIHN0YXRlIG1heSBiZSBrZXB0IG91dHNpZGUgb2YgUmVhY3QhXG4gIC8vIEluIG9yZGVyIGZvciBhbiBvYmplY3QgdG8gYmUgYWJsZSB0byBkaXNwb3NlIGl0XG4gIC8vICAgLSBoYXMgYSBkaXNwb3NlIG1ldGhvZFxuICAvLyAgIC0gY2Fubm90IGJlIGEgPHByaW1pdGl2ZSBvYmplY3Q9ey4uLn0gLz5cbiAgLy8gICAtIGNhbm5vdCBiZSBhIFRIUkVFLlNjZW5lLCBiZWNhdXNlIHRocmVlIGhhcyBicm9rZW4gaXRzIG93biBBUElcbiAgaWYgKHNob3VsZERpc3Bvc2UgJiYgY2hpbGQudHlwZSAhPT0gJ3ByaW1pdGl2ZScgJiYgY2hpbGQub2JqZWN0LnR5cGUgIT09ICdTY2VuZScpIHtcbiAgICBkaXNwb3NlT25JZGxlKGNoaWxkLm9iamVjdCk7XG4gIH1cblxuICAvLyBUcmVlIHdhcyB1cGRhdGVkLCByZXF1ZXN0IGEgZnJhbWUgZm9yIHRvcC1sZXZlbCBpbnN0YW5jZVxuICBpZiAoZGlzcG9zZSA9PT0gdW5kZWZpbmVkKSBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xufVxuZnVuY3Rpb24gc2V0RmliZXJSZWYoZmliZXIsIHB1YmxpY0luc3RhbmNlKSB7XG4gIGZvciAoY29uc3QgX2ZpYmVyIG9mIFtmaWJlciwgZmliZXIuYWx0ZXJuYXRlXSkge1xuICAgIGlmIChfZmliZXIgIT09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgX2ZpYmVyLnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfZmliZXIucmVmQ2xlYW51cCA9PSBudWxsID8gdm9pZCAwIDogX2ZpYmVyLnJlZkNsZWFudXAoKTtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IF9maWJlci5yZWYocHVibGljSW5zdGFuY2UpO1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicpIF9maWJlci5yZWZDbGVhbnVwID0gY2xlYW51cDtcbiAgICAgIH0gZWxzZSBpZiAoX2ZpYmVyLnJlZikge1xuICAgICAgICBfZmliZXIucmVmLmN1cnJlbnQgPSBwdWJsaWNJbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHJlY29uc3RydWN0ZWQgPSBbXTtcbmZ1bmN0aW9uIHN3YXBJbnN0YW5jZXMoKSB7XG4gIC8vIERldGFjaCBpbnN0YW5jZVxuICBmb3IgKGNvbnN0IFtpbnN0YW5jZV0gb2YgcmVjb25zdHJ1Y3RlZCkge1xuICAgIGNvbnN0IHBhcmVudCA9IGluc3RhbmNlLnBhcmVudDtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuYXR0YWNoKSB7XG4gICAgICAgIGRldGFjaChwYXJlbnQsIGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QzRChpbnN0YW5jZS5vYmplY3QpICYmIGlzT2JqZWN0M0QocGFyZW50Lm9iamVjdCkpIHtcbiAgICAgICAgcGFyZW50Lm9iamVjdC5yZW1vdmUoaW5zdGFuY2Uub2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaW5zdGFuY2UuY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkLnByb3BzLmF0dGFjaCkge1xuICAgICAgICAgIGRldGFjaChpbnN0YW5jZSwgY2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0M0QoY2hpbGQub2JqZWN0KSAmJiBpc09iamVjdDNEKGluc3RhbmNlLm9iamVjdCkpIHtcbiAgICAgICAgICBpbnN0YW5jZS5vYmplY3QucmVtb3ZlKGNoaWxkLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb2xkIGluc3RhbmNlIGlzIGhpZGRlbiwgd2UgbmVlZCB0byB1bmhpZGUgaXQuXG4gICAgLy8gUmVhY3QgYXNzdW1lcyBpdCBjYW4gZGlzY2FyZCBpbnN0YW5jZXMgc2luY2UgdGhleSdyZSBwdXJlIGZvciBET00uXG4gICAgLy8gVGhpcyBpc24ndCB0cnVlIGZvciB1cyBzaW5jZSBvdXIgbGlmZXRpbWVzIGFyZSBpbXB1cmUgYW5kIGxvbmdsaXZpbmcuXG4gICAgLy8gU28sIHdlIG1hbnVhbGx5IGNoZWNrIGlmIGFuIGluc3RhbmNlIHdhcyBoaWRkZW4gYW5kIHVuaGlkZSBpdC5cbiAgICBpZiAoaW5zdGFuY2UuaXNIaWRkZW4pIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlKTtcblxuICAgIC8vIERpc3Bvc2Ugb2Ygb2xkIG9iamVjdCBpZiBhYmxlXG4gICAgaWYgKGluc3RhbmNlLm9iamVjdC5fX3IzZikgZGVsZXRlIGluc3RhbmNlLm9iamVjdC5fX3IzZjtcbiAgICBpZiAoaW5zdGFuY2UudHlwZSAhPT0gJ3ByaW1pdGl2ZScpIGRpc3Bvc2VPbklkbGUoaW5zdGFuY2Uub2JqZWN0KTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBpbnN0YW5jZVxuICBmb3IgKGNvbnN0IFtpbnN0YW5jZSwgcHJvcHMsIGZpYmVyXSBvZiByZWNvbnN0cnVjdGVkKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICBjb25zdCBwYXJlbnQgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRwcm9wcyRvYmplYywgX2luc3RhbmNlJHByb3BzJGFyZ3M7XG4gICAgICAvLyBHZXQgdGFyZ2V0IGZyb20gY2F0YWxvZ3VlXG4gICAgICBjb25zdCB0YXJnZXQgPSBjYXRhbG9ndWVbdG9QYXNjYWxDYXNlKGluc3RhbmNlLnR5cGUpXTtcblxuICAgICAgLy8gQ3JlYXRlIG9iamVjdFxuICAgICAgaW5zdGFuY2Uub2JqZWN0ID0gKF9pbnN0YW5jZSRwcm9wcyRvYmplYyA9IGluc3RhbmNlLnByb3BzLm9iamVjdCkgIT0gbnVsbCA/IF9pbnN0YW5jZSRwcm9wcyRvYmplYyA6IG5ldyB0YXJnZXQoLi4uKChfaW5zdGFuY2UkcHJvcHMkYXJncyA9IGluc3RhbmNlLnByb3BzLmFyZ3MpICE9IG51bGwgPyBfaW5zdGFuY2UkcHJvcHMkYXJncyA6IFtdKSk7XG4gICAgICBpbnN0YW5jZS5vYmplY3QuX19yM2YgPSBpbnN0YW5jZTtcbiAgICAgIHNldEZpYmVyUmVmKGZpYmVyLCBpbnN0YW5jZS5vYmplY3QpO1xuXG4gICAgICAvLyBTZXQgaW5pdGlhbCBwcm9wc1xuICAgICAgYXBwbHlQcm9wcyhpbnN0YW5jZS5vYmplY3QsIGluc3RhbmNlLnByb3BzKTtcbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hdHRhY2gpIHtcbiAgICAgICAgYXR0YWNoKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdDNEKGluc3RhbmNlLm9iamVjdCkgJiYgaXNPYmplY3QzRChwYXJlbnQub2JqZWN0KSkge1xuICAgICAgICBwYXJlbnQub2JqZWN0LmFkZChpbnN0YW5jZS5vYmplY3QpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQucHJvcHMuYXR0YWNoKSB7XG4gICAgICAgICAgYXR0YWNoKGluc3RhbmNlLCBjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QzRChjaGlsZC5vYmplY3QpICYmIGlzT2JqZWN0M0QoaW5zdGFuY2Uub2JqZWN0KSkge1xuICAgICAgICAgIGluc3RhbmNlLm9iamVjdC5hZGQoY2hpbGQub2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUcmVlIHdhcyB1cGRhdGVkLCByZXF1ZXN0IGEgZnJhbWVcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfVxuICB9XG4gIHJlY29uc3RydWN0ZWQubGVuZ3RoID0gMDtcbn1cblxuLy8gRG9uJ3QgaGFuZGxlIHRleHQgaW5zdGFuY2VzLCBtYWtlIGl0IG5vLW9wXG5jb25zdCBoYW5kbGVUZXh0SW5zdGFuY2UgPSAoKSA9PiB7fTtcbmNvbnN0IE5PX0NPTlRFWFQgPSB7fTtcbmxldCBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBOb0V2ZW50UHJpb3JpdHk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21haW4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckZsYWdzLmpzXG5jb25zdCBOb0ZsYWdzID0gMDtcbmNvbnN0IFVwZGF0ZSA9IDQ7XG5jb25zdCByZWNvbmNpbGVyID0gLyogQF9fUFVSRV9fICovY3JlYXRlUmVjb25jaWxlcih7XG4gIGlzUHJpbWFyeVJlbmRlcmVyOiBmYWxzZSxcbiAgd2FybnNJZk5vdEFjdGluZzogZmFsc2UsXG4gIHN1cHBvcnRzTXV0YXRpb246IHRydWUsXG4gIHN1cHBvcnRzUGVyc2lzdGVuY2U6IGZhbHNlLFxuICBzdXBwb3J0c0h5ZHJhdGlvbjogZmFsc2UsXG4gIGNyZWF0ZUluc3RhbmNlLFxuICByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQsXG4gIGFwcGVuZEluaXRpYWxDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIGluc2VydEJlZm9yZSxcbiAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZS5fX3IzZjtcbiAgICBpZiAoIWNoaWxkIHx8ICFzY2VuZSkgcmV0dXJuO1xuICAgIGFwcGVuZENoaWxkKHNjZW5lLCBjaGlsZCk7XG4gIH0sXG4gIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZS5fX3IzZjtcbiAgICBpZiAoIWNoaWxkIHx8ICFzY2VuZSkgcmV0dXJuO1xuICAgIHJlbW92ZUNoaWxkKHNjZW5lLCBjaGlsZCk7XG4gIH0sXG4gIGluc2VydEluQ29udGFpbmVyQmVmb3JlKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZS5fX3IzZjtcbiAgICBpZiAoIWNoaWxkIHx8ICFiZWZvcmVDaGlsZCB8fCAhc2NlbmUpIHJldHVybjtcbiAgICBpbnNlcnRCZWZvcmUoc2NlbmUsIGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gIH0sXG4gIGdldFJvb3RIb3N0Q29udGV4dDogKCkgPT4gTk9fQ09OVEVYVCxcbiAgZ2V0Q2hpbGRIb3N0Q29udGV4dDogKCkgPT4gTk9fQ09OVEVYVCxcbiAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGZpYmVyKSB7XG4gICAgdmFyIF9uZXdQcm9wcyRhcmdzLCBfb2xkUHJvcHMkYXJncywgX25ld1Byb3BzJGFyZ3MyO1xuICAgIHZhbGlkYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMpO1xuICAgIGxldCByZWNvbnN0cnVjdCA9IGZhbHNlO1xuXG4gICAgLy8gUmVjb25zdHJ1Y3QgcHJpbWl0aXZlcyBpZiBvYmplY3QgcHJvcCBjaGFuZ2VzXG4gICAgaWYgKGluc3RhbmNlLnR5cGUgPT09ICdwcmltaXRpdmUnICYmIG9sZFByb3BzLm9iamVjdCAhPT0gbmV3UHJvcHMub2JqZWN0KSByZWNvbnN0cnVjdCA9IHRydWU7XG4gICAgLy8gUmVjb25zdHJ1Y3QgaW5zdGFuY2UgaWYgYXJncyB3ZXJlIGFkZGVkIG9yIHJlbW92ZWRcbiAgICBlbHNlIGlmICgoKF9uZXdQcm9wcyRhcmdzID0gbmV3UHJvcHMuYXJncykgPT0gbnVsbCA/IHZvaWQgMCA6IF9uZXdQcm9wcyRhcmdzLmxlbmd0aCkgIT09ICgoX29sZFByb3BzJGFyZ3MgPSBvbGRQcm9wcy5hcmdzKSA9PSBudWxsID8gdm9pZCAwIDogX29sZFByb3BzJGFyZ3MubGVuZ3RoKSkgcmVjb25zdHJ1Y3QgPSB0cnVlO1xuICAgIC8vIFJlY29uc3RydWN0IGluc3RhbmNlIGlmIGFyZ3Mgd2VyZSBjaGFuZ2VkXG4gICAgZWxzZSBpZiAoKF9uZXdQcm9wcyRhcmdzMiA9IG5ld1Byb3BzLmFyZ3MpICE9IG51bGwgJiYgX25ld1Byb3BzJGFyZ3MyLnNvbWUoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgdmFyIF9vbGRQcm9wcyRhcmdzMjtcbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gKChfb2xkUHJvcHMkYXJnczIgPSBvbGRQcm9wcy5hcmdzKSA9PSBudWxsID8gdm9pZCAwIDogX29sZFByb3BzJGFyZ3MyW2luZGV4XSk7XG4gICAgfSkpIHJlY29uc3RydWN0ID0gdHJ1ZTtcblxuICAgIC8vIFJlY29uc3RydWN0IHdoZW4gYXJncyBvciA8cHJpbWl0aXZlIG9iamVjdD17Li4ufSBoYXZlIGNoYW5nZXNcbiAgICBpZiAocmVjb25zdHJ1Y3QpIHtcbiAgICAgIHJlY29uc3RydWN0ZWQucHVzaChbaW5zdGFuY2UsIHtcbiAgICAgICAgLi4ubmV3UHJvcHNcbiAgICAgIH0sIGZpYmVyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIGRpZmYtc2V0LCBmbGFnIGlmIHRoZXJlIGFyZSBhbnkgY2hhbmdlc1xuICAgICAgY29uc3QgY2hhbmdlZFByb3BzID0gZGlmZlByb3BzKGluc3RhbmNlLCBuZXdQcm9wcyk7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoY2hhbmdlZFByb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZS5wcm9wcywgY2hhbmdlZFByb3BzKTtcbiAgICAgICAgYXBwbHlQcm9wcyhpbnN0YW5jZS5vYmplY3QsIGNoYW5nZWRQcm9wcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggcmVjb25zdHJ1Y3RlZCBzaWJsaW5ncyB3aGVuIHdlIGhpdCB0aGUgbGFzdCB1cGRhdGVkIGNoaWxkIGluIGEgc2VxdWVuY2VcbiAgICBjb25zdCBpc1RhaWxTaWJsaW5nID0gZmliZXIuc2libGluZyA9PT0gbnVsbCB8fCAoZmliZXIuZmxhZ3MgJiBVcGRhdGUpID09PSBOb0ZsYWdzO1xuICAgIGlmIChpc1RhaWxTaWJsaW5nKSBzd2FwSW5zdGFuY2VzKCk7XG4gIH0sXG4gIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOiAoKSA9PiBmYWxzZSxcbiAgY29tbWl0TW91bnQoKSB7fSxcbiAgZ2V0UHVibGljSW5zdGFuY2U6IGluc3RhbmNlID0+IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5vYmplY3QsXG4gIHByZXBhcmVGb3JDb21taXQ6ICgpID0+IG51bGwsXG4gIHByZXBhcmVQb3J0YWxNb3VudDogY29udGFpbmVyID0+IHByZXBhcmUoY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUsIGNvbnRhaW5lciwgJycsIHt9KSxcbiAgcmVzZXRBZnRlckNvbW1pdDogKCkgPT4ge30sXG4gIHNob3VsZFNldFRleHRDb250ZW50OiAoKSA9PiBmYWxzZSxcbiAgY2xlYXJDb250YWluZXI6ICgpID0+IGZhbHNlLFxuICBoaWRlSW5zdGFuY2UsXG4gIHVuaGlkZUluc3RhbmNlLFxuICBjcmVhdGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgaGlkZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICB1bmhpZGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgc2NoZWR1bGVUaW1lb3V0OiB0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFRpbWVvdXQgOiB1bmRlZmluZWQsXG4gIGNhbmNlbFRpbWVvdXQ6IHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBjbGVhclRpbWVvdXQgOiB1bmRlZmluZWQsXG4gIG5vVGltZW91dDogLTEsXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6ICgpID0+IG51bGwsXG4gIGJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1cigpIHt9LFxuICBhZnRlckFjdGl2ZUluc3RhbmNlQmx1cigpIHt9LFxuICBkZXRhY2hEZWxldGVkSW5zdGFuY2UoKSB7fSxcbiAgcHJlcGFyZVNjb3BlVXBkYXRlKCkge30sXG4gIGdldEluc3RhbmNlRnJvbVNjb3BlOiAoKSA9PiBudWxsLFxuICBzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uOiAoKSA9PiBmYWxzZSxcbiAgdHJhY2tTY2hlZHVsZXJFdmVudDogKCkgPT4ge30sXG4gIHJlc29sdmVFdmVudFR5cGU6ICgpID0+IG51bGwsXG4gIHJlc29sdmVFdmVudFRpbWVTdGFtcDogKCkgPT4gLTEuMSxcbiAgcmVxdWVzdFBvc3RQYWludENhbGxiYWNrKCkge30sXG4gIG1heVN1c3BlbmRDb21taXQ6ICgpID0+IGZhbHNlLFxuICBwcmVsb2FkSW5zdGFuY2U6ICgpID0+IHRydWUsXG4gIC8vIHRydWUgaW5kaWNhdGVzIGFscmVhZHkgbG9hZGVkXG4gIHN0YXJ0U3VzcGVuZGluZ0NvbW1pdCgpIHt9LFxuICBzdXNwZW5kSW5zdGFuY2UoKSB7fSxcbiAgd2FpdEZvckNvbW1pdFRvQmVSZWFkeTogKCkgPT4gbnVsbCxcbiAgTm90UGVuZGluZ1RyYW5zaXRpb246IG51bGwsXG4gIC8vIFRoZSByZWNvbmNpbGVyIHR5cGVzIHVzZSB0aGUgaW50ZXJuYWwgUmVhY3RDb250ZXh0IHdpdGggYWxsIHRoZSBoaWRkZW4gcHJvcGVydGllc1xuICAvLyBzbyB3ZSBoYXZlIHRvIGNhc3QgZnJvbSB0aGUgcHVibGljIFJlYWN0LkNvbnRleHQgdHlwZVxuICBIb3N0VHJhbnNpdGlvbkNvbnRleHQ6IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCksXG4gIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShuZXdQcmlvcml0eSkge1xuICAgIGN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IG5ld1ByaW9yaXR5O1xuICB9LFxuICBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbiAgfSxcbiAgcmVzb2x2ZVVwZGF0ZVByaW9yaXR5KCkge1xuICAgIHZhciBfd2luZG93JGV2ZW50O1xuICAgIGlmIChjdXJyZW50VXBkYXRlUHJpb3JpdHkgIT09IE5vRXZlbnRQcmlvcml0eSkgcmV0dXJuIGN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbiAgICBzd2l0Y2ggKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgoX3dpbmRvdyRldmVudCA9IHdpbmRvdy5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckZXZlbnQudHlwZSkpIHtcbiAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICAgIGNhc2UgJ2RibGNsaWNrJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgICAgY2FzZSAncG9pbnRlcmRvd24nOlxuICAgICAgY2FzZSAncG9pbnRlcnVwJzpcbiAgICAgICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgICAgIGNhc2UgJ3BvaW50ZXJtb3ZlJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgICAgY2FzZSAncG9pbnRlcm92ZXInOlxuICAgICAgY2FzZSAncG9pbnRlcmVudGVyJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJsZWF2ZSc6XG4gICAgICBjYXNlICd3aGVlbCc6XG4gICAgICAgIHJldHVybiBDb250aW51b3VzRXZlbnRQcmlvcml0eTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgICB9XG4gIH0sXG4gIHJlc2V0Rm9ybUluc3RhbmNlKCkge31cbn0pO1xuXG5jb25zdCBfcm9vdHMgPSBuZXcgTWFwKCk7XG5jb25zdCBzaGFsbG93TG9vc2UgPSB7XG4gIG9iamVjdHM6ICdzaGFsbG93JyxcbiAgc3RyaWN0OiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIHNpemUpIHtcbiAgaWYgKCFzaXplICYmIHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgJiYgY2FudmFzLnBhcmVudEVsZW1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnRcbiAgICB9ID0gY2FudmFzLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdFxuICAgIH07XG4gIH0gZWxzZSBpZiAoIXNpemUgJiYgdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5zaXplXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSb290KGNhbnZhcykge1xuICAvLyBDaGVjayBhZ2FpbnN0IG1pc3Rha2VuIHVzZSBvZiBjcmVhdGVSb290XG4gIGNvbnN0IHByZXZSb290ID0gX3Jvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBwcmV2RmliZXIgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3QuZmliZXI7XG4gIGNvbnN0IHByZXZTdG9yZSA9IHByZXZSb290ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Um9vdC5zdG9yZTtcbiAgaWYgKHByZXZSb290KSBjb25zb2xlLndhcm4oJ1IzRi5jcmVhdGVSb290IHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIScpO1xuXG4gIC8vIFJlcG9ydCB3aGVuIGFuIGVycm9yIHdhcyBkZXRlY3RlZCBpbiBhIHByZXZpb3VzIHJlbmRlclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjI2MVxuICBjb25zdCBsb2dSZWNvdmVyYWJsZUVycm9yID0gdHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nID9cbiAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCByZXBvcnRFcnJvciB3aWxsIGRpc3BhdGNoIGFuIGVycm9yIGV2ZW50LFxuICAvLyBlbXVsYXRpbmcgYW4gdW5jYXVnaHQgSmF2YVNjcmlwdCBlcnJvci5cbiAgcmVwb3J0RXJyb3IgOlxuICAvLyBJbiBvbGRlciBicm93c2VycyBhbmQgdGVzdCBlbnZpcm9ubWVudHMsIGZhbGxiYWNrIHRvIGNvbnNvbGUuZXJyb3IuXG4gIGNvbnNvbGUuZXJyb3I7XG5cbiAgLy8gQ3JlYXRlIHN0b3JlXG4gIGNvbnN0IHN0b3JlID0gcHJldlN0b3JlIHx8IGNyZWF0ZVN0b3JlKGludmFsaWRhdGUsIGFkdmFuY2UpO1xuICAvLyBDcmVhdGUgcmVuZGVyZXJcbiAgY29uc3QgZmliZXIgPSBwcmV2RmliZXIgfHwgcmVjb25jaWxlci5jcmVhdGVDb250YWluZXIoc3RvcmUsXG4gIC8vIGNvbnRhaW5lclxuICBDb25jdXJyZW50Um9vdCxcbiAgLy8gdGFnXG4gIG51bGwsXG4gIC8vIGh5ZHJhdGlvbiBjYWxsYmFja3NcbiAgZmFsc2UsXG4gIC8vIGlzU3RyaWN0TW9kZVxuICBudWxsLFxuICAvLyBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlXG4gICcnLFxuICAvLyBpZGVudGlmaWVyUHJlZml4XG4gIGxvZ1JlY292ZXJhYmxlRXJyb3IsXG4gIC8vIG9uVW5jYXVnaHRFcnJvclxuICBsb2dSZWNvdmVyYWJsZUVycm9yLFxuICAvLyBvbkNhdWdodEVycm9yXG4gIGxvZ1JlY292ZXJhYmxlRXJyb3IsXG4gIC8vIG9uUmVjb3ZlcmFibGVFcnJvclxuICBudWxsIC8vIHRyYW5zaXRpb25DYWxsYmFja3NcbiAgKTtcbiAgLy8gTWFwIGl0XG4gIGlmICghcHJldlJvb3QpIF9yb290cy5zZXQoY2FudmFzLCB7XG4gICAgZmliZXIsXG4gICAgc3RvcmVcbiAgfSk7XG5cbiAgLy8gTG9jYWxzXG4gIGxldCBvbkNyZWF0ZWQ7XG4gIGxldCBsYXN0Q2FtZXJhO1xuICBsZXQgY29uZmlndXJlZCA9IGZhbHNlO1xuICBsZXQgcGVuZGluZyA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgYXN5bmMgY29uZmlndXJlKHByb3BzID0ge30pIHtcbiAgICAgIGxldCByZXNvbHZlO1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKF9yZXNvbHZlID0+IHJlc29sdmUgPSBfcmVzb2x2ZSk7XG4gICAgICBsZXQge1xuICAgICAgICBnbDogZ2xDb25maWcsXG4gICAgICAgIHNpemU6IHByb3BzU2l6ZSxcbiAgICAgICAgc2NlbmU6IHNjZW5lT3B0aW9ucyxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZENhbGxiYWNrLFxuICAgICAgICBzaGFkb3dzID0gZmFsc2UsXG4gICAgICAgIGxpbmVhciA9IGZhbHNlLFxuICAgICAgICBmbGF0ID0gZmFsc2UsXG4gICAgICAgIGxlZ2FjeSA9IGZhbHNlLFxuICAgICAgICBvcnRob2dyYXBoaWMgPSBmYWxzZSxcbiAgICAgICAgZnJhbWVsb29wID0gJ2Fsd2F5cycsXG4gICAgICAgIGRwciA9IFsxLCAyXSxcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcjogcmF5Y2FzdE9wdGlvbnMsXG4gICAgICAgIGNhbWVyYTogY2FtZXJhT3B0aW9ucyxcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkXG4gICAgICB9ID0gcHJvcHM7XG4gICAgICBsZXQgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBTZXQgdXAgcmVuZGVyZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IGdsID0gc3RhdGUuZ2w7XG4gICAgICBpZiAoIXN0YXRlLmdsKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgICAgICBwb3dlclByZWZlcmVuY2U6ICdoaWdoLXBlcmZvcm1hbmNlJyxcbiAgICAgICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAgICAgYWxwaGE6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3VzdG9tUmVuZGVyZXIgPSB0eXBlb2YgZ2xDb25maWcgPT09ICdmdW5jdGlvbicgPyBhd2FpdCBnbENvbmZpZyhkZWZhdWx0UHJvcHMpIDogZ2xDb25maWc7XG4gICAgICAgIGlmIChpc1JlbmRlcmVyKGN1c3RvbVJlbmRlcmVyKSkge1xuICAgICAgICAgIGdsID0gY3VzdG9tUmVuZGVyZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2wgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgICAgICAuLi5nbENvbmZpZ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgZ2xcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCByYXljYXN0ZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IHJheWNhc3RlciA9IHN0YXRlLnJheWNhc3RlcjtcbiAgICAgIGlmICghcmF5Y2FzdGVyKSBzdGF0ZS5zZXQoe1xuICAgICAgICByYXljYXN0ZXI6IHJheWNhc3RlciA9IG5ldyBUSFJFRS5SYXljYXN0ZXIoKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCByYXljYXN0ZXIgb3B0aW9uc1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0gPSByYXljYXN0T3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmICghaXMuZXF1KG9wdGlvbnMsIHJheWNhc3Rlciwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhyYXljYXN0ZXIsIHtcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBpZiAoIWlzLmVxdShwYXJhbXMsIHJheWNhc3Rlci5wYXJhbXMsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIC4uLnJheWNhc3Rlci5wYXJhbXMsXG4gICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgZGVmYXVsdCBjYW1lcmEsIGRvbid0IG92ZXJ3cml0ZSBhbnkgdXNlci1zZXQgc3RhdGVcbiAgICAgIGlmICghc3RhdGUuY2FtZXJhIHx8IHN0YXRlLmNhbWVyYSA9PT0gbGFzdENhbWVyYSAmJiAhaXMuZXF1KGxhc3RDYW1lcmEsIGNhbWVyYU9wdGlvbnMsIHNoYWxsb3dMb29zZSkpIHtcbiAgICAgICAgbGFzdENhbWVyYSA9IGNhbWVyYU9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGlzQ2FtZXJhID0gY2FtZXJhT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY2FtZXJhT3B0aW9ucy5pc0NhbWVyYTtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gaXNDYW1lcmEgPyBjYW1lcmFPcHRpb25zIDogb3J0aG9ncmFwaGljID8gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgwLCAwLCAwLCAwLCAwLjEsIDEwMDApIDogbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCAwLCAwLjEsIDEwMDApO1xuICAgICAgICBpZiAoIWlzQ2FtZXJhKSB7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnogPSA1O1xuICAgICAgICAgIGlmIChjYW1lcmFPcHRpb25zKSB7XG4gICAgICAgICAgICBhcHBseVByb3BzKGNhbWVyYSwgY2FtZXJhT3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSB1c2VyLWRlZmluZWQgZnJ1c3R1bSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzE2MFxuICAgICAgICAgICAgaWYgKCFjYW1lcmEubWFudWFsKSB7XG4gICAgICAgICAgICAgIGlmICgnYXNwZWN0JyBpbiBjYW1lcmFPcHRpb25zIHx8ICdsZWZ0JyBpbiBjYW1lcmFPcHRpb25zIHx8ICdyaWdodCcgaW4gY2FtZXJhT3B0aW9ucyB8fCAnYm90dG9tJyBpbiBjYW1lcmFPcHRpb25zIHx8ICd0b3AnIGluIGNhbWVyYU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjYW1lcmEubWFudWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFsd2F5cyBsb29rIGF0IGNlbnRlciBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKCFzdGF0ZS5jYW1lcmEgJiYgIShjYW1lcmFPcHRpb25zICE9IG51bGwgJiYgY2FtZXJhT3B0aW9ucy5yb3RhdGlvbikpIGNhbWVyYS5sb29rQXQoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBjYW1lcmFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHJheWNhc3RlclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXhyL2lzc3Vlcy8zMDBcbiAgICAgICAgcmF5Y2FzdGVyLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIHNjZW5lIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUuc2NlbmUpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBpZiAoc2NlbmVPcHRpb25zICE9IG51bGwgJiYgc2NlbmVPcHRpb25zLmlzU2NlbmUpIHtcbiAgICAgICAgICBzY2VuZSA9IHNjZW5lT3B0aW9ucztcbiAgICAgICAgICBwcmVwYXJlKHNjZW5lLCBzdG9yZSwgJycsIHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgICAgIHByZXBhcmUoc2NlbmUsIHN0b3JlLCAnJywge30pO1xuICAgICAgICAgIGlmIChzY2VuZU9wdGlvbnMpIGFwcGx5UHJvcHMoc2NlbmUsIHNjZW5lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBzY2VuZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgZXZlbnRzIGludGVybmFsbHlcbiAgICAgIGlmIChldmVudHMgJiYgIXN0YXRlLmV2ZW50cy5oYW5kbGVycykgc3RhdGUuc2V0KHtcbiAgICAgICAgZXZlbnRzOiBldmVudHMoc3RvcmUpXG4gICAgICB9KTtcbiAgICAgIC8vIENoZWNrIHNpemUsIGFsbG93IGl0IHRvIHRha2Ugb24gY29udGFpbmVyIGJvdW5kcyBpbml0aWFsbHlcbiAgICAgIGNvbnN0IHNpemUgPSBjb21wdXRlSW5pdGlhbFNpemUoY2FudmFzLCBwcm9wc1NpemUpO1xuICAgICAgaWYgKCFpcy5lcXUoc2l6ZSwgc3RhdGUuc2l6ZSwgc2hhbGxvd0xvb3NlKSkge1xuICAgICAgICBzdGF0ZS5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCBzaXplLnRvcCwgc2l6ZS5sZWZ0KTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHBpeGVscmF0aW9cbiAgICAgIGlmIChkcHIgJiYgc3RhdGUudmlld3BvcnQuZHByICE9PSBjYWxjdWxhdGVEcHIoZHByKSkgc3RhdGUuc2V0RHByKGRwcik7XG4gICAgICAvLyBDaGVjayBmcmFtZWxvb3BcbiAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgIT09IGZyYW1lbG9vcCkgc3RhdGUuc2V0RnJhbWVsb29wKGZyYW1lbG9vcCk7XG4gICAgICAvLyBDaGVjayBwb2ludGVyIG1pc3NlZFxuICAgICAgaWYgKCFzdGF0ZS5vblBvaW50ZXJNaXNzZWQpIHN0YXRlLnNldCh7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZFxuICAgICAgfSk7XG4gICAgICAvLyBDaGVjayBwZXJmb3JtYW5jZVxuICAgICAgaWYgKHBlcmZvcm1hbmNlICYmICFpcy5lcXUocGVyZm9ybWFuY2UsIHN0YXRlLnBlcmZvcm1hbmNlLCBzaGFsbG93TG9vc2UpKSBzdGF0ZS5zZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgICAuLi5wZXJmb3JtYW5jZVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCB1cCBYUiAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnhyKSB7XG4gICAgICAgIHZhciBfZ2wkeHI7XG4gICAgICAgIC8vIEhhbmRsZSBmcmFtZSBiZWhhdmlvciBpbiBXZWJYUlxuICAgICAgICBjb25zdCBoYW5kbGVYUkZyYW1lID0gKHRpbWVzdGFtcCwgZnJhbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJykgcmV0dXJuO1xuICAgICAgICAgIGFkdmFuY2UodGltZXN0YW1wLCB0cnVlLCBzdGF0ZSwgZnJhbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvZ2dsZSByZW5kZXIgc3dpdGNoaW5nIG9uIHNlc3Npb25cbiAgICAgICAgY29uc3QgaGFuZGxlU2Vzc2lvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuZW5hYmxlZCA9IHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZztcbiAgICAgICAgICBzdGF0ZS5nbC54ci5zZXRBbmltYXRpb25Mb29wKHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZyA/IGhhbmRsZVhSRnJhbWUgOiBudWxsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmdsLnhyLmlzUHJlc2VudGluZykgaW52YWxpZGF0ZShzdGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV2ViWFIgc2Vzc2lvbiBtYW5hZ2VyXG4gICAgICAgIGNvbnN0IHhyID0ge1xuICAgICAgICAgIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIFdlYlhSIHNlc3Npb24gZXZlbnRzXG4gICAgICAgIGlmICh0eXBlb2YgKChfZ2wkeHIgPSBnbC54cikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbCR4ci5hZGRFdmVudExpc3RlbmVyKSA9PT0gJ2Z1bmN0aW9uJykgeHIuY29ubmVjdCgpO1xuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIHhyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgc2hhZG93bWFwXG4gICAgICBpZiAoZ2wuc2hhZG93TWFwKSB7XG4gICAgICAgIGNvbnN0IG9sZEVuYWJsZWQgPSBnbC5zaGFkb3dNYXAuZW5hYmxlZDtcbiAgICAgICAgY29uc3Qgb2xkVHlwZSA9IGdsLnNoYWRvd01hcC50eXBlO1xuICAgICAgICBnbC5zaGFkb3dNYXAuZW5hYmxlZCA9ICEhc2hhZG93cztcbiAgICAgICAgaWYgKGlzLmJvbyhzaGFkb3dzKSkge1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5zdHIoc2hhZG93cykpIHtcbiAgICAgICAgICB2YXIgX3R5cGVzJHNoYWRvd3M7XG4gICAgICAgICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgICAgICBiYXNpYzogVEhSRUUuQmFzaWNTaGFkb3dNYXAsXG4gICAgICAgICAgICBwZXJjZW50YWdlOiBUSFJFRS5QQ0ZTaGFkb3dNYXAsXG4gICAgICAgICAgICBzb2Z0OiBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwLFxuICAgICAgICAgICAgdmFyaWFuY2U6IFRIUkVFLlZTTVNoYWRvd01hcFxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2wuc2hhZG93TWFwLnR5cGUgPSAoX3R5cGVzJHNoYWRvd3MgPSB0eXBlc1tzaGFkb3dzXSkgIT0gbnVsbCA/IF90eXBlcyRzaGFkb3dzIDogVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5vYmooc2hhZG93cykpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGdsLnNoYWRvd01hcCwgc2hhZG93cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZEVuYWJsZWQgIT09IGdsLnNoYWRvd01hcC5lbmFibGVkIHx8IG9sZFR5cGUgIT09IGdsLnNoYWRvd01hcC50eXBlKSBnbC5zaGFkb3dNYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgVEhSRUUuQ29sb3JNYW5hZ2VtZW50LmVuYWJsZWQgPSAhbGVnYWN5O1xuXG4gICAgICAvLyBTZXQgY29sb3Igc3BhY2UgYW5kIHRvbmVtYXBwaW5nIHByZWZlcmVuY2VzXG4gICAgICBpZiAoIWNvbmZpZ3VyZWQpIHtcbiAgICAgICAgZ2wub3V0cHV0Q29sb3JTcGFjZSA9IGxpbmVhciA/IFRIUkVFLkxpbmVhclNSR0JDb2xvclNwYWNlIDogVEhSRUUuU1JHQkNvbG9yU3BhY2U7XG4gICAgICAgIGdsLnRvbmVNYXBwaW5nID0gZmxhdCA/IFRIUkVFLk5vVG9uZU1hcHBpbmcgOiBUSFJFRS5BQ0VTRmlsbWljVG9uZU1hcHBpbmc7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2xvciBtYW5hZ2VtZW50IHN0YXRlXG4gICAgICBpZiAoc3RhdGUubGVnYWN5ICE9PSBsZWdhY3kpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBsZWdhY3lcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdGF0ZS5saW5lYXIgIT09IGxpbmVhcikgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGxpbmVhclxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YXRlLmZsYXQgIT09IGZsYXQpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBmbGF0XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCBnbCBwcm9wc1xuICAgICAgaWYgKGdsQ29uZmlnICYmICFpcy5mdW4oZ2xDb25maWcpICYmICFpc1JlbmRlcmVyKGdsQ29uZmlnKSAmJiAhaXMuZXF1KGdsQ29uZmlnLCBnbCwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhnbCwgZ2xDb25maWcpO1xuXG4gICAgICAvLyBTZXQgbG9jYWxzXG4gICAgICBvbkNyZWF0ZWQgPSBvbkNyZWF0ZWRDYWxsYmFjaztcbiAgICAgIGNvbmZpZ3VyZWQgPSB0cnVlO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW5kZXIoY2hpbGRyZW4pIHtcbiAgICAgIC8vIFRoZSByb290IGhhcyB0byBiZSBjb25maWd1cmVkIGJlZm9yZSBpdCBjYW4gYmUgcmVuZGVyZWRcbiAgICAgIGlmICghY29uZmlndXJlZCAmJiAhcGVuZGluZykgdGhpcy5jb25maWd1cmUoKTtcbiAgICAgIHBlbmRpbmcudGhlbigoKSA9PiB7XG4gICAgICAgIHJlY29uY2lsZXIudXBkYXRlQ29udGFpbmVyKCAvKiNfX1BVUkVfXyovanN4KFByb3ZpZGVyLCB7XG4gICAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZCxcbiAgICAgICAgICByb290RWxlbWVudDogY2FudmFzXG4gICAgICAgIH0pLCBmaWJlciwgbnVsbCwgKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH0sXG4gICAgdW5tb3VudCgpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBQcm92aWRlcih7XG4gIHN0b3JlLFxuICBjaGlsZHJlbixcbiAgb25DcmVhdGVkLFxuICByb290RWxlbWVudFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gRmxhZyB0aGUgY2FudmFzIGFjdGl2ZSwgcmVuZGVyaW5nIHdpbGwgbm93IGJlZ2luXG4gICAgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcm5hbCxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSkpO1xuICAgIC8vIE5vdGlmeSB0aGF0IGluaXQgaXMgY29tcGxldGVkLCB0aGUgc2NlbmUgZ3JhcGggZXhpc3RzLCBidXQgbm90aGluZyBoYXMgeWV0IHJlbmRlcmVkXG4gICAgaWYgKG9uQ3JlYXRlZCkgb25DcmVhdGVkKHN0YXRlKTtcbiAgICAvLyBDb25uZWN0IGV2ZW50cyB0byB0aGUgdGFyZ2V0cyBwYXJlbnQsIHRoaXMgaXMgZG9uZSB0byBlbnN1cmUgZXZlbnRzIGFyZSByZWdpc3RlcmVkIG9uXG4gICAgLy8gYSBzaGFyZWQgdGFyZ2V0LCBhbmQgbm90IG9uIHRoZSBjYW52YXMgaXRzZWxmXG4gICAgaWYgKCFzdG9yZS5nZXRTdGF0ZSgpLmV2ZW50cy5jb25uZWN0ZWQpIHN0YXRlLmV2ZW50cy5jb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29ubmVjdChyb290RWxlbWVudCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RvcmUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb3QgPSBfcm9vdHMuZ2V0KGNhbnZhcyk7XG4gIGNvbnN0IGZpYmVyID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5maWJlcjtcbiAgaWYgKGZpYmVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LnN0b3JlLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlKSBzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgPSBmYWxzZTtcbiAgICByZWNvbmNpbGVyLnVwZGF0ZUNvbnRhaW5lcihudWxsLCBmaWJlciwgbnVsbCwgKCkgPT4ge1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX3N0YXRlJGdsLCBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMsIF9zdGF0ZSRnbDIsIF9zdGF0ZSRnbDM7XG4gICAgICAgICAgICBzdGF0ZS5ldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIChfc3RhdGUkZ2wgPSBzdGF0ZS5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IChfc3RhdGUkZ2wkcmVuZGVyTGlzdHMgPSBfc3RhdGUkZ2wucmVuZGVyTGlzdHMpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMuZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsJHJlbmRlckxpc3RzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIChfc3RhdGUkZ2wyID0gc3RhdGUuZ2wpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wyLmZvcmNlQ29udGV4dExvc3MgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbDIuZm9yY2VDb250ZXh0TG9zcygpO1xuICAgICAgICAgICAgaWYgKChfc3RhdGUkZ2wzID0gc3RhdGUuZ2wpICE9IG51bGwgJiYgX3N0YXRlJGdsMy54cikgc3RhdGUueHIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZGlzcG9zZShzdGF0ZS5zY2VuZSk7XG4gICAgICAgICAgICBfcm9vdHMuZGVsZXRlKGNhbnZhcyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGNhbnZhcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogLi4uICovXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lciwgc3RhdGUpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goUG9ydGFsLCB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFBvcnRhbCh7XG4gIHN0YXRlID0ge30sXG4gIGNoaWxkcmVuLFxuICBjb250YWluZXJcbn0pIHtcbiAgLyoqIFRoaXMgaGFzIHRvIGJlIGEgY29tcG9uZW50IGJlY2F1c2UgaXQgd291bGQgbm90IGJlIGFibGUgdG8gY2FsbCB1c2VUaHJlZS91c2VTdG9yZSBvdGhlcndpc2Ugc2luY2VcclxuICAgKiAgaWYgdGhpcyBpcyBvdXIgZW52aXJvbm1lbnQsIHRoZW4gd2UgYXJlIG5vdCBpbiByM2YncyByZW5kZXJlciBidXQgaW4gcmVhY3QtZG9tLCBpdCB3b3VsZCB0cmlnZ2VyXHJcbiAgICogIHRoZSBcIlIzRiBob29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgQ2FudmFzIGNvbXBvbmVudCFcIiB3YXJuaW5nOlxyXG4gICAqICA8Q2FudmFzPlxyXG4gICAqICAgIHtjcmVhdGVQb3J0YWwoLi4uKX0gKi9cbiAgY29uc3Qge1xuICAgIGV2ZW50cyxcbiAgICBzaXplLFxuICAgIC4uLnJlc3RcbiAgfSA9IHN0YXRlO1xuICBjb25zdCBwcmV2aW91c1Jvb3QgPSB1c2VTdG9yZSgpO1xuICBjb25zdCBbcmF5Y2FzdGVyXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBUSFJFRS5SYXljYXN0ZXIoKSk7XG4gIGNvbnN0IFtwb2ludGVyXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBUSFJFRS5WZWN0b3IyKCkpO1xuICBjb25zdCBpbmplY3QgPSB1c2VNdXRhYmxlQ2FsbGJhY2soKHJvb3RTdGF0ZSwgaW5qZWN0U3RhdGUpID0+IHtcbiAgICBsZXQgdmlld3BvcnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGluamVjdFN0YXRlLmNhbWVyYSAmJiBzaXplKSB7XG4gICAgICBjb25zdCBjYW1lcmEgPSBpbmplY3RTdGF0ZS5jYW1lcmE7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIG92ZXJyaWRlIHZpZXdwb3J0LCBpZiBwcmVzZW50XG4gICAgICB2aWV3cG9ydCA9IHJvb3RTdGF0ZS52aWV3cG9ydC5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBuZXcgVEhSRUUuVmVjdG9yMygpLCBzaXplKTtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcG9ydGFsIGNhbWVyYSwgaWYgaXQgZGlmZmVycyBmcm9tIHRoZSBwcmV2aW91cyBsYXllclxuICAgICAgaWYgKGNhbWVyYSAhPT0gcm9vdFN0YXRlLmNhbWVyYSkgdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAvLyBUaGUgaW50ZXJzZWN0IGNvbnNpc3RzIG9mIHRoZSBwcmV2aW91cyByb290IHN0YXRlXG4gICAgICAuLi5yb290U3RhdGUsXG4gICAgICAuLi5pbmplY3RTdGF0ZSxcbiAgICAgIC8vIFBvcnRhbHMgaGF2ZSB0aGVpciBvd24gc2NlbmUsIHdoaWNoIGZvcm1zIHRoZSByb290LCBhIHJheWNhc3RlciBhbmQgYSBwb2ludGVyXG4gICAgICBzY2VuZTogY29udGFpbmVyLFxuICAgICAgcmF5Y2FzdGVyLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgLy8gVGhlaXIgcHJldmlvdXMgcm9vdCBpcyB0aGUgbGF5ZXIgYmVmb3JlIGl0XG4gICAgICBwcmV2aW91c1Jvb3QsXG4gICAgICAvLyBFdmVudHMsIHNpemUgYW5kIHZpZXdwb3J0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBpbmplY3QgbGF5ZXJcbiAgICAgIGV2ZW50czoge1xuICAgICAgICAuLi5yb290U3RhdGUuZXZlbnRzLFxuICAgICAgICAuLi5pbmplY3RTdGF0ZS5ldmVudHMsXG4gICAgICAgIC4uLmV2ZW50c1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLnNpemUsXG4gICAgICAgIC4uLnNpemVcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICAuLi5yb290U3RhdGUudmlld3BvcnQsXG4gICAgICAgIC4uLnZpZXdwb3J0XG4gICAgICB9LFxuICAgICAgLy8gTGF5ZXJzIGFyZSBhbGxvd2VkIHRvIG92ZXJyaWRlIGV2ZW50c1xuICAgICAgc2V0RXZlbnRzOiBldmVudHMgPT4gaW5qZWN0U3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgLi4uZXZlbnRzXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgIH07XG4gIH0pO1xuICBjb25zdCB1c2VQb3J0YWxTdG9yZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIC8vIENyZWF0ZSBhIG1pcnJvcmVkIHN0b3JlLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgcm9vdCB3aXRoIGEgZmV3IG92ZXJyaWRlcyAuLi5cbiAgICBjb25zdCBzdG9yZSA9IGNyZWF0ZVdpdGhFcXVhbGl0eUZuKChzZXQsIGdldCkgPT4gKHtcbiAgICAgIC4uLnJlc3QsXG4gICAgICBzZXQsXG4gICAgICBnZXRcbiAgICB9KSk7XG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gcHJldmlvdXMgcm9vdC1zdGF0ZSBhbmQgY29weSBjaGFuZ2VzIG92ZXIgdG8gdGhlIG1pcnJvcmVkIHBvcnRhbC1zdGF0ZVxuICAgIGNvbnN0IG9uTXV0YXRlID0gcHJldiA9PiBzdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiBpbmplY3QuY3VycmVudChwcmV2LCBzdGF0ZSkpO1xuICAgIG9uTXV0YXRlKHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpKTtcbiAgICBwcmV2aW91c1Jvb3Quc3Vic2NyaWJlKG9uTXV0YXRlKTtcbiAgICByZXR1cm4gc3RvcmU7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbcHJldmlvdXNSb290LCBjb250YWluZXJdKTtcbiAgcmV0dXJuIChcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgLy8gQHRzLWlnbm9yZSwgcmVjb25jaWxlciB0eXBlcyBhcmUgbm90IG1haW50YWluZWRcbiAgICBqc3goRnJhZ21lbnQsIHtcbiAgICAgIGNoaWxkcmVuOiByZWNvbmNpbGVyLmNyZWF0ZVBvcnRhbCggLyojX19QVVJFX18qL2pzeChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB1c2VQb3J0YWxTdG9yZSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICB9KSwgdXNlUG9ydGFsU3RvcmUsIG51bGwpXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXHJcbiAqIEZvcmNlIFJlYWN0IHRvIGZsdXNoIGFueSB1cGRhdGVzIGluc2lkZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgc3luY2hyb25vdXNseSBhbmQgaW1tZWRpYXRlbHkuXHJcbiAqIEFsbCB0aGUgc2FtZSBjYXZlYXRzIGRvY3VtZW50ZWQgZm9yIHJlYWN0LWRvbSdzIGBmbHVzaFN5bmNgIGFwcGx5IGhlcmUgKHNlZSBodHRwczovL3JlYWN0LmRldi9yZWZlcmVuY2UvcmVhY3QtZG9tL2ZsdXNoU3luYykuXHJcbiAqIE5ldmVydGhlbGVzcywgc29tZXRpbWVzIG9uZSBuZWVkcyB0byByZW5kZXIgc3luY2hyb25vdXNseSwgZm9yIGV4YW1wbGUgdG8ga2VlcCBET00gYW5kIDNEIGNoYW5nZXMgaW4gbG9jay1zdGVwIHdpdGhvdXRcclxuICogaGF2aW5nIHRvIHJldmVydCB0byBhIG5vbi1SZWFjdCBzb2x1dGlvbi4gTm90ZTogdGhpcyB3aWxsIG9ubHkgZmx1c2ggdXBkYXRlcyB3aXRoaW4gdGhlIGBDYW52YXNgIHJvb3QuXHJcbiAqL1xuZnVuY3Rpb24gZmx1c2hTeW5jKGZuKSB7XG4gIC8vIEB0cy1pZ25vcmUgLSByZWNvbmNpbGVyIHR5cGVzIGFyZSBub3QgbWFpbnRhaW5lZFxuICByZXR1cm4gcmVjb25jaWxlci5mbHVzaFN5bmNGcm9tUmVjb25jaWxlcihmbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YnMoY2FsbGJhY2ssIHN1YnMpIHtcbiAgY29uc3Qgc3ViID0ge1xuICAgIGNhbGxiYWNrXG4gIH07XG4gIHN1YnMuYWRkKHN1Yik7XG4gIHJldHVybiAoKSA9PiB2b2lkIHN1YnMuZGVsZXRlKHN1Yik7XG59XG5jb25zdCBnbG9iYWxFZmZlY3RzID0gbmV3IFNldCgpO1xuY29uc3QgZ2xvYmFsQWZ0ZXJFZmZlY3RzID0gbmV3IFNldCgpO1xuY29uc3QgZ2xvYmFsVGFpbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5cbi8qKlxyXG4gKiBBZGRzIGEgZ2xvYmFsIHJlbmRlciBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgZWFjaCBmcmFtZS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZEVmZmVjdFxyXG4gKi9cbmNvbnN0IGFkZEVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEVmZmVjdHMpO1xuXG4vKipcclxuICogQWRkcyBhIGdsb2JhbCBhZnRlci1yZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRBZnRlckVmZmVjdFxyXG4gKi9cbmNvbnN0IGFkZEFmdGVyRWZmZWN0ID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsQWZ0ZXJFZmZlY3RzKTtcblxuLyoqXHJcbiAqIEFkZHMgYSBnbG9iYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gcmVuZGVyaW5nIHN0b3BzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkVGFpbFxyXG4gKi9cbmNvbnN0IGFkZFRhaWwgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxUYWlsRWZmZWN0cyk7XG5mdW5jdGlvbiBydW4oZWZmZWN0cywgdGltZXN0YW1wKSB7XG4gIGlmICghZWZmZWN0cy5zaXplKSByZXR1cm47XG4gIGZvciAoY29uc3Qge1xuICAgIGNhbGxiYWNrXG4gIH0gb2YgZWZmZWN0cy52YWx1ZXMoKSkge1xuICAgIGNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoR2xvYmFsRWZmZWN0cyh0eXBlLCB0aW1lc3RhbXApIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICdhZnRlcic6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEFmdGVyRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICd0YWlsJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsVGFpbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gIH1cbn1cbmxldCBzdWJzY3JpYmVycztcbmxldCBzdWJzY3JpcHRpb247XG5mdW5jdGlvbiB1cGRhdGUodGltZXN0YW1wLCBzdGF0ZSwgZnJhbWUpIHtcbiAgLy8gUnVuIGxvY2FsIGVmZmVjdHNcbiAgbGV0IGRlbHRhID0gc3RhdGUuY2xvY2suZ2V0RGVsdGEoKTtcblxuICAvLyBJbiBmcmFtZWxvb3A9J25ldmVyJyBtb2RlLCBjbG9jayB0aW1lcyBhcmUgdXBkYXRlZCB1c2luZyB0aGUgcHJvdmlkZWQgdGltZXN0YW1wXG4gIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicgJiYgdHlwZW9mIHRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICBkZWx0YSA9IHRpbWVzdGFtcCAtIHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lO1xuICAgIHN0YXRlLmNsb2NrLm9sZFRpbWUgPSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZSA9IHRpbWVzdGFtcDtcbiAgfVxuXG4gIC8vIENhbGwgc3Vic2NyaWJlcnMgKHVzZUZyYW1lKVxuICBzdWJzY3JpYmVycyA9IHN0YXRlLmludGVybmFsLnN1YnNjcmliZXJzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlcnNbaV07XG4gICAgc3Vic2NyaXB0aW9uLnJlZi5jdXJyZW50KHN1YnNjcmlwdGlvbi5zdG9yZS5nZXRTdGF0ZSgpLCBkZWx0YSwgZnJhbWUpO1xuICB9XG5cbiAgLy8gUmVuZGVyIGNvbnRlbnRcbiAgaWYgKCFzdGF0ZS5pbnRlcm5hbC5wcmlvcml0eSAmJiBzdGF0ZS5nbC5yZW5kZXIpIHN0YXRlLmdsLnJlbmRlcihzdGF0ZS5zY2VuZSwgc3RhdGUuY2FtZXJhKTtcblxuICAvLyBEZWNyZWFzZSBmcmFtZSBjb3VudFxuICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1heCgwLCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgLSAxKTtcbiAgcmV0dXJuIHN0YXRlLmZyYW1lbG9vcCA9PT0gJ2Fsd2F5cycgPyAxIDogc3RhdGUuaW50ZXJuYWwuZnJhbWVzO1xufVxubGV0IHJ1bm5pbmcgPSBmYWxzZTtcbmxldCB1c2VGcmFtZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbmxldCByZXBlYXQ7XG5sZXQgZnJhbWU7XG5sZXQgc3RhdGU7XG5mdW5jdGlvbiBsb29wKHRpbWVzdGFtcCkge1xuICBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgcnVubmluZyA9IHRydWU7XG4gIHJlcGVhdCA9IDA7XG5cbiAgLy8gUnVuIGVmZmVjdHNcbiAgZmx1c2hHbG9iYWxFZmZlY3RzKCdiZWZvcmUnLCB0aW1lc3RhbXApO1xuXG4gIC8vIFJlbmRlciBhbGwgcm9vdHNcbiAgdXNlRnJhbWVJblByb2dyZXNzID0gdHJ1ZTtcbiAgZm9yIChjb25zdCByb290IG9mIF9yb290cy52YWx1ZXMoKSkge1xuICAgIHZhciBfc3RhdGUkZ2wkeHI7XG4gICAgc3RhdGUgPSByb290LnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBJZiB0aGUgZnJhbWVsb29wIGlzIGludmFsaWRhdGVkLCBkbyBub3QgcnVuIGFub3RoZXIgZnJhbWVcbiAgICBpZiAoc3RhdGUuaW50ZXJuYWwuYWN0aXZlICYmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICdhbHdheXMnIHx8IHN0YXRlLmludGVybmFsLmZyYW1lcyA+IDApICYmICEoKF9zdGF0ZSRnbCR4ciA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4ci5pc1ByZXNlbnRpbmcpKSB7XG4gICAgICByZXBlYXQgKz0gdXBkYXRlKHRpbWVzdGFtcCwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICB1c2VGcmFtZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAvLyBSdW4gYWZ0ZXItZWZmZWN0c1xuICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2FmdGVyJywgdGltZXN0YW1wKTtcblxuICAvLyBTdG9wIHRoZSBsb29wIGlmIG5vdGhpbmcgaW52YWxpZGF0ZXMgaXRcbiAgaWYgKHJlcGVhdCA9PT0gMCkge1xuICAgIC8vIFRhaWwgY2FsbCBlZmZlY3RzLCB0aGV5IGFyZSBjYWxsZWQgd2hlbiByZW5kZXJpbmcgc3RvcHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ3RhaWwnLCB0aW1lc3RhbXApO1xuXG4gICAgLy8gRmxhZyBlbmQgb2Ygb3BlcmF0aW9uXG4gICAgcnVubmluZyA9IGZhbHNlO1xuICAgIHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIEludmFsaWRhdGVzIHRoZSB2aWV3LCByZXF1ZXN0aW5nIGEgZnJhbWUgdG8gYmUgcmVuZGVyZWQuIFdpbGwgZ2xvYmFsbHkgaW52YWxpZGF0ZSB1bmxlc3MgcGFzc2VkIGEgcm9vdCdzIHN0YXRlLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjaW52YWxpZGF0ZVxyXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRhdGUoc3RhdGUsIGZyYW1lcyA9IDEpIHtcbiAgdmFyIF9zdGF0ZSRnbCR4cjI7XG4gIGlmICghc3RhdGUpIHJldHVybiBfcm9vdHMuZm9yRWFjaChyb290ID0+IGludmFsaWRhdGUocm9vdC5zdG9yZS5nZXRTdGF0ZSgpLCBmcmFtZXMpKTtcbiAgaWYgKChfc3RhdGUkZ2wkeHIyID0gc3RhdGUuZ2wueHIpICE9IG51bGwgJiYgX3N0YXRlJGdsJHhyMi5pc1ByZXNlbnRpbmcgfHwgIXN0YXRlLmludGVybmFsLmFjdGl2ZSB8fCBzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicpIHJldHVybjtcbiAgaWYgKGZyYW1lcyA+IDEpIHtcbiAgICAvLyBsZWdhY3kgc3VwcG9ydCBmb3IgcGVvcGxlIHVzaW5nIGZyYW1lcyBwYXJhbWV0ZXJzXG4gICAgLy8gSW5jcmVhc2UgZnJhbWVzLCBkbyBub3QgZ28gaGlnaGVyIHRoYW4gNjBcbiAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1pbig2MCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzICsgZnJhbWVzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodXNlRnJhbWVJblByb2dyZXNzKSB7XG4gICAgICAvL2NhbGxlZCBmcm9tIHdpdGhpbiBhIHVzZUZyYW1lLCBpdCBtZWFucyB0aGUgdXNlciB3YW50cyBhbiBhZGRpdGlvbmFsIGZyYW1lXG4gICAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL3RoZSB1c2VyIG5lZWQgYSBuZXcgZnJhbWUsIG5vIG5lZWQgdG8gaW5jcmVtZW50IGZ1cnRoZXIgdGhhbiAxXG4gICAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSByZW5kZXItbG9vcCBpc24ndCBhY3RpdmUsIHN0YXJ0IGl0XG4gIGlmICghcnVubmluZykge1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgfVxufVxuXG4vKipcclxuICogQWR2YW5jZXMgdGhlIGZyYW1lbG9vcCBhbmQgcnVucyByZW5kZXIgZWZmZWN0cywgdXNlZnVsIGZvciB3aGVuIG1hbnVhbGx5IHJlbmRlcmluZyB2aWEgYGZyYW1lbG9vcD1cIm5ldmVyXCJgLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWR2YW5jZVxyXG4gKi9cbmZ1bmN0aW9uIGFkdmFuY2UodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzID0gdHJ1ZSwgc3RhdGUsIGZyYW1lKSB7XG4gIGlmIChydW5HbG9iYWxFZmZlY3RzKSBmbHVzaEdsb2JhbEVmZmVjdHMoJ2JlZm9yZScsIHRpbWVzdGFtcCk7XG4gIGlmICghc3RhdGUpIGZvciAoY29uc3Qgcm9vdCBvZiBfcm9vdHMudmFsdWVzKCkpIHVwZGF0ZSh0aW1lc3RhbXAsIHJvb3Quc3RvcmUuZ2V0U3RhdGUoKSk7ZWxzZSB1cGRhdGUodGltZXN0YW1wLCBzdGF0ZSwgZnJhbWUpO1xuICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG59XG5cbmNvbnN0IERPTV9FVkVOVFMgPSB7XG4gIG9uQ2xpY2s6IFsnY2xpY2snLCBmYWxzZV0sXG4gIG9uQ29udGV4dE1lbnU6IFsnY29udGV4dG1lbnUnLCBmYWxzZV0sXG4gIG9uRG91YmxlQ2xpY2s6IFsnZGJsY2xpY2snLCBmYWxzZV0sXG4gIG9uV2hlZWw6IFsnd2hlZWwnLCB0cnVlXSxcbiAgb25Qb2ludGVyRG93bjogWydwb2ludGVyZG93bicsIHRydWVdLFxuICBvblBvaW50ZXJVcDogWydwb2ludGVydXAnLCB0cnVlXSxcbiAgb25Qb2ludGVyTGVhdmU6IFsncG9pbnRlcmxlYXZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlck1vdmU6IFsncG9pbnRlcm1vdmUnLCB0cnVlXSxcbiAgb25Qb2ludGVyQ2FuY2VsOiBbJ3BvaW50ZXJjYW5jZWwnLCB0cnVlXSxcbiAgb25Mb3N0UG9pbnRlckNhcHR1cmU6IFsnbG9zdHBvaW50ZXJjYXB0dXJlJywgdHJ1ZV1cbn07XG5cbi8qKiBEZWZhdWx0IFIzRiBldmVudCBtYW5hZ2VyIGZvciB3ZWIgKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50ZXJFdmVudHMoc3RvcmUpIHtcbiAgY29uc3Qge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfSA9IGNyZWF0ZUV2ZW50cyhzdG9yZSk7XG4gIHJldHVybiB7XG4gICAgcHJpb3JpdHk6IDEsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBjb21wdXRlKGV2ZW50LCBzdGF0ZSwgcHJldmlvdXMpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC83ODJcbiAgICAgIC8vIEV2ZW50cyB0cmlnZ2VyIG91dHNpZGUgb2YgY2FudmFzIHdoZW4gbW92ZWQsIHVzZSBvZmZzZXRYL1kgYnkgZGVmYXVsdCBhbmQgYWxsb3cgb3ZlcnJpZGVzXG4gICAgICBzdGF0ZS5wb2ludGVyLnNldChldmVudC5vZmZzZXRYIC8gc3RhdGUuc2l6ZS53aWR0aCAqIDIgLSAxLCAtKGV2ZW50Lm9mZnNldFkgLyBzdGF0ZS5zaXplLmhlaWdodCkgKiAyICsgMSk7XG4gICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgIH0sXG4gICAgY29ubmVjdGVkOiB1bmRlZmluZWQsXG4gICAgaGFuZGxlcnM6IE9iamVjdC5rZXlzKERPTV9FVkVOVFMpLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2MsXG4gICAgICBba2V5XTogaGFuZGxlUG9pbnRlcihrZXkpXG4gICAgfSksIHt9KSxcbiAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgIHZhciBfaW50ZXJuYWwkbGFzdEV2ZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBldmVudHMsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmICgoX2ludGVybmFsJGxhc3RFdmVudCA9IGludGVybmFsLmxhc3RFdmVudCkgIT0gbnVsbCAmJiBfaW50ZXJuYWwkbGFzdEV2ZW50LmN1cnJlbnQgJiYgZXZlbnRzLmhhbmRsZXJzKSBldmVudHMuaGFuZGxlcnMub25Qb2ludGVyTW92ZShpbnRlcm5hbC5sYXN0RXZlbnQuY3VycmVudCk7XG4gICAgfSxcbiAgICBjb25uZWN0OiB0YXJnZXQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgY29ubmVjdGVkOiB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgaWYgKGV2ZW50cy5oYW5kbGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZXZlbnRzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHMuaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgY29uc3QgW2V2ZW50TmFtZSwgcGFzc2l2ZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQsIHtcbiAgICAgICAgICAgIHBhc3NpdmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoZXZlbnRzLmNvbm5lY3RlZCkge1xuICAgICAgICBpZiAoZXZlbnRzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGV2ZW50cy5oYW5kbGVycykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHMuaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgICBjb25zdCBbZXZlbnROYW1lXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgICAgICBldmVudHMuY29ubmVjdGVkLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgICAgY29ubmVjdGVkOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IHVzZVN0b3JlIGFzIEEsIEJsb2NrIGFzIEIsIHVzZVRocmVlIGFzIEMsIHVzZUZyYW1lIGFzIEQsIEVycm9yQm91bmRhcnkgYXMgRSwgdXNlR3JhcGggYXMgRiwgdXNlTG9hZGVyIGFzIEcsIF9yb290cyBhcyBfLCB1c2VNdXRhYmxlQ2FsbGJhY2sgYXMgYSwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBhcyBiLCBjcmVhdGVSb290IGFzIGMsIHVubW91bnRDb21wb25lbnRBdE5vZGUgYXMgZCwgZXh0ZW5kIGFzIGUsIGNyZWF0ZVBvaW50ZXJFdmVudHMgYXMgZiwgY3JlYXRlRXZlbnRzIGFzIGcsIGZsdXNoR2xvYmFsRWZmZWN0cyBhcyBoLCBpc1JlZiBhcyBpLCBhZGRFZmZlY3QgYXMgaiwgYWRkQWZ0ZXJFZmZlY3QgYXMgaywgYWRkVGFpbCBhcyBsLCBpbnZhbGlkYXRlIGFzIG0sIGFkdmFuY2UgYXMgbiwgY3JlYXRlUG9ydGFsIGFzIG8sIGZsdXNoU3luYyBhcyBwLCBjb250ZXh0IGFzIHEsIHJlY29uY2lsZXIgYXMgciwgYXBwbHlQcm9wcyBhcyBzLCB0aHJlZVR5cGVzIGFzIHQsIHVzZUJyaWRnZSBhcyB1LCBnZXRSb290U3RhdGUgYXMgdiwgZGlzcG9zZSBhcyB3LCBhY3QgYXMgeCwgYnVpbGRHcmFwaCBhcyB5LCB1c2VJbnN0YW5jZUhhbmRsZSBhcyB6IH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJEZWZhdWx0RXZlbnRQcmlvcml0eSIsIkNvbnRpbnVvdXNFdmVudFByaW9yaXR5IiwiRGlzY3JldGVFdmVudFByaW9yaXR5IiwiQ29uY3VycmVudFJvb3QiLCJUSFJFRSIsImNyZWF0ZVdpdGhFcXVhbGl0eUZuIiwic3VzcGVuZCIsInByZWxvYWQiLCJjbGVhciIsIlJlY29uY2lsZXIiLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwidW5zdGFibGVfSWRsZVByaW9yaXR5IiwianN4IiwiRnJhZ21lbnQiLCJ1c2VGaWJlciIsInVzZUNvbnRleHRCcmlkZ2UiLCJ0cmF2ZXJzZUZpYmVyIiwidGhyZWVUeXBlcyIsIk9iamVjdCIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImZpbmRJbml0aWFsUm9vdCIsImluc3RhbmNlIiwicm9vdCIsImdldFN0YXRlIiwicHJldmlvdXNSb290IiwiYWN0IiwiaXNPcnRob2dyYXBoaWNDYW1lcmEiLCJkZWYiLCJpc1JlZiIsIm9iaiIsImhhc093blByb3BlcnR5IiwiaXNDb2xvclJlcHJlc2VudGF0aW9uIiwidmFsdWUiLCJpc0NvbG9yIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIl93aW5kb3ckZG9jdW1lbnQiLCJfd2luZG93JG5hdmlnYXRvciIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VNdXRhYmxlQ2FsbGJhY2siLCJmbiIsInJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJ1c2VCcmlkZ2UiLCJmaWJlciIsIkNvbnRleHRCcmlkZ2UiLCJ1c2VNZW1vIiwiY2hpbGRyZW4iLCJzdHJpY3QiLCJub2RlIiwidHlwZSIsIlN0cmljdE1vZGUiLCJSb290IiwiQmxvY2siLCJzZXQiLCJQcm9taXNlIiwiRXJyb3JCb3VuZGFyeSIsIl9FcnJvckJvdW5kYXJ5IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJhcmdzIiwic3RhdGUiLCJlcnJvciIsImNvbXBvbmVudERpZENhdGNoIiwiZXJyIiwicHJvcHMiLCJyZW5kZXIiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJjYWxjdWxhdGVEcHIiLCJkcHIiLCJfd2luZG93JGRldmljZVBpeGVsUmEiLCJ0YXJnZXQiLCJkZXZpY2VQaXhlbFJhdGlvIiwiQXJyYXkiLCJpc0FycmF5IiwiTWF0aCIsIm1pbiIsIm1heCIsImdldFJvb3RTdGF0ZSIsIl9yM2YiLCJfX3IzZiIsImlzIiwiYSIsImFyciIsImZ1biIsInN0ciIsIm51bSIsImJvbyIsInVuZCIsIm51bCIsImVxdSIsImIiLCJhcnJheXMiLCJvYmplY3RzIiwiaXNPYmoiLCJpc0FyciIsImkiLCJsZW5ndGgiLCJrZXlzIiwiYnVpbGRHcmFwaCIsIm9iamVjdCIsImRhdGEiLCJub2RlcyIsIm1hdGVyaWFscyIsIm1lc2hlcyIsInRyYXZlcnNlIiwibmFtZSIsIm1hdGVyaWFsIiwiaXNNZXNoIiwiZGlzcG9zZSIsInAiLCJwcm9wIiwiUkVBQ1RfSU5URVJOQUxfUFJPUFMiLCJnZXRJbnN0YW5jZVByb3BzIiwicXVldWUiLCJrZXkiLCJpbmNsdWRlcyIsInByZXBhcmUiLCJwYXJlbnQiLCJldmVudENvdW50IiwiaGFuZGxlcnMiLCJpc0hpZGRlbiIsInJlc29sdmUiLCJwYXJ0Iiwic3BsaXQiLCJfdGFyZ2V0IiwiSU5ERVhfUkVHRVgiLCJhdHRhY2giLCJjaGlsZCIsInRlc3QiLCJpbmRleCIsInJlcGxhY2UiLCJwcmV2aW91c0F0dGFjaCIsImRldGFjaCIsInByZXZpb3VzIiwidW5kZWZpbmVkIiwiUkVTRVJWRURfUFJPUFMiLCJNRU1PSVpFRF9QUk9UT1RZUEVTIiwiTWFwIiwiZ2V0TWVtb2l6ZWRQcm90b3R5cGUiLCJjdG9yIiwiZ2V0IiwiZSIsImRpZmZQcm9wcyIsIm5ld1Byb3BzIiwiY2hhbmdlZFByb3BzIiwib3RoZXIiLCJzdGFydHNXaXRoIiwiY29sb3JNYXBzIiwiRVZFTlRfUkVHRVgiLCJhcHBseVByb3BzIiwiX2luc3RhbmNlJG9iamVjdCIsInJvb3RTdGF0ZSIsInByZXZIYW5kbGVycyIsIkxheWVycyIsIm1hc2siLCJDb2xvciIsImNvcHkiLCJmcm9tQXJyYXkiLCJzZXRTY2FsYXIiLCJfcm9vdCRrZXkiLCJsaW5lYXIiLCJpc1RleHR1cmUiLCJmb3JtYXQiLCJSR0JBRm9ybWF0IiwiVW5zaWduZWRCeXRlVHlwZSIsImNvbG9yU3BhY2UiLCJTUkdCQ29sb3JTcGFjZSIsImludGVybmFsIiwiaXNPYmplY3QzRCIsImludGVyYWN0aW9uIiwiaW5kZXhPZiIsInNwbGljZSIsInJheWNhc3QiLCJwdXNoIiwiaXNCdWZmZXJHZW9tZXRyeSIsImlzTWF0ZXJpYWwiLCJpbnZhbGlkYXRlSW5zdGFuY2UiLCJfaW5zdGFuY2Ukcm9vdCIsIm9uVXBkYXRlIiwiZnJhbWVzIiwiaW52YWxpZGF0ZSIsInVwZGF0ZUNhbWVyYSIsImNhbWVyYSIsInNpemUiLCJtYW51YWwiLCJsZWZ0Iiwid2lkdGgiLCJyaWdodCIsInRvcCIsImhlaWdodCIsImJvdHRvbSIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJtYWtlSWQiLCJldmVudCIsImV2ZW50T2JqZWN0IiwidXVpZCIsImluc3RhbmNlSWQiLCJyZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZSIsImNhcHR1cmVkTWFwIiwiY2FwdHVyZXMiLCJwb2ludGVySWQiLCJjYXB0dXJlRGF0YSIsImRlbGV0ZSIsInJlbGVhc2VQb2ludGVyQ2FwdHVyZSIsInJlbW92ZUludGVyYWN0aXZpdHkiLCJzdG9yZSIsImZpbHRlciIsIm8iLCJpbml0aWFsSGl0cyIsImhvdmVyZWQiLCJmb3JFYWNoIiwiY3JlYXRlRXZlbnRzIiwiY2FsY3VsYXRlRGlzdGFuY2UiLCJkeCIsIm9mZnNldFgiLCJpbml0aWFsQ2xpY2siLCJkeSIsIm9mZnNldFkiLCJyb3VuZCIsInNxcnQiLCJmaWx0ZXJQb2ludGVyRXZlbnRzIiwic29tZSIsImludGVyc2VjdCIsImR1cGxpY2F0ZXMiLCJTZXQiLCJpbnRlcnNlY3Rpb25zIiwiZXZlbnRzT2JqZWN0cyIsInJheWNhc3RlciIsImV2ZW50cyIsImNvbXB1dGUiLCJoYW5kbGVSYXljYXN0IiwiZW5hYmxlZCIsIl9zdGF0ZSRwcmV2aW91c1Jvb3QiLCJpbnRlcnNlY3RPYmplY3QiLCJoaXRzIiwiZmxhdE1hcCIsInNvcnQiLCJhU3RhdGUiLCJiU3RhdGUiLCJkaXN0YW5jZSIsInByaW9yaXR5IiwiaXRlbSIsImlkIiwiaGFzIiwiYWRkIiwiaGl0IiwiX3IzZjIiLCJ2YWx1ZXMiLCJpbnRlcnNlY3Rpb24iLCJoYW5kbGVJbnRlcnNlY3RzIiwiZGVsdGEiLCJjYWxsYmFjayIsImxvY2FsU3RhdGUiLCJzdG9wcGVkIiwidHJhdmVyc2VBbmNlc3RvcnMiLCJwYXJlbnRTdGF0ZSIsInBvaW50ZXIiLCJ1bnByb2plY3RlZFBvaW50IiwiVmVjdG9yMyIsIngiLCJ5IiwidW5wcm9qZWN0IiwiaGFzUG9pbnRlckNhcHR1cmUiLCJfaW50ZXJuYWwkY2FwdHVyZWRNYXAiLCJfaW50ZXJuYWwkY2FwdHVyZWRNYXAyIiwic2V0UG9pbnRlckNhcHR1cmUiLCJleHRyYWN0RXZlbnRQcm9wcyIsInByb3BlcnR5IiwicmF5Y2FzdEV2ZW50IiwicmF5Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FwdHVyZXNGb3JQb2ludGVyIiwiZnJvbSIsImZpbmQiLCJoaWdoZXIiLCJzbGljZSIsImNhbmNlbFBvaW50ZXIiLCJjdXJyZW50VGFyZ2V0IiwibmF0aXZlRXZlbnQiLCJob3ZlcmVkT2JqIiwib25Qb2ludGVyT3V0Iiwib25Qb2ludGVyTGVhdmUiLCJwb2ludGVyTWlzc2VkIiwib25Qb2ludGVyTWlzc2VkIiwiaGFuZGxlUG9pbnRlciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImhhbmRsZUV2ZW50IiwibGFzdEV2ZW50IiwiaXNQb2ludGVyTW92ZSIsImlzQ2xpY2tFdmVudCIsIm1hcCIsIm9uSW50ZXJzZWN0Iiwib25Qb2ludGVyT3ZlciIsIm9uUG9pbnRlckVudGVyIiwiaG92ZXJlZEl0ZW0iLCJvblBvaW50ZXJNb3ZlIiwiaGFuZGxlciIsImlzUmVuZGVyZXIiLCJjb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImNyZWF0ZVN0b3JlIiwiYWR2YW5jZSIsInJvb3RTdG9yZSIsInBvc2l0aW9uIiwiZGVmYXVsdFRhcmdldCIsInRlbXBUYXJnZXQiLCJnZXRDdXJyZW50Vmlld3BvcnQiLCJpc1ZlY3RvcjMiLCJnZXRXb3JsZFBvc2l0aW9uIiwiZGlzdGFuY2VUbyIsInpvb20iLCJmYWN0b3IiLCJmb3YiLCJQSSIsImgiLCJ0YW4iLCJ3IiwicGVyZm9ybWFuY2VUaW1lb3V0Iiwic2V0UGVyZm9ybWFuY2VDdXJyZW50IiwicGVyZm9ybWFuY2UiLCJWZWN0b3IyIiwiZ2wiLCJjb25uZWN0ZWQiLCJzY2VuZSIsInhyIiwidGltZXN0YW1wIiwicnVuR2xvYmFsRWZmZWN0cyIsImxlZ2FjeSIsImZsYXQiLCJjb250cm9scyIsImNsb2NrIiwiQ2xvY2siLCJtb3VzZSIsImZyYW1lbG9vcCIsImRlYm91bmNlIiwicmVncmVzcyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJ2aWV3cG9ydCIsImluaXRpYWxEcHIiLCJzZXRFdmVudHMiLCJzZXRTaXplIiwic2V0RHByIiwicmVzb2x2ZWQiLCJzZXRGcmFtZWxvb3AiLCJzdG9wIiwiZWxhcHNlZFRpbWUiLCJzdGFydCIsInN1YnNjcmliZXJzIiwiY3JlYXRlUmVmIiwiYWN0aXZlIiwic3Vic2NyaWJlIiwicyIsIm9sZFNpemUiLCJvbGREcHIiLCJvbGRDYW1lcmEiLCJzZXRQaXhlbFJhdGlvIiwidXBkYXRlU3R5bGUiLCJIVE1MQ2FudmFzRWxlbWVudCIsImRvbUVsZW1lbnQiLCJ1c2VJbnN0YW5jZUhhbmRsZSIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VTdG9yZSIsInVzZUNvbnRleHQiLCJFcnJvciIsInVzZVRocmVlIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwidXNlRnJhbWUiLCJyZW5kZXJQcmlvcml0eSIsInVzZUdyYXBoIiwibWVtb2l6ZWRMb2FkZXJzIiwiV2Vha01hcCIsImlzQ29uc3RydWN0b3IkMSIsIl92YWx1ZSRwcm90b3R5cGUiLCJwcm90b3R5cGUiLCJsb2FkaW5nRm4iLCJleHRlbnNpb25zIiwib25Qcm9ncmVzcyIsIlByb3RvIiwiaW5wdXQiLCJsb2FkZXIiLCJhbGwiLCJyZXMiLCJyZWplY3QiLCJsb2FkIiwiYXNzaWduIiwibWVzc2FnZSIsInVzZUxvYWRlciIsInJlc3VsdHMiLCJlcXVhbCIsImNyZWF0ZVJlY29uY2lsZXIiLCJjb25maWciLCJyZWNvbmNpbGVyIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiYnVuZGxlVHlwZSIsInByb2Nlc3MiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwidmVyc2lvbiIsIk5vRXZlbnRQcmlvcml0eSIsImNhdGFsb2d1ZSIsIlBSRUZJWF9SRUdFWCIsInRvUGFzY2FsQ2FzZSIsInRvVXBwZXJDYXNlIiwiaXNDb25zdHJ1Y3RvciIsImV4dGVuZCIsInZhbGlkYXRlSW5zdGFuY2UiLCJjcmVhdGVJbnN0YW5jZSIsIl9wcm9wcyRvYmplY3QiLCJoaWRlSW5zdGFuY2UiLCJfaW5zdGFuY2UkcGFyZW50IiwidmlzaWJsZSIsInVuaGlkZUluc3RhbmNlIiwiX2luc3RhbmNlJHBhcmVudDIiLCJoYW5kbGVDb250YWluZXJFZmZlY3RzIiwiYmVmb3JlQ2hpbGQiLCJfY2hpbGQkcHJvcHMkb2JqZWN0IiwiX2NoaWxkJHByb3BzJGFyZ3MiLCJjaGlsZEluZGV4IiwiZXhpc3RpbmdJbmRleCIsImFkanVzdGVkSW5kZXgiLCJkaXNwYXRjaEV2ZW50IiwiY2hpbGRJbnN0YW5jZSIsImFwcGVuZENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwiZGlzcG9zZU9uSWRsZSIsImhhbmRsZURpc3Bvc2UiLCJJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQiLCJyZW1vdmVDaGlsZCIsInJlbW92ZSIsInNob3VsZERpc3Bvc2UiLCJzZXRGaWJlclJlZiIsInB1YmxpY0luc3RhbmNlIiwiX2ZpYmVyIiwiYWx0ZXJuYXRlIiwicmVmQ2xlYW51cCIsImNsZWFudXAiLCJyZWNvbnN0cnVjdGVkIiwic3dhcEluc3RhbmNlcyIsIl9pbnN0YW5jZSRwcm9wcyRvYmplYyIsIl9pbnN0YW5jZSRwcm9wcyRhcmdzIiwiaGFuZGxlVGV4dEluc3RhbmNlIiwiTk9fQ09OVEVYVCIsImN1cnJlbnRVcGRhdGVQcmlvcml0eSIsIk5vRmxhZ3MiLCJVcGRhdGUiLCJpc1ByaW1hcnlSZW5kZXJlciIsIndhcm5zSWZOb3RBY3RpbmciLCJzdXBwb3J0c011dGF0aW9uIiwic3VwcG9ydHNQZXJzaXN0ZW5jZSIsInN1cHBvcnRzSHlkcmF0aW9uIiwiYXBwZW5kSW5pdGlhbENoaWxkIiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImNvbnRhaW5lciIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsImNvbW1pdFVwZGF0ZSIsIm9sZFByb3BzIiwiX25ld1Byb3BzJGFyZ3MiLCJfb2xkUHJvcHMkYXJncyIsIl9uZXdQcm9wcyRhcmdzMiIsInJlY29uc3RydWN0IiwiX29sZFByb3BzJGFyZ3MyIiwiaXNUYWlsU2libGluZyIsInNpYmxpbmciLCJmbGFncyIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwiY29tbWl0TW91bnQiLCJnZXRQdWJsaWNJbnN0YW5jZSIsInByZXBhcmVGb3JDb21taXQiLCJwcmVwYXJlUG9ydGFsTW91bnQiLCJyZXNldEFmdGVyQ29tbWl0Iiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJjbGVhckNvbnRhaW5lciIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImhpZGVUZXh0SW5zdGFuY2UiLCJ1bmhpZGVUZXh0SW5zdGFuY2UiLCJzY2hlZHVsZVRpbWVvdXQiLCJjYW5jZWxUaW1lb3V0Iiwibm9UaW1lb3V0IiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ciIsImFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwiZGV0YWNoRGVsZXRlZEluc3RhbmNlIiwicHJlcGFyZVNjb3BlVXBkYXRlIiwiZ2V0SW5zdGFuY2VGcm9tU2NvcGUiLCJzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uIiwidHJhY2tTY2hlZHVsZXJFdmVudCIsInJlc29sdmVFdmVudFR5cGUiLCJyZXNvbHZlRXZlbnRUaW1lU3RhbXAiLCJyZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2siLCJtYXlTdXNwZW5kQ29tbWl0IiwicHJlbG9hZEluc3RhbmNlIiwic3RhcnRTdXNwZW5kaW5nQ29tbWl0Iiwic3VzcGVuZEluc3RhbmNlIiwid2FpdEZvckNvbW1pdFRvQmVSZWFkeSIsIk5vdFBlbmRpbmdUcmFuc2l0aW9uIiwiSG9zdFRyYW5zaXRpb25Db250ZXh0Iiwic2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5IiwibmV3UHJpb3JpdHkiLCJnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJyZXNvbHZlVXBkYXRlUHJpb3JpdHkiLCJfd2luZG93JGV2ZW50IiwicmVzZXRGb3JtSW5zdGFuY2UiLCJfcm9vdHMiLCJzaGFsbG93TG9vc2UiLCJjb21wdXRlSW5pdGlhbFNpemUiLCJjYW52YXMiLCJwYXJlbnRFbGVtZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiT2Zmc2NyZWVuQ2FudmFzIiwiY3JlYXRlUm9vdCIsInByZXZSb290IiwicHJldkZpYmVyIiwicHJldlN0b3JlIiwiY29uc29sZSIsIndhcm4iLCJsb2dSZWNvdmVyYWJsZUVycm9yIiwicmVwb3J0RXJyb3IiLCJjcmVhdGVDb250YWluZXIiLCJvbkNyZWF0ZWQiLCJsYXN0Q2FtZXJhIiwiY29uZmlndXJlZCIsInBlbmRpbmciLCJjb25maWd1cmUiLCJfcmVzb2x2ZSIsImdsQ29uZmlnIiwicHJvcHNTaXplIiwic2NlbmVPcHRpb25zIiwib25DcmVhdGVkQ2FsbGJhY2siLCJzaGFkb3dzIiwib3J0aG9ncmFwaGljIiwicmF5Y2FzdE9wdGlvbnMiLCJjYW1lcmFPcHRpb25zIiwiZGVmYXVsdFByb3BzIiwicG93ZXJQcmVmZXJlbmNlIiwiYW50aWFsaWFzIiwiYWxwaGEiLCJjdXN0b21SZW5kZXJlciIsIldlYkdMUmVuZGVyZXIiLCJSYXljYXN0ZXIiLCJwYXJhbXMiLCJvcHRpb25zIiwiaXNDYW1lcmEiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsInoiLCJyb3RhdGlvbiIsImxvb2tBdCIsImlzU2NlbmUiLCJTY2VuZSIsIl9nbCR4ciIsImhhbmRsZVhSRnJhbWUiLCJmcmFtZSIsImhhbmRsZVNlc3Npb25DaGFuZ2UiLCJpc1ByZXNlbnRpbmciLCJzZXRBbmltYXRpb25Mb29wIiwiY29ubmVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkaXNjb25uZWN0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNoYWRvd01hcCIsIm9sZEVuYWJsZWQiLCJvbGRUeXBlIiwiUENGU29mdFNoYWRvd01hcCIsIl90eXBlcyRzaGFkb3dzIiwidHlwZXMiLCJiYXNpYyIsIkJhc2ljU2hhZG93TWFwIiwicGVyY2VudGFnZSIsIlBDRlNoYWRvd01hcCIsInNvZnQiLCJ2YXJpYW5jZSIsIlZTTVNoYWRvd01hcCIsIm5lZWRzVXBkYXRlIiwiQ29sb3JNYW5hZ2VtZW50Iiwib3V0cHV0Q29sb3JTcGFjZSIsIkxpbmVhclNSR0JDb2xvclNwYWNlIiwidG9uZU1hcHBpbmciLCJOb1RvbmVNYXBwaW5nIiwiQUNFU0ZpbG1pY1RvbmVNYXBwaW5nIiwidGhlbiIsInVwZGF0ZUNvbnRhaW5lciIsIlByb3ZpZGVyIiwicm9vdEVsZW1lbnQiLCJ1bm1vdW50IiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsIl9zdGF0ZSRnbCIsIl9zdGF0ZSRnbCRyZW5kZXJMaXN0cyIsIl9zdGF0ZSRnbDIiLCJfc3RhdGUkZ2wzIiwicmVuZGVyTGlzdHMiLCJmb3JjZUNvbnRleHRMb3NzIiwiY3JlYXRlUG9ydGFsIiwiUG9ydGFsIiwicmVzdCIsInVzZVN0YXRlIiwiaW5qZWN0IiwiaW5qZWN0U3RhdGUiLCJ1c2VQb3J0YWxTdG9yZSIsIm9uTXV0YXRlIiwicHJldiIsInNldFN0YXRlIiwiZmx1c2hTeW5jIiwiZmx1c2hTeW5jRnJvbVJlY29uY2lsZXIiLCJjcmVhdGVTdWJzIiwic3VicyIsInN1YiIsImdsb2JhbEVmZmVjdHMiLCJnbG9iYWxBZnRlckVmZmVjdHMiLCJnbG9iYWxUYWlsRWZmZWN0cyIsImFkZEVmZmVjdCIsImFkZEFmdGVyRWZmZWN0IiwiYWRkVGFpbCIsInJ1biIsImVmZmVjdHMiLCJmbHVzaEdsb2JhbEVmZmVjdHMiLCJzdWJzY3JpcHRpb24iLCJ1cGRhdGUiLCJnZXREZWx0YSIsIm9sZFRpbWUiLCJydW5uaW5nIiwidXNlRnJhbWVJblByb2dyZXNzIiwicmVwZWF0IiwibG9vcCIsIl9zdGF0ZSRnbCR4ciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiX3N0YXRlJGdsJHhyMiIsIkRPTV9FVkVOVFMiLCJvbkNsaWNrIiwib25Db250ZXh0TWVudSIsIm9uRG91YmxlQ2xpY2siLCJvbldoZWVsIiwib25Qb2ludGVyRG93biIsIm9uUG9pbnRlclVwIiwib25Qb2ludGVyQ2FuY2VsIiwib25Mb3N0UG9pbnRlckNhcHR1cmUiLCJjcmVhdGVQb2ludGVyRXZlbnRzIiwic2V0RnJvbUNhbWVyYSIsInJlZHVjZSIsImFjYyIsIl9pbnRlcm5hbCRsYXN0RXZlbnQiLCJldmVudE5hbWUiLCJwYXNzaXZlIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIl8iLCJjIiwiZCIsImYiLCJnIiwiaiIsImsiLCJsIiwibSIsIm4iLCJxIiwiciIsInQiLCJ1IiwidiJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   act: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   addEffect: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   addTail: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   advance: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   applyProps: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   context: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   createEvents: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createPortal: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   createRoot: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   dispose: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   events: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   extend: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   flushSync: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   getRootState: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   invalidate: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   reconciler: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   useGraph: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   useLoader: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   useStore: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   useThree: () => (/* reexport safe */ _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.C)\n/* harmony export */ });\n/* harmony import */ var _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events-e3cb66e2.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-e3cb66e2.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/index.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction CanvasImpl({ ref, children, fallback, resize, style, gl, events = _events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.f, eventSource, eventPrefix, shadows, linear, flat, legacy, orthographic, frameloop, dpr, performance, raycaster, camera, scene, onPointerMissed, onCreated, ...props }) {\n    // Create a known catalogue of Threejs-native elements\n    // This will include the entire THREE namespace by default, users can extend\n    // their own elements by using the createRoot API instead\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo({\n        \"CanvasImpl.useMemo\": ()=>(0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__)\n    }[\"CanvasImpl.useMemo\"], []);\n    const Bridge = (0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)();\n    const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n        scroll: true,\n        debounce: {\n            scroll: 50,\n            resize: 0\n        },\n        ...resize\n    });\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const divRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, {\n        \"CanvasImpl.useImperativeHandle\": ()=>canvasRef.current\n    }[\"CanvasImpl.useImperativeHandle\"]);\n    const handlePointerMissed = (0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(onPointerMissed);\n    const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    // Suspend this component if block is a promise (2nd run)\n    if (block) throw block;\n    // Throw exception outwards if anything within canvas throws\n    if (error) throw error;\n    const root = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    (0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)({\n        \"CanvasImpl.useIsomorphicLayoutEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n                if (!root.current) root.current = (0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(canvas);\n                async function run() {\n                    await root.current.configure({\n                        gl,\n                        scene,\n                        events,\n                        shadows,\n                        linear,\n                        flat,\n                        legacy,\n                        orthographic,\n                        frameloop,\n                        dpr,\n                        performance,\n                        raycaster,\n                        camera,\n                        size: containerRect,\n                        // Pass mutable reference to onPointerMissed so it's free to update\n                        onPointerMissed: {\n                            \"CanvasImpl.useIsomorphicLayoutEffect.run\": (...args)=>handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args)\n                        }[\"CanvasImpl.useIsomorphicLayoutEffect.run\"],\n                        onCreated: {\n                            \"CanvasImpl.useIsomorphicLayoutEffect.run\": (state)=>{\n                                // Connect to event source\n                                state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n                                // Set up compute function\n                                if (eventPrefix) {\n                                    state.setEvents({\n                                        compute: {\n                                            \"CanvasImpl.useIsomorphicLayoutEffect.run\": (event, state)=>{\n                                                const x = event[eventPrefix + 'X'];\n                                                const y = event[eventPrefix + 'Y'];\n                                                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                                                state.raycaster.setFromCamera(state.pointer, state.camera);\n                                            }\n                                        }[\"CanvasImpl.useIsomorphicLayoutEffect.run\"]\n                                    });\n                                }\n                                // Call onCreated callback\n                                onCreated == null ? void 0 : onCreated(state);\n                            }\n                        }[\"CanvasImpl.useIsomorphicLayoutEffect.run\"]\n                    });\n                    root.current.render(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Bridge, {\n                        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n                            set: setError,\n                            children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n                                fallback: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                                    set: setBlock\n                                }),\n                                children: children != null ? children : null\n                            })\n                        })\n                    }));\n                }\n                run();\n            }\n        }\n    }[\"CanvasImpl.useIsomorphicLayoutEffect\"]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"CanvasImpl.useEffect\": ()=>{\n            const canvas = canvasRef.current;\n            if (canvas) return ({\n                \"CanvasImpl.useEffect\": ()=>(0,_events_e3cb66e2_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas)\n            })[\"CanvasImpl.useEffect\"];\n        }\n    }[\"CanvasImpl.useEffect\"], []);\n    // When the event source is not this div, we need to set pointer-events to none\n    // Or else the canvas will block events from reaching the event source\n    const pointerEvents = eventSource ? 'none' : 'auto';\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        ref: divRef,\n        style: {\n            position: 'relative',\n            width: '100%',\n            height: '100%',\n            overflow: 'hidden',\n            pointerEvents,\n            ...style\n        },\n        ...props,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n            ref: containerRef,\n            style: {\n                width: '100%',\n                height: '100%'\n            },\n            children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"canvas\", {\n                ref: canvasRef,\n                style: {\n                    display: 'block'\n                },\n                children: fallback\n            })\n        })\n    });\n}\n/**\r\n * A DOM canvas which accepts threejs elements as children.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\r\n */ function Canvas(props) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(its_fine__WEBPACK_IMPORTED_MODULE_8__.FiberProvider, {\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CanvasImpl, {\n            ...props\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9QO0FBQ2tSO0FBQ3ZlO0FBQ0E7QUFDWTtBQUNGO0FBQ0Q7QUFDSjtBQUNQO0FBQ047QUFDRztBQUNQO0FBRW5CLFNBQVMwRSxXQUFXLEVBQ2xCQyxHQUFHLEVBQ0hDLFFBQVEsRUFDUkMsUUFBUSxFQUNSQyxNQUFNLEVBQ05DLEtBQUssRUFDTEMsRUFBRSxFQUNGbEMsU0FBUzNCLHNEQUFtQixFQUM1QjhELFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxPQUFPLEVBQ1BDLE1BQU0sRUFDTkMsSUFBSSxFQUNKQyxNQUFNLEVBQ05DLFlBQVksRUFDWkMsU0FBUyxFQUNUQyxHQUFHLEVBQ0hDLFdBQVcsRUFDWEMsU0FBUyxFQUNUQyxNQUFNLEVBQ05DLEtBQUssRUFDTEMsZUFBZSxFQUNmQyxTQUFTLEVBQ1QsR0FBR0MsT0FDSjtJQUNDLHNEQUFzRDtJQUN0RCw0RUFBNEU7SUFDNUUseURBQXlEO0lBQ3pEM0IsMENBQWE7OEJBQUMsSUFBTXBFLDBEQUFNQSxDQUFDcUUsa0NBQUtBOzZCQUFHLEVBQUU7SUFDckMsTUFBTTRCLFNBQVMvRiwwREFBU0E7SUFDeEIsTUFBTSxDQUFDZ0csY0FBY0MsY0FBYyxHQUFHN0IsNkRBQVVBLENBQUM7UUFDL0M4QixRQUFRO1FBQ1JDLFVBQVU7WUFDUkQsUUFBUTtZQUNSdkIsUUFBUTtRQUNWO1FBQ0EsR0FBR0EsTUFBTTtJQUNYO0lBQ0EsTUFBTXlCLFlBQVlsQyx5Q0FBWSxDQUFDO0lBQy9CLE1BQU1vQyxTQUFTcEMseUNBQVksQ0FBQztJQUM1QkEsc0RBQXlCLENBQUNNOzBDQUFLLElBQU00QixVQUFVSSxPQUFPOztJQUN0RCxNQUFNQyxzQkFBc0J2RywwREFBa0JBLENBQUN5RjtJQUMvQyxNQUFNLENB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Q0FBQyxPQUFPO1FBQzdCRSxLQUFLOEI7UUFDTDFCLE9BQU87WUFDTHVELFVBQVU7WUFDVmxCLE9BQU87WUFDUEMsUUFBUTtZQUNSa0IsVUFBVTtZQUNWRjtZQUNBLEdBQUd0RCxLQUFLO1FBQ1Y7UUFDQSxHQUFHaUIsS0FBSztRQUNScEIsVUFBVSxXQUFXLEdBQUVILHNEQUFHQSxDQUFDLE9BQU87WUFDaENFLEtBQUt3QjtZQUNMcEIsT0FBTztnQkFDTHFDLE9BQU87Z0JBQ1BDLFFBQVE7WUFDVjtZQUNBekMsVUFBVSxXQUFXLEdBQUVILHNEQUFHQSxDQUFDLFVBQVU7Z0JBQ25DRSxLQUFLNEI7Z0JBQ0x4QixPQUFPO29CQUNMeUQsU0FBUztnQkFDWDtnQkFDQTVELFVBQVVDO1lBQ1o7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTNEQsT0FBT3pDLEtBQUs7SUFDbkIsT0FBTyxXQUFXLEdBQUV2QixzREFBR0EsQ0FBQ0QsbURBQWFBLEVBQUU7UUFDckNJLFVBQVUsV0FBVyxHQUFFSCxzREFBR0EsQ0FBQ0MsWUFBWTtZQUNyQyxHQUFHc0IsS0FBSztRQUNWO0lBQ0Y7QUFDRjtBQUVrQiIsInNvdXJjZXMiOlsiRDpcXFdlYl9BcHBzXFxSZWFjdC1Qcm9qZWN0c1xccXVvdGUtZGVjb2Rlclxcbm9kZV9tb2R1bGVzXFxAcmVhY3QtdGhyZWVcXGZpYmVyXFxkaXN0XFxyZWFjdC10aHJlZS1maWJlci5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZSBhcyBleHRlbmQsIHUgYXMgdXNlQnJpZGdlLCBhIGFzIHVzZU11dGFibGVDYWxsYmFjaywgYiBhcyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCBjIGFzIGNyZWF0ZVJvb3QsIGkgYXMgaXNSZWYsIEUgYXMgRXJyb3JCb3VuZGFyeSwgQiBhcyBCbG9jaywgZCBhcyB1bm1vdW50Q29tcG9uZW50QXROb2RlLCBmIGFzIGNyZWF0ZVBvaW50ZXJFdmVudHMgfSBmcm9tICcuL2V2ZW50cy1lM2NiNjZlMi5lc20uanMnO1xuZXhwb3J0IHsgdCBhcyBSZWFjdFRocmVlRmliZXIsIF8gYXMgX3Jvb3RzLCB4IGFzIGFjdCwgayBhcyBhZGRBZnRlckVmZmVjdCwgaiBhcyBhZGRFZmZlY3QsIGwgYXMgYWRkVGFpbCwgbiBhcyBhZHZhbmNlLCBzIGFzIGFwcGx5UHJvcHMsIHkgYXMgYnVpbGRHcmFwaCwgcSBhcyBjb250ZXh0LCBnIGFzIGNyZWF0ZUV2ZW50cywgbyBhcyBjcmVhdGVQb3J0YWwsIGMgYXMgY3JlYXRlUm9vdCwgdyBhcyBkaXNwb3NlLCBmIGFzIGV2ZW50cywgZSBhcyBleHRlbmQsIGggYXMgZmx1c2hHbG9iYWxFZmZlY3RzLCBwIGFzIGZsdXNoU3luYywgdiBhcyBnZXRSb290U3RhdGUsIG0gYXMgaW52YWxpZGF0ZSwgciBhcyByZWNvbmNpbGVyLCBkIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUsIEQgYXMgdXNlRnJhbWUsIEYgYXMgdXNlR3JhcGgsIHogYXMgdXNlSW5zdGFuY2VIYW5kbGUsIEcgYXMgdXNlTG9hZGVyLCBBIGFzIHVzZVN0b3JlLCBDIGFzIHVzZVRocmVlIH0gZnJvbSAnLi9ldmVudHMtZTNjYjY2ZTIuZXNtLmpzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB1c2VNZWFzdXJlIGZyb20gJ3JlYWN0LXVzZS1tZWFzdXJlJztcbmltcG9ydCB7IEZpYmVyUHJvdmlkZXIgfSBmcm9tICdpdHMtZmluZSc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgJ3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzJztcbmltcG9ydCAnenVzdGFuZC90cmFkaXRpb25hbCc7XG5pbXBvcnQgJ3N1c3BlbmQtcmVhY3QnO1xuaW1wb3J0ICdyZWFjdC1yZWNvbmNpbGVyJztcbmltcG9ydCAnc2NoZWR1bGVyJztcblxuZnVuY3Rpb24gQ2FudmFzSW1wbCh7XG4gIHJlZixcbiAgY2hpbGRyZW4sXG4gIGZhbGxiYWNrLFxuICByZXNpemUsXG4gIHN0eWxlLFxuICBnbCxcbiAgZXZlbnRzID0gY3JlYXRlUG9pbnRlckV2ZW50cyxcbiAgZXZlbnRTb3VyY2UsXG4gIGV2ZW50UHJlZml4LFxuICBzaGFkb3dzLFxuICBsaW5lYXIsXG4gIGZsYXQsXG4gIGxlZ2FjeSxcbiAgb3J0aG9ncmFwaGljLFxuICBmcmFtZWxvb3AsXG4gIGRwcixcbiAgcGVyZm9ybWFuY2UsXG4gIHJheWNhc3RlcixcbiAgY2FtZXJhLFxuICBzY2VuZSxcbiAgb25Qb2ludGVyTWlzc2VkLFxuICBvbkNyZWF0ZWQsXG4gIC4uLnByb3BzXG59KSB7XG4gIC8vIENyZWF0ZSBhIGtub3duIGNhdGFsb2d1ZSBvZiBUaHJlZWpzLW5hdGl2ZSBlbGVtZW50c1xuICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgZW50aXJlIFRIUkVFIG5hbWVzcGFjZSBieSBkZWZhdWx0LCB1c2VycyBjYW4gZXh0ZW5kXG4gIC8vIHRoZWlyIG93biBlbGVtZW50cyBieSB1c2luZyB0aGUgY3JlYXRlUm9vdCBBUEkgaW5zdGVhZFxuICBSZWFjdC51c2VNZW1vKCgpID0+IGV4dGVuZChUSFJFRSksIFtdKTtcbiAgY29uc3QgQnJpZGdlID0gdXNlQnJpZGdlKCk7XG4gIGNvbnN0IFtjb250YWluZXJSZWYsIGNvbnRhaW5lclJlY3RdID0gdXNlTWVhc3VyZSh7XG4gICAgc2Nyb2xsOiB0cnVlLFxuICAgIGRlYm91bmNlOiB7XG4gICAgICBzY3JvbGw6IDUwLFxuICAgICAgcmVzaXplOiAwXG4gICAgfSxcbiAgICAuLi5yZXNpemVcbiAgfSk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZGl2UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gY2FudmFzUmVmLmN1cnJlbnQpO1xuICBjb25zdCBoYW5kbGVQb2ludGVyTWlzc2VkID0gdXNlTXV0YWJsZUNhbGxiYWNrKG9uUG9pbnRlck1pc3NlZCk7XG4gIGNvbnN0IFtibG9jaywgc2V0QmxvY2tdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBTdXNwZW5kIHRoaXMgY29tcG9uZW50IGlmIGJsb2NrIGlzIGEgcHJvbWlzZSAoMm5kIHJ1bilcbiAgaWYgKGJsb2NrKSB0aHJvdyBibG9jaztcbiAgLy8gVGhyb3cgZXhjZXB0aW9uIG91dHdhcmRzIGlmIGFueXRoaW5nIHdpdGhpbiBjYW52YXMgdGhyb3dzXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gIGNvbnN0IHJvb3QgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmIChjb250YWluZXJSZWN0LndpZHRoID4gMCAmJiBjb250YWluZXJSZWN0LmhlaWdodCA+IDAgJiYgY2FudmFzKSB7XG4gICAgICBpZiAoIXJvb3QuY3VycmVudCkgcm9vdC5jdXJyZW50ID0gY3JlYXRlUm9vdChjYW52YXMpO1xuICAgICAgYXN5bmMgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgICBhd2FpdCByb290LmN1cnJlbnQuY29uZmlndXJlKHtcbiAgICAgICAgICBnbCxcbiAgICAgICAgICBzY2VuZSxcbiAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgc2hhZG93cyxcbiAgICAgICAgICBsaW5lYXIsXG4gICAgICAgICAgZmxhdCxcbiAgICAgICAgICBsZWdhY3ksXG4gICAgICAgICAgb3J0aG9ncmFwaGljLFxuICAgICAgICAgIGZyYW1lbG9vcCxcbiAgICAgICAgICBkcHIsXG4gICAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgICAgcmF5Y2FzdGVyLFxuICAgICAgICAgIGNhbWVyYSxcbiAgICAgICAgICBzaXplOiBjb250YWluZXJSZWN0LFxuICAgICAgICAgIC8vIFBhc3MgbXV0YWJsZSByZWZlcmVuY2UgdG8gb25Qb2ludGVyTWlzc2VkIHNvIGl0J3MgZnJlZSB0byB1cGRhdGVcbiAgICAgICAgICBvblBvaW50ZXJNaXNzZWQ6ICguLi5hcmdzKSA9PiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCguLi5hcmdzKSxcbiAgICAgICAgICBvbkNyZWF0ZWQ6IHN0YXRlID0+IHtcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gZXZlbnQgc291cmNlXG4gICAgICAgICAgICBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3QoZXZlbnRTb3VyY2UgPyBpc1JlZihldmVudFNvdXJjZSkgPyBldmVudFNvdXJjZS5jdXJyZW50IDogZXZlbnRTb3VyY2UgOiBkaXZSZWYuY3VycmVudCk7XG4gICAgICAgICAgICAvLyBTZXQgdXAgY29tcHV0ZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKGV2ZW50UHJlZml4KSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNldEV2ZW50cyh7XG4gICAgICAgICAgICAgICAgY29tcHV0ZTogKGV2ZW50LCBzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IGV2ZW50W2V2ZW50UHJlZml4ICsgJ1gnXTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBldmVudFtldmVudFByZWZpeCArICdZJ107XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5wb2ludGVyLnNldCh4IC8gc3RhdGUuc2l6ZS53aWR0aCAqIDIgLSAxLCAtKHkgLyBzdGF0ZS5zaXplLmhlaWdodCkgKiAyICsgMSk7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxsIG9uQ3JlYXRlZCBjYWxsYmFja1xuICAgICAgICAgICAgb25DcmVhdGVkID09IG51bGwgPyB2b2lkIDAgOiBvbkNyZWF0ZWQoc3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJvb3QuY3VycmVudC5yZW5kZXIoIC8qI19fUFVSRV9fKi9qc3goQnJpZGdlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICAgICAgc2V0OiBzZXRFcnJvcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KFJlYWN0LlN1c3BlbnNlLCB7XG4gICAgICAgICAgICAgIGZhbGxiYWNrOiAvKiNfX1BVUkVfXyovanN4KEJsb2NrLCB7XG4gICAgICAgICAgICAgICAgc2V0OiBzZXRCbG9ja1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuICE9IG51bGwgPyBjaGlsZHJlbiA6IG51bGxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgcnVuKCk7XG4gICAgfVxuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY2FudmFzKSByZXR1cm4gKCkgPT4gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMpO1xuICB9LCBbXSk7XG5cbiAgLy8gV2hlbiB0aGUgZXZlbnQgc291cmNlIGlzIG5vdCB0aGlzIGRpdiwgd2UgbmVlZCB0byBzZXQgcG9pbnRlci1ldmVudHMgdG8gbm9uZVxuICAvLyBPciBlbHNlIHRoZSBjYW52YXMgd2lsbCBibG9jayBldmVudHMgZnJvbSByZWFjaGluZyB0aGUgZXZlbnQgc291cmNlXG4gIGNvbnN0IHBvaW50ZXJFdmVudHMgPSBldmVudFNvdXJjZSA/ICdub25lJyA6ICdhdXRvJztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgIHJlZjogZGl2UmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIHBvaW50ZXJFdmVudHMsXG4gICAgICAuLi5zdHlsZVxuICAgIH0sXG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgICBzdHlsZToge1xuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KFwiY2FudmFzXCIsIHtcbiAgICAgICAgcmVmOiBjYW52YXNSZWYsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZmFsbGJhY2tcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59XG5cbi8qKlxyXG4gKiBBIERPTSBjYW52YXMgd2hpY2ggYWNjZXB0cyB0aHJlZWpzIGVsZW1lbnRzIGFzIGNoaWxkcmVuLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9jYW52YXNcclxuICovXG5mdW5jdGlvbiBDYW52YXMocHJvcHMpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goRmliZXJQcm92aWRlciwge1xuICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KENhbnZhc0ltcGwsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IENhbnZhcyB9O1xuIl0sIm5hbWVzIjpbImUiLCJleHRlbmQiLCJ1IiwidXNlQnJpZGdlIiwiYSIsInVzZU11dGFibGVDYWxsYmFjayIsImIiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiYyIsImNyZWF0ZVJvb3QiLCJpIiwiaXNSZWYiLCJFIiwiRXJyb3JCb3VuZGFyeSIsIkIiLCJCbG9jayIsImQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwiZiIsImNyZWF0ZVBvaW50ZXJFdmVudHMiLCJ0IiwiUmVhY3RUaHJlZUZpYmVyIiwiXyIsIl9yb290cyIsIngiLCJhY3QiLCJrIiwiYWRkQWZ0ZXJFZmZlY3QiLCJqIiwiYWRkRWZmZWN0IiwibCIsImFkZFRhaWwiLCJuIiwiYWR2YW5jZSIsInMiLCJhcHBseVByb3BzIiwieSIsImJ1aWxkR3JhcGgiLCJxIiwiY29udGV4dCIsImciLCJjcmVhdGVFdmVudHMiLCJvIiwiY3JlYXRlUG9ydGFsIiwidyIsImRpc3Bvc2UiLCJldmVudHMiLCJoIiwiZmx1c2hHbG9iYWxFZmZlY3RzIiwicCIsImZsdXNoU3luYyIsInYiLCJnZXRSb290U3RhdGUiLCJtIiwiaW52YWxpZGF0ZSIsInIiLCJyZWNvbmNpbGVyIiwiRCIsInVzZUZyYW1lIiwiRiIsInVzZUdyYXBoIiwieiIsInVzZUluc3RhbmNlSGFuZGxlIiwiRyIsInVzZUxvYWRlciIsIkEiLCJ1c2VTdG9yZSIsIkMiLCJ1c2VUaHJlZSIsIlJlYWN0IiwiVEhSRUUiLCJ1c2VNZWFzdXJlIiwiRmliZXJQcm92aWRlciIsImpzeCIsIkNhbnZhc0ltcGwiLCJyZWYiLCJjaGlsZHJlbiIsImZhbGxiYWNrIiwicmVzaXplIiwic3R5bGUiLCJnbCIsImV2ZW50U291cmNlIiwiZXZlbnRQcmVmaXgiLCJzaGFkb3dzIiwibGluZWFyIiwiZmxhdCIsImxlZ2FjeSIsIm9ydGhvZ3JhcGhpYyIsImZyYW1lbG9vcCIsImRwciIsInBlcmZvcm1hbmNlIiwicmF5Y2FzdGVyIiwiY2FtZXJhIiwic2NlbmUiLCJvblBvaW50ZXJNaXNzZWQiLCJvbkNyZWF0ZWQiLCJwcm9wcyIsInVzZU1lbW8iLCJCcmlkZ2UiLCJjb250YWluZXJSZWYiLCJjb250YWluZXJSZWN0Iiwic2Nyb2xsIiwiZGVib3VuY2UiLCJjYW52YXNSZWYiLCJ1c2VSZWYiLCJkaXZSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiY3VycmVudCIsImhhbmRsZVBvaW50ZXJNaXNzZWQiLCJibG9jayIsInNldEJsb2NrIiwidXNlU3RhdGUiLCJlcnJvciIsInNldEVycm9yIiwicm9vdCIsImNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0IiwicnVuIiwiY29uZmlndXJlIiwic2l6ZSIsImFyZ3MiLCJzdGF0ZSIsImNvbm5lY3QiLCJzZXRFdmVudHMiLCJjb21wdXRlIiwiZXZlbnQiLCJwb2ludGVyIiwic2V0Iiwic2V0RnJvbUNhbWVyYSIsInJlbmRlciIsIlN1c3BlbnNlIiwidXNlRWZmZWN0IiwicG9pbnRlckV2ZW50cyIsInBvc2l0aW9uIiwib3ZlcmZsb3ciLCJkaXNwbGF5IiwiQ2FudmFzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ })

};
;